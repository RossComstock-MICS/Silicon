'use strict';

var coreNodejs = require('./core-nodejs.js');
var core = require('./core.js');
var path = require('node:path');
var fs = require('fs');
var glob = require('glob');
var ignore = require('ignore');
var deepmerge = require('deepmerge');
var prompts = require('prompts');
require('./meta-helper.js');
var kleur = require('kleur');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var ignore__default = /*#__PURE__*/_interopDefault(ignore);
var deepmerge__default = /*#__PURE__*/_interopDefault(deepmerge);
var prompts__default = /*#__PURE__*/_interopDefault(prompts);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);

const DEFAULT_EXTENSIONS = ["html"];
function isDirectory(filename) {
    const st = fs__default.default.statSync(filename);
    return st.isDirectory();
}
function join(stem, filename) {
    if (path__default.default.isAbsolute(filename)) {
        return path__default.default.normalize(filename);
    }
    else {
        return path__default.default.normalize(path__default.default.join(stem, filename));
    }
}
function directoryPattern(extensions) {
    switch (extensions.length) {
        case 0:
            return "**/*";
        case 1:
            return `**/*.${extensions[0]}`;
        default:
            return `**/*.{${extensions.join(",")}}`;
    }
}
/**
 * Takes a number of file patterns (globs) and returns array of expanded
 * filenames.
 */
function expandFiles(patterns, options) {
    var _a, _b;
    const cwd = (_a = options.cwd) !== null && _a !== void 0 ? _a : process.cwd();
    const extensions = (_b = options.extensions) !== null && _b !== void 0 ? _b : DEFAULT_EXTENSIONS;
    const files = patterns.reduce((result, pattern) => {
        /* process - as standard input */
        if (pattern === "-") {
            result.push("/dev/stdin");
            return result;
        }
        for (const filename of glob.globSync(pattern, { cwd })) {
            /* if file is a directory recursively expand files from it */
            const fullpath = join(cwd, filename);
            if (isDirectory(fullpath)) {
                const dir = expandFiles([directoryPattern(extensions)], { ...options, cwd: fullpath });
                result = result.concat(dir.map((cur) => join(filename, cur)));
                continue;
            }
            result.push(fullpath);
        }
        return result.sort((a, b) => {
            const pa = a.split("/").length;
            const pb = b.split("/").length;
            if (pa !== pb) {
                return pa - pb;
            }
            else {
                return a > b ? 1 : -1;
            }
        });
    }, []);
    /* only return unique matches */
    return Array.from(new Set(files));
}

function wrap(formatter, dst) {
    return (results) => {
        const output = formatter(results);
        if (dst) {
            const dir = path__default.default.dirname(dst);
            if (!fs__default.default.existsSync(dir)) {
                fs__default.default.mkdirSync(dir, { recursive: true });
            }
            fs__default.default.writeFileSync(dst, output, "utf-8");
            return "";
        }
        else {
            return output;
        }
    };
}
function loadFormatter(name) {
    const fn = core.getFormatter(name);
    if (fn) {
        return fn;
    }
    try {
        return coreNodejs.legacyRequire(name);
    }
    catch (error) {
        throw new core.UserError(`No formatter named "${name}"`, core.ensureError(error));
    }
}
function getFormatter(formatters) {
    const fn = formatters.split(",").map((cur) => {
        const [name, dst] = cur.split("=", 2);
        const fn = loadFormatter(name);
        return wrap(fn, dst);
    });
    return (report) => {
        return fn
            .map((formatter) => formatter(report.results))
            .filter(Boolean)
            .join("\n");
    };
}

class IsIgnored {
    constructor() {
        this.cacheIgnore = new Map();
    }
    /**
     * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
     * one of them contains a pattern matching given filename.
     */
    isIgnored(filename) {
        return this.match(filename);
    }
    /**
     * Clear cache
     */
    clearCache() {
        this.cacheIgnore.clear();
    }
    match(target) {
        let current = path__default.default.dirname(target);
        // eslint-disable-next-line no-constant-condition -- breaks out when filesystem is traversed
        while (true) {
            const relative = path__default.default.relative(current, target);
            const filename = path__default.default.join(current, ".htmlvalidateignore");
            /* test filename (relative to the ignore file) against the patterns */
            const ig = this.parseFile(filename);
            if (ig && ig.ignores(relative)) {
                return true;
            }
            /* get the parent directory */
            const child = current;
            current = path__default.default.dirname(current);
            /* stop if this is the root directory */
            if (current === child) {
                break;
            }
        }
        return false;
    }
    parseFile(filename) {
        if (this.cacheIgnore.has(filename)) {
            return this.cacheIgnore.get(filename);
        }
        if (!fs__default.default.existsSync(filename)) {
            this.cacheIgnore.set(filename, undefined);
            return undefined;
        }
        const content = fs__default.default.readFileSync(filename, "utf-8");
        const ig = ignore__default.default().add(content);
        this.cacheIgnore.set(filename, ig);
        return ig;
    }
}

var Frameworks;
(function (Frameworks) {
    Frameworks["angularjs"] = "AngularJS";
    Frameworks["vuejs"] = "Vue.js";
    Frameworks["markdown"] = "Markdown";
})(Frameworks || (Frameworks = {}));
const frameworkConfig = {
    [Frameworks.angularjs]: {
        transform: {
            "^.*\\.js$": "html-validate-angular/js",
            "^.*\\.html$": "html-validate-angular/html",
        },
    },
    [Frameworks.vuejs]: {
        plugins: ["html-validate-vue"],
        extends: ["html-validate-vue:recommended"],
        transform: {
            "^.*\\.vue$": "html-validate-vue",
        },
    },
    [Frameworks.markdown]: {
        transform: {
            "^.*\\.md$": "html-validate-markdown",
        },
    },
};
function addFrameworks(src, frameworks) {
    let config = src;
    for (const framework of frameworks) {
        config = deepmerge__default.default(config, frameworkConfig[framework]);
    }
    return config;
}
function writeConfig(dst, config) {
    return new Promise((resolve, reject) => {
        fs__default.default.writeFile(dst, JSON.stringify(config, null, 2), (err) => {
            if (err)
                reject(err);
            resolve();
        });
    });
}
async function init$1(cwd) {
    const filename = `${cwd}/.htmlvalidate.json`;
    const exists = fs__default.default.existsSync(filename);
    const initialConfig = {
        elements: ["html5"],
        extends: ["html-validate:recommended"],
    };
    /* confirm overwrite */
    if (exists) {
        const result = await prompts__default.default({
            name: "overwrite",
            type: "confirm",
            message: "A .htmlvalidate.json file already exists, do you want to overwrite it?",
        });
        if (!result.overwrite) {
            return Promise.reject();
        }
    }
    const questions = [
        {
            name: "frameworks",
            type: "multiselect",
            choices: [
                { title: Frameworks.angularjs, value: Frameworks.angularjs },
                { title: Frameworks.vuejs, value: Frameworks.vuejs },
                { title: Frameworks.markdown, value: Frameworks.markdown },
            ],
            message: "Support additional frameworks?",
        },
    ];
    /* prompt user for questions */
    const answers = await prompts__default.default(questions);
    /* write configuration to file */
    let config = initialConfig;
    config = addFrameworks(config, answers.frameworks);
    await writeConfig(filename, config);
    return {
        filename,
    };
}

const defaultConfig = {
    extends: ["html-validate:recommended"],
};
function getBaseConfig(filename) {
    if (filename) {
        const resolver = coreNodejs.nodejsResolver();
        const configData = resolver.resolveConfig(path__default.default.resolve(filename), { cache: false });
        if (!configData) {
            throw new core.UserError(`Failed to read configuration from "${filename}"`);
        }
        return configData;
    }
    else {
        return defaultConfig;
    }
}
/**
 * @public
 */
class CLI {
    /**
     * Create new CLI helper.
     *
     * Can be used to create tooling with similar properties to bundled CLI
     * script.
     */
    constructor(options) {
        this.options = options !== null && options !== void 0 ? options : {};
        this.config = this.resolveConfig();
        this.loader = new coreNodejs.FileSystemConfigLoader(this.config);
        this.ignored = new IsIgnored();
    }
    /**
     * Returns list of files matching patterns and are not ignored. Filenames will
     * have absolute paths.
     *
     * @public
     */
    expandFiles(patterns, options = {}) {
        return expandFiles(patterns, options).filter((filename) => !this.isIgnored(filename));
    }
    getFormatter(formatters) {
        return getFormatter(formatters);
    }
    /**
     * Initialize project with a new configuration.
     *
     * A new `.htmlvalidate.json` file will be placed in the path provided by
     * `cwd`.
     */
    init(cwd) {
        return init$1(cwd);
    }
    /**
     * Searches ".htmlvalidateignore" files from filesystem and returns `true` if
     * one of them contains a pattern matching given filename.
     */
    isIgnored(filename) {
        return this.ignored.isIgnored(filename);
    }
    /**
     * Clear cache.
     *
     * Previously fetched [[HtmlValidate]] instances must either be fetched again
     * or call [[HtmlValidate.flushConfigCache]].
     */
    /* istanbul ignore next: each method is tested separately */
    clearCache() {
        this.loader.flushCache();
        this.ignored.clearCache();
    }
    /**
     * Get HtmlValidate instance with configuration based on options passed to the
     * constructor.
     *
     * @internal
     */
    getLoader() {
        return this.loader;
    }
    /**
     * Get HtmlValidate instance with configuration based on options passed to the
     * constructor.
     *
     * @public
     */
    getValidator() {
        const loader = this.getLoader();
        return new core.HtmlValidate(loader);
    }
    /**
     * @internal
     */
    getConfig() {
        return this.config;
    }
    resolveConfig() {
        const { options } = this;
        const config = getBaseConfig(options.configFile);
        let rules = options.rules;
        if (rules) {
            if (Array.isArray(rules)) {
                rules = rules.join(",");
            }
            const raw = rules
                .split(",")
                .map((it) => it.trim().replace(/([^:]*):/, '"$1":'))
                .join(",");
            try {
                const rules = JSON.parse(`{${raw}}`);
                config.extends = [];
                config.rules = rules;
            }
            catch (err) /* istanbul ignore next */ {
                const message = err instanceof Error ? err.message : String(err);
                throw new core.UserError(`Error while parsing --rule option "{${raw}}": ${message}.\n`);
            }
        }
        return config;
    }
}

/**
 * @internal
 */
exports.Mode = void 0;
(function (Mode) {
    Mode[Mode["LINT"] = 0] = "LINT";
    Mode[Mode["INIT"] = 1] = "INIT";
    Mode[Mode["DUMP_EVENTS"] = 2] = "DUMP_EVENTS";
    Mode[Mode["DUMP_TOKENS"] = 3] = "DUMP_TOKENS";
    Mode[Mode["DUMP_TREE"] = 4] = "DUMP_TREE";
    Mode[Mode["DUMP_SOURCE"] = 5] = "DUMP_SOURCE";
    Mode[Mode["PRINT_CONFIG"] = 6] = "PRINT_CONFIG";
})(exports.Mode || (exports.Mode = {}));
function modeToFlag(mode) {
    switch (mode) {
        case exports.Mode.LINT:
            return null;
        case exports.Mode.INIT:
            return "--init";
        case exports.Mode.DUMP_EVENTS:
            return "--dump-events";
        case exports.Mode.DUMP_TOKENS:
            return "--dump-tokens";
        case exports.Mode.DUMP_TREE:
            return "--dump-tree";
        case exports.Mode.DUMP_SOURCE:
            return "--dump-source";
        case exports.Mode.PRINT_CONFIG:
            return "--print-config";
    }
}

function renameStdin(report, filename) {
    const stdin = report.results.find((cur) => cur.filePath === "/dev/stdin");
    if (stdin) {
        stdin.filePath = filename;
    }
}
function lint(htmlvalidate, output, files, options) {
    const reports = files.map((filename) => {
        try {
            return htmlvalidate.validateFileSync(filename);
        }
        catch (err) {
            const message = kleur__default.default.red(`Validator crashed when parsing "${filename}"`);
            output.write(`${message}\n`);
            throw err;
        }
    });
    const merged = core.Reporter.merge(reports);
    /* rename stdin if an explicit filename was passed */
    if (options.stdinFilename) {
        renameStdin(merged, options.stdinFilename);
    }
    output.write(options.formatter(merged));
    if (options.maxWarnings >= 0 && merged.warningCount > options.maxWarnings) {
        output.write(`\nhtml-validate found too many warnings (maximum: ${options.maxWarnings}).\n`);
        return Promise.resolve(false);
    }
    return Promise.resolve(merged.valid);
}

async function init(cli, output, options) {
    const result = await cli.init(options.cwd);
    output.write(`Configuration written to "${result.filename}"\n`);
    return true;
}

async function printConfig(htmlvalidate, output, files) {
    if (files.length > 1) {
        output.write(`\`--print-config\` expected a single filename but got multiple:\n\n`);
        for (const filename of files) {
            output.write(`  - ${filename}\n`);
        }
        output.write("\n");
        return false;
    }
    const config = await htmlvalidate.getConfigFor(files[0]);
    const json = JSON.stringify(config.getConfigData(), null, 2);
    output.write(`${json}\n`);
    return true;
}

const jsonIgnored = [
    "annotation",
    "blockedRules",
    "cache",
    "closed",
    "depth",
    "disabledRules",
    "nodeType",
    "unique",
    "voidElement",
];
const jsonFiltered = [
    "childNodes",
    "children",
    "data",
    "meta",
    "metaElement",
    "originalData",
    "parent",
];
function isLocation(key, value) {
    return Boolean(value && (key === "location" || key.endsWith("Location")));
}
function isIgnored(key) {
    return Boolean(key.startsWith("_") || jsonIgnored.includes(key));
}
function isFiltered(key, value) {
    return Boolean(value && jsonFiltered.includes(key));
}
function eventReplacer(key, value) {
    if (isLocation(key, value)) {
        return `${value.filename}:${value.line}:${value.column}`;
    }
    if (isIgnored(key)) {
        return undefined;
    }
    if (isFiltered(key, value)) {
        return "[truncated]";
    }
    return value;
}
function eventFormatter(entry) {
    const strdata = JSON.stringify(entry.data, eventReplacer, 2);
    return `${entry.event}: ${strdata}`;
}

function dump(htmlvalidate, output, files, mode) {
    let lines = [];
    switch (mode) {
        case exports.Mode.DUMP_EVENTS:
            lines = files.map((filename) => htmlvalidate.dumpEvents(filename).map(eventFormatter));
            break;
        case exports.Mode.DUMP_TOKENS:
            lines = files.map((filename) => htmlvalidate.dumpTokens(filename).map((entry) => {
                const data = JSON.stringify(entry.data);
                return `TOKEN: ${entry.token}\n  Data: ${data}\n  Location: ${entry.location}`;
            }));
            break;
        case exports.Mode.DUMP_TREE:
            lines = files.map((filename) => htmlvalidate.dumpTree(filename));
            break;
        case exports.Mode.DUMP_SOURCE:
            lines = files.map((filename) => htmlvalidate.dumpSource(filename));
            break;
        default:
            throw new Error(`Unknown mode "${mode}"`);
    }
    const flat = lines.reduce((s, c) => s.concat(c), []);
    output.write(flat.join("\n"));
    output.write("\n");
    return Promise.resolve(true);
}

exports.CLI = CLI;
exports.dump = dump;
exports.init = init;
exports.lint = lint;
exports.modeToFlag = modeToFlag;
exports.printConfig = printConfig;
//# sourceMappingURL=cli.js.map
