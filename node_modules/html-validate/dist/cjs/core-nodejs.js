'use strict';

var fs = require('node:fs');
var path = require('node:path');
var core = require('./core.js');
var kleur = require('kleur');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);

/**
 * Similar to `require(..)` but removes the cached copy first.
 */
function requireUncached(require, moduleId) {
    const filename = require.resolve(moduleId);
    /* remove references from the parent module to prevent memory leak */
    const m = require.cache[filename];
    if (m === null || m === void 0 ? void 0 : m.parent) {
        const { parent } = m;
        for (let i = parent.children.length - 1; i >= 0; i--) {
            if (parent.children[i].id === filename) {
                parent.children.splice(i, 1);
            }
        }
    }
    /* remove old module from cache */
    /* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- needed to perform its function */
    delete require.cache[filename];
    /* eslint-disable-next-line import/no-dynamic-require, security/detect-non-literal-require -- as expected but should be moved to upcoming resolver class */
    return require(filename);
}

const legacyRequire = require;

let cachedRootDir = null;
/**
 * @internal
 */
function determineRootDirImpl(intial, fs) {
    /* try to locate package.json */
    let current = intial;
    // eslint-disable-next-line no-constant-condition -- break outs when filesystem is traversed
    while (true) {
        const search = path__default.default.join(current, "package.json");
        if (fs.existsSync(search)) {
            return current;
        }
        /* get the parent directory */
        const child = current;
        current = path__default.default.dirname(current);
        /* stop if this is the root directory */
        if (current === child) {
            break;
        }
    }
    /* default to working directory if no package.json is found */
    return intial;
}
/**
 * Try to determine root directory based on the location of the closest
 * `package.json`. Fallbacks on `process.cwd()` if no package.json was found.
 *
 * @internal
 */
/* istanbul ignore next: cached version of determineRootDirImpl, no need to test */
function determineRootDir() {
    if (cachedRootDir === null) {
        cachedRootDir = determineRootDirImpl(process.cwd(), fs__default.default);
    }
    return cachedRootDir;
}

/**
 * @internal
 */
function expandRelativePath(value, { cwd }) {
    if (typeof value === "string" && value.startsWith(".")) {
        return path__default.default.normalize(path__default.default.join(cwd, value));
    }
    else {
        return value;
    }
}

function isRequireError(error) {
    return Boolean(error && typeof error === "object" && "code" in error);
}
function isTransformer(value) {
    return typeof value === "function";
}
/**
 * Create a new resolver for NodeJS packages using `require(..)`.
 *
 * If the module name contains `<rootDir>` (e.g. `<rootDir/foo`) it will be
 * expanded relative to the root directory either explicitly set by the
 * `rootDir` parameter or determined automatically by the closest `package.json`
 * file (starting at the current working directory).
 *
 * @public
 * @since 8.0.0
 */
function nodejsResolver(options = {}) {
    var _a;
    const rootDir = (_a = options.rootDir) !== null && _a !== void 0 ? _a : determineRootDir();
    function internalRequire(id, { cache }) {
        const moduleName = id.replace("<rootDir>", rootDir);
        try {
            /* istanbul ignore else: the tests only runs the cached versions to get
             * unmodified access to `require`, the implementation of `requireUncached`
             * is assumed to be tested elsewhere */
            if (cache) {
                return legacyRequire(moduleName);
            }
            else {
                return requireUncached(legacyRequire, moduleName);
            }
        }
        catch (err) {
            if (isRequireError(err) && err.code === "MODULE_NOT_FOUND") {
                return null;
            }
            throw err;
        }
    }
    return {
        name: "nodejs-resolver",
        resolveElements(id, options) {
            return internalRequire(id, options);
        },
        resolveConfig(id, options) {
            const configData = internalRequire(id, options);
            if (!configData) {
                return null;
            }
            /* expand any relative paths */
            const cwd = path__default.default.dirname(id);
            const expand = (value) => expandRelativePath(value, { cwd });
            if (configData.elements) {
                configData.elements = configData.elements.map(expand);
            }
            if (configData.extends) {
                configData.extends = configData.extends.map(expand);
            }
            if (configData.plugins) {
                configData.plugins = configData.plugins.map(expand);
            }
            return configData;
        },
        resolvePlugin(id, options) {
            return internalRequire(id, options);
        },
        resolveTransformer(id, options) {
            const mod = internalRequire(id, options);
            if (!mod) {
                return null;
            }
            if (isTransformer(mod)) {
                return mod;
            }
            /* this is not a proper transformer, is it a plugin exposing a transformer? */
            if (mod.transformer) {
                throw new core.ConfigError(`Module "${id}" is not a valid transformer. This looks like a plugin, did you forget to load the plugin first?`);
            }
            throw new core.ConfigError(`Module "${id}" is not a valid transformer.`);
        },
    };
}

/**
 * @internal
 */
function findConfigurationFiles(fs, directory) {
    return ["json", "cjs", "js"]
        .map((extension) => path__default.default.join(directory, `.htmlvalidate.${extension}`))
        .filter((filePath) => fs.existsSync(filePath));
}
const defaultResolvers = [nodejsResolver()];
function hasResolver(value) {
    return Array.isArray(value[0]);
}
/**
 * Loads configuration by traversing filesystem.
 *
 * Configuration is read from three sources and in the following order:
 *
 * 1. Global configuration passed to constructor.
 * 2. Configuration files found when traversing the directory structure.
 * 3. Override passed to this function.
 *
 * The following configuration filenames are searched:
 *
 * - `.htmlvalidate.json`
 * - `.htmlvalidate.js`
 * - `.htmlvalidate.cjs`
 *
 * Global configuration is used when no configuration file is found. The
 * result is always merged with override if present.
 *
 * The `root` property set to `true` affects the configuration as following:
 *
 * 1. If set in override the override is returned as-is.
 * 2. If set in the global config the override is merged into global and
 * returned. No configuration files are searched.
 * 3. Setting `root` in configuration file only stops directory traversal.
 *
 * @public
 */
class FileSystemConfigLoader extends core.ConfigLoader {
    constructor(...args) {
        var _a, _b;
        if (hasResolver(args)) {
            /* istanbul ignore next */
            const [resolvers, config, options = {}] = args;
            super(resolvers, config);
            this.fs = /* istanbul ignore next */ (_a = options.fs) !== null && _a !== void 0 ? _a : fs__default.default;
        }
        else {
            /* istanbul ignore next */
            const [config, options = {}] = args;
            super(defaultResolvers, config);
            this.fs = /* istanbul ignore next */ (_b = options.fs) !== null && _b !== void 0 ? _b : fs__default.default;
        }
        this.cache = new Map();
    }
    /**
     * Get configuration for given filename.
     *
     * @param filename - Filename to get configuration for.
     * @param configOverride - Configuration to merge final result with.
     */
    getConfigFor(filename, configOverride) {
        /* special case when the overridden configuration is marked as root, should
         * not try to load any more configuration files */
        const override = this.loadFromObject(configOverride !== null && configOverride !== void 0 ? configOverride : {});
        if (override.isRootFound()) {
            override.init();
            return override.resolve();
        }
        /* special case when the global configuration is marked as root, should not
         * try to load and more configuration files */
        if (this.globalConfig.isRootFound()) {
            const merged = this.globalConfig.merge(this.resolvers, override);
            merged.init();
            return merged.resolve();
        }
        const config = this.fromFilename(filename);
        const merged = config
            ? config.merge(this.resolvers, override)
            : this.globalConfig.merge(this.resolvers, override);
        merged.init();
        return merged.resolve();
    }
    /**
     * Flush configuration cache.
     *
     * @param filename - If given only the cache for that file is flushed.
     */
    flushCache(filename) {
        if (filename) {
            this.cache.delete(filename);
        }
        else {
            this.cache.clear();
        }
    }
    /**
     * Load raw configuration from directory traversal.
     *
     * This configuration is not merged with global configuration and may return
     * `null` if no configuration files are found.
     */
    fromFilename(filename) {
        if (filename === "inline") {
            return null;
        }
        const cache = this.cache.get(filename);
        if (cache) {
            return cache;
        }
        let found = false;
        let current = path__default.default.resolve(path__default.default.dirname(filename));
        let config = this.empty();
        // eslint-disable-next-line no-constant-condition -- it will break out when filesystem is traversed
        while (true) {
            /* search configuration files in current directory */
            for (const configFile of findConfigurationFiles(this.fs, current)) {
                const local = this.loadFromFile(configFile);
                found = true;
                config = local.merge(this.resolvers, config);
            }
            /* stop if a configuration with "root" is set to true */
            if (config.isRootFound()) {
                break;
            }
            /* get the parent directory */
            const child = current;
            current = path__default.default.dirname(current);
            /* stop if this is the root directory */
            if (current === child) {
                break;
            }
        }
        /* no config was found by loader, return null and let caller decide what to do */
        if (!found) {
            this.cache.set(filename, null);
            return null;
        }
        this.cache.set(filename, config);
        return config;
    }
    /**
     * @internal For testing only
     */
    _getInternalCache() {
        return this.cache;
    }
    defaultConfig() {
        return core.Config.defaultConfig();
    }
}

const defaults = {
    silent: false,
    version: core.version,
    logger(text) {
        /* eslint-disable-next-line no-console -- expected to log */
        console.error(kleur__default.default.red(text));
    },
};
/**
 * Tests if plugin is compatible with html-validate library. Unless the `silent`
 * option is used a warning is displayed on the console.
 *
 * @public
 * @since v5.0.0
 * @param name - Name of plugin
 * @param declared - What library versions the plugin support (e.g. declared peerDependencies)
 * @returns - `true` if version is compatible
 */
function compatibilityCheck(name, declared, options) {
    return core.compatibilityCheckImpl(name, declared, {
        ...defaults,
        ...options,
    });
}

exports.FileSystemConfigLoader = FileSystemConfigLoader;
exports.compatibilityCheck = compatibilityCheck;
exports.legacyRequire = legacyRequire;
exports.nodejsResolver = nodejsResolver;
//# sourceMappingURL=core-nodejs.js.map
