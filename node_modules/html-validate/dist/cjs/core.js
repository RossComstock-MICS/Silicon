'use strict';

var Ajv = require('ajv');
var deepmerge = require('deepmerge');
var elements = require('./elements.js');
var fs = require('fs');
var betterAjvErrors = require('@sidvind/better-ajv-errors');
var utils_naturalJoin = require('./utils/natural-join.js');
var codeFrame = require('@babel/code-frame');
var kleur = require('kleur');
var stylish$2 = require('@html-validate/stylish');
var semver = require('semver');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefault(Ajv);
var deepmerge__default = /*#__PURE__*/_interopDefault(deepmerge);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var betterAjvErrors__default = /*#__PURE__*/_interopDefault(betterAjvErrors);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);
var semver__default = /*#__PURE__*/_interopDefault(semver);

const $schema$2 = "http://json-schema.org/draft-06/schema#";
const $id$2 = "http://json-schema.org/draft-06/schema#";
const title = "Core schema meta-schema";
const definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
const type$2 = [
	"object",
	"boolean"
];
const properties$2 = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	examples: {
		type: "array",
		items: {
		}
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": {
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var ajvSchemaDraft = {
	$schema: $schema$2,
	$id: $id$2,
	title: title,
	definitions: definitions$1,
	type: type$2,
	properties: properties$2,
	"default": {
}
};

function stringify(value) {
    if (typeof value === "string") {
        return String(value);
    }
    else {
        return JSON.stringify(value);
    }
}
/**
 * Represents an `Error` created from arbitrary values.
 *
 * @public
 */
class WrappedError extends Error {
    constructor(message) {
        super(stringify(message));
    }
}

/**
 * Ensures the value is an Error.
 *
 * If the passed value is not an `Error` instance a [[WrappedError]] is
 * constructed with the stringified value.
 *
 * @internal
 */
function ensureError(value) {
    if (value instanceof Error) {
        return value;
    }
    else {
        return new WrappedError(value);
    }
}

/**
 * @public
 */
class NestedError extends Error {
    constructor(message, nested) {
        super(message);
        Error.captureStackTrace(this, NestedError);
        this.name = NestedError.name;
        if (nested === null || nested === void 0 ? void 0 : nested.stack) {
            this.stack += `\nCaused by: ${nested.stack}`;
        }
    }
}

/**
 * @public
 */
class UserError extends NestedError {
    constructor(message, nested) {
        super(message, nested);
        Error.captureStackTrace(this, UserError);
        this.name = UserError.name;
    }
    /**
     * @public
     */
    /* istanbul ignore next: default implementation */
    prettyFormat() {
        return undefined;
    }
}

/**
 * @internal
 */
class InheritError extends UserError {
    constructor({ tagName, inherit }) {
        const message = `Element <${tagName}> cannot inherit from <${inherit}>: no such element`;
        super(message);
        Error.captureStackTrace(this, InheritError);
        this.name = InheritError.name;
        this.tagName = tagName;
        this.inherit = inherit;
        this.filename = null;
    }
    prettyFormat() {
        const { message, tagName, inherit } = this;
        const source = this.filename
            ? ["", "This error occurred when loading element metadata from:", `"${this.filename}"`, ""]
            : [""];
        return [
            message,
            ...source,
            "This usually occurs when the elements are defined in the wrong order, try one of the following:",
            "",
            `  - Ensure the spelling of "${inherit}" is correct.`,
            `  - Ensure the file containing "${inherit}" is loaded before the file containing "${tagName}".`,
            `  - Move the definition of "${inherit}" above the definition for "${tagName}".`,
        ].join("\n");
    }
}

function getSummary(schema, obj, errors) {
    const output = betterAjvErrors__default.default(schema, obj, errors, {
        format: "js",
    });
    // istanbul ignore next: for safety only
    return output.length > 0 ? output[0].error : "unknown validation error";
}
/**
 * @public
 */
class SchemaValidationError extends UserError {
    constructor(filename, message, obj, schema, errors) {
        const summary = getSummary(schema, obj, errors);
        super(`${message}: ${summary}`);
        this.filename = filename;
        this.obj = obj;
        this.schema = schema;
        this.errors = errors;
    }
    prettyError() {
        const json = this.getRawJSON();
        return betterAjvErrors__default.default(this.schema, this.obj, this.errors, {
            format: "cli",
            indent: 2,
            json,
        });
    }
    getRawJSON() {
        if (this.filename && fs__default.default.existsSync(this.filename)) {
            return fs__default.default.readFileSync(this.filename, "utf-8");
        }
        else {
            return null;
        }
    }
}

/**
 * Computes hash for given string.
 *
 * @internal
 */
function cyrb53(str) {
    const a = 2654435761;
    const b = 1597334677;
    const c = 2246822507;
    const d = 3266489909;
    const e = 4294967296;
    const f = 2097151;
    const seed = 0;
    let h1 = 0xdeadbeef ^ seed;
    let h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, a);
        h2 = Math.imul(h2 ^ ch, b);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), c) ^ Math.imul(h2 ^ (h2 >>> 13), d);
    h2 = Math.imul(h2 ^ (h2 >>> 16), c) ^ Math.imul(h1 ^ (h1 >>> 13), d);
    return e * (f & h2) + (h1 >>> 0);
}
const computeHash = cyrb53;

const $schema$1 = "http://json-schema.org/draft-06/schema#";
const $id$1 = "https://html-validate.org/schemas/elements.json";
const type$1 = "object";
const properties$1 = {
	$schema: {
		type: "string"
	}
};
const patternProperties = {
	"^[^$].*$": {
		type: "object",
		properties: {
			inherit: {
				title: "Inherit from another element",
				description: "Most properties from the parent element will be copied onto this one",
				type: "string"
			},
			embedded: {
				title: "Mark this element as belonging in the embedded content category",
				$ref: "#/definitions/contentCategory"
			},
			flow: {
				title: "Mark this element as belonging in the flow content category",
				$ref: "#/definitions/contentCategory"
			},
			heading: {
				title: "Mark this element as belonging in the heading content category",
				$ref: "#/definitions/contentCategory"
			},
			interactive: {
				title: "Mark this element as belonging in the interactive content category",
				$ref: "#/definitions/contentCategory"
			},
			metadata: {
				title: "Mark this element as belonging in the metadata content category",
				$ref: "#/definitions/contentCategory"
			},
			phrasing: {
				title: "Mark this element as belonging in the phrasing content category",
				$ref: "#/definitions/contentCategory"
			},
			sectioning: {
				title: "Mark this element as belonging in the sectioning content category",
				$ref: "#/definitions/contentCategory"
			},
			deprecated: {
				title: "Mark element as deprecated",
				description: "Deprecated elements should not be used. If a message is provided it will be included in the error",
				anyOf: [
					{
						type: "boolean"
					},
					{
						type: "string"
					},
					{
						$ref: "#/definitions/deprecatedElement"
					}
				]
			},
			foreign: {
				title: "Mark element as foreign",
				description: "Foreign elements are elements which have a start and end tag but is otherwize not parsed",
				type: "boolean"
			},
			"void": {
				title: "Mark element as void",
				description: "Void elements are elements which cannot have content and thus must not use an end tag",
				type: "boolean"
			},
			transparent: {
				title: "Mark element as transparent",
				description: "Transparent elements follows the same content model as its parent, i.e. the content must be allowed in the parent.",
				anyOf: [
					{
						type: "boolean"
					},
					{
						type: "array",
						items: {
							type: "string"
						}
					}
				]
			},
			implicitClosed: {
				title: "List of elements which implicitly closes this element",
				description: "Some elements are automatically closed when another start tag occurs",
				type: "array",
				items: {
					type: "string"
				}
			},
			implicitRole: {
				title: "Implicit ARIA role for this element",
				description: "Some elements have implicit ARIA roles.",
				"function": true
			},
			scriptSupporting: {
				title: "Mark element as script-supporting",
				description: "Script-supporting elements are elements which can be inserted where othersise not permitted to assist in templating",
				type: "boolean"
			},
			form: {
				title: "Mark element as a submittable form element",
				type: "boolean"
			},
			formAssociated: {
				title: "Mark element as a form-associated element",
				$ref: "#/definitions/FormAssociated"
			},
			labelable: {
				title: "Mark this element as labelable",
				description: "This element may contain an associated label element.",
				anyOf: [
					{
						type: "boolean"
					},
					{
						$ref: "#/definitions/expression"
					}
				]
			},
			deprecatedAttributes: {
				title: "List of deprecated attributes",
				type: "array",
				items: {
					type: "string"
				}
			},
			requiredAttributes: {
				title: "List of required attributes",
				type: "array",
				items: {
					type: "string"
				}
			},
			attributes: {
				title: "List of known attributes and allowed values",
				$ref: "#/definitions/PermittedAttribute"
			},
			permittedContent: {
				title: "List of elements or categories allowed as content in this element",
				$ref: "#/definitions/Permitted"
			},
			permittedDescendants: {
				title: "List of elements or categories allowed as descendants in this element",
				$ref: "#/definitions/Permitted"
			},
			permittedOrder: {
				title: "Required order of child elements",
				$ref: "#/definitions/PermittedOrder"
			},
			permittedParent: {
				title: "List of elements or categories allowed as parent to this element",
				$ref: "#/definitions/Permitted"
			},
			requiredAncestors: {
				title: "List of required ancestor elements",
				$ref: "#/definitions/RequiredAncestors"
			},
			requiredContent: {
				title: "List of required content elements",
				$ref: "#/definitions/RequiredContent"
			},
			textContent: {
				title: "Allow, disallow or require textual content",
				description: "This property controls whenever an element allows, disallows or requires text. Text from any descendant counts, not only direct children",
				"default": "default",
				type: "string",
				"enum": [
					"none",
					"default",
					"required",
					"accessible"
				]
			}
		},
		additionalProperties: false
	}
};
const definitions = {
	contentCategory: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#/definitions/expression"
			}
		]
	},
	expression: {
		type: "array",
		minItems: 2,
		maxItems: 2,
		items: [
			{
				type: "string",
				"enum": [
					"isDescendant",
					"hasAttribute",
					"matchAttribute"
				]
			},
			{
				anyOf: [
					{
						type: "string"
					},
					{
						$ref: "#/definitions/operation"
					}
				]
			}
		]
	},
	operation: {
		type: "array",
		minItems: 3,
		maxItems: 3,
		items: [
			{
				type: "string"
			},
			{
				type: "string",
				"enum": [
					"!=",
					"="
				]
			},
			{
				type: "string"
			}
		]
	},
	deprecatedElement: {
		type: "object",
		additionalProperties: false,
		properties: {
			message: {
				type: "string",
				title: "A short text message shown next to the regular error message."
			},
			documentation: {
				type: "string",
				title: "An extended markdown formatted message shown with the contextual rule documentation."
			},
			source: {
				type: "string",
				title: "Element source, e.g. what standard or library deprecated this element.",
				"default": "html5"
			}
		}
	},
	FormAssociated: {
		type: "object",
		additionalProperties: false,
		properties: {
			listed: {
				type: "boolean",
				title: "Listed elements have a name attribute and is listed in the form and fieldset elements property."
			}
		}
	},
	Permitted: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "array",
					items: {
						anyOf: [
							{
								type: "string"
							},
							{
								$ref: "#/definitions/PermittedGroup"
							}
						]
					}
				},
				{
					$ref: "#/definitions/PermittedGroup"
				}
			]
		}
	},
	PermittedAttribute: {
		type: "object",
		patternProperties: {
			"^.*$": {
				anyOf: [
					{
						type: "object",
						additionalProperties: false,
						properties: {
							allowed: {
								"function": true,
								title: "Set to a function to evaluate if this attribute is allowed in this context"
							},
							boolean: {
								type: "boolean",
								title: "Set to true if this is a boolean attribute"
							},
							deprecated: {
								title: "Set to true or string if this attribute is deprecated",
								oneOf: [
									{
										type: "boolean"
									},
									{
										type: "string"
									}
								]
							},
							list: {
								type: "boolean",
								title: "Set to true if this attribute is a list of space-separated tokens, each which must be valid by itself"
							},
							"enum": {
								type: "array",
								title: "Exhaustive list of values (string or regex) this attribute accepts",
								uniqueItems: true,
								items: {
									anyOf: [
										{
											type: "string"
										},
										{
											regexp: true
										}
									]
								}
							},
							omit: {
								type: "boolean",
								title: "Set to true if this attribute can optionally omit its value"
							},
							required: {
								type: "boolean",
								title: "Set to true if this attribute is required"
							}
						}
					},
					{
						type: "array",
						uniqueItems: true,
						items: {
							type: "string"
						}
					},
					{
						type: "null"
					}
				]
			}
		}
	},
	PermittedGroup: {
		type: "object",
		additionalProperties: false,
		properties: {
			exclude: {
				anyOf: [
					{
						items: {
							type: "string"
						},
						type: "array"
					},
					{
						type: "string"
					}
				]
			}
		}
	},
	PermittedOrder: {
		type: "array",
		items: {
			type: "string"
		}
	},
	RequiredAncestors: {
		type: "array",
		items: {
			type: "string"
		}
	},
	RequiredContent: {
		type: "array",
		items: {
			type: "string"
		}
	}
};
var schema = {
	$schema: $schema$1,
	$id: $id$1,
	type: type$1,
	properties: properties$1,
	patternProperties: patternProperties,
	definitions: definitions
};

/**
 * AJV keyword "regexp" to validate the type to be a regular expression.
 * Injects errors with the "type" keyword to give the same output.
 */
/* istanbul ignore next: manual testing */
const ajvRegexpValidate = function (data, dataCxt) {
    const valid = data instanceof RegExp;
    if (!valid) {
        ajvRegexpValidate.errors = [
            {
                instancePath: dataCxt === null || dataCxt === void 0 ? void 0 : dataCxt.instancePath,
                schemaPath: undefined,
                keyword: "type",
                message: "should be a regular expression",
                params: {
                    keyword: "type",
                },
            },
        ];
    }
    return valid;
};
const ajvRegexpKeyword = {
    keyword: "regexp",
    schema: false,
    errors: true,
    validate: ajvRegexpValidate,
};

/**
 * AJV keyword "function" to validate the type to be a function. Injects errors
 * with the "type" keyword to give the same output.
 */
const ajvFunctionValidate = function (data, dataCxt) {
    const valid = typeof data === "function";
    if (!valid) {
        ajvFunctionValidate.errors = [
            {
                instancePath: /* istanbul ignore next */ dataCxt === null || dataCxt === void 0 ? void 0 : dataCxt.instancePath,
                schemaPath: undefined,
                keyword: "type",
                message: "should be a function",
                params: {
                    keyword: "type",
                },
            },
        ];
    }
    return valid;
};
const ajvFunctionKeyword = {
    keyword: "function",
    schema: false,
    errors: true,
    validate: ajvFunctionValidate,
};

/**
 * @public
 */
exports.TextContent = void 0;
(function (TextContent) {
    /* forbid node to have text content, inter-element whitespace is ignored */
    TextContent["NONE"] = "none";
    /* node can have text but not required too */
    TextContent["DEFAULT"] = "default";
    /* node requires text-nodes to be present (direct or by descendant) */
    TextContent["REQUIRED"] = "required";
    /* node requires accessible text (hidden text is ignored, tries to get text from accessibility tree) */
    TextContent["ACCESSIBLE"] = "accessible";
})(exports.TextContent || (exports.TextContent = {}));
/**
 * Properties listed here can be copied (loaded) onto another element using
 * [[HtmlElement.loadMeta]].
 *
 * @public
 */
const MetaCopyableProperty = [
    "metadata",
    "flow",
    "sectioning",
    "heading",
    "phrasing",
    "embedded",
    "interactive",
    "transparent",
    "form",
    "formAssociated",
    "labelable",
    "attributes",
    "permittedContent",
    "permittedDescendants",
    "permittedOrder",
    "permittedParent",
    "requiredAncestors",
    "requiredContent",
];
/**
 * @internal
 */
function setMetaProperty(dst, key, value) {
    dst[key] = value;
}

function isSet(value) {
    return typeof value !== "undefined";
}
function flag(value) {
    return value ? true : undefined;
}
function stripUndefined(src) {
    const entries = Object.entries(src).filter(([, value]) => isSet(value));
    return Object.fromEntries(entries);
}
function migrateSingleAttribute(src, key) {
    var _a, _b;
    const result = {};
    result.deprecated = flag((_a = src.deprecatedAttributes) === null || _a === void 0 ? void 0 : _a.includes(key));
    result.required = flag((_b = src.requiredAttributes) === null || _b === void 0 ? void 0 : _b.includes(key));
    result.omit = undefined;
    const attr = src.attributes ? src.attributes[key] : undefined;
    if (typeof attr === "undefined") {
        return stripUndefined(result);
    }
    /* when the attribute is set to null we use a special property "delete" to
     * flag it, if it is still set during merge (inheritance, overwriting, etc) the attribute will be removed */
    if (attr === null) {
        result.delete = true;
        return stripUndefined(result);
    }
    if (Array.isArray(attr)) {
        if (attr.length === 0) {
            result.boolean = true;
        }
        else {
            result.enum = attr.filter((it) => it !== "");
            if (attr.includes("")) {
                result.omit = true;
            }
        }
        return stripUndefined(result);
    }
    else {
        return stripUndefined({ ...result, ...attr });
    }
}
function migrateAttributes(src) {
    var _a, _b, _c;
    const keys = [
        ...Object.keys((_a = src.attributes) !== null && _a !== void 0 ? _a : {}),
        ...((_b = src.requiredAttributes) !== null && _b !== void 0 ? _b : []),
        ...((_c = src.deprecatedAttributes) !== null && _c !== void 0 ? _c : []),
    ].sort();
    const entries = keys.map((key) => {
        return [key, migrateSingleAttribute(src, key)];
    });
    return Object.fromEntries(entries);
}
function migrateElement(src) {
    var _a;
    const result = {
        ...src,
        ...{
            formAssociated: undefined,
        },
        attributes: migrateAttributes(src),
        textContent: src.textContent,
        implicitRole: (_a = src.implicitRole) !== null && _a !== void 0 ? _a : (() => null),
    };
    /* removed properties */
    delete result.deprecatedAttributes;
    delete result.requiredAttributes;
    /* strip out undefined */
    if (!result.textContent) {
        delete result.textContent;
    }
    if (src.formAssociated) {
        result.formAssociated = {
            listed: Boolean(src.formAssociated.listed),
        };
    }
    else {
        delete result.formAssociated;
    }
    return result;
}

/**
 * Returns true if given element is a descendant of given tagname.
 *
 * @internal
 */
function isDescendant(node, tagName) {
    let cur = node.parent;
    while (cur && !cur.isRootElement()) {
        if (cur.is(tagName)) {
            return true;
        }
        cur = cur.parent;
    }
    return false;
}

/**
 * Returns true if given element has given attribute (no matter the value, null,
 * dynamic, etc).
 */
function hasAttribute(node, attr) {
    return node.hasAttribute(attr);
}

/**
 * Matches attribute against value.
 */
function matchAttribute(node, key, op, value) {
    var _a;
    const nodeValue = ((_a = node.getAttributeValue(key)) !== null && _a !== void 0 ? _a : "").toLowerCase();
    switch (op) {
        case "!=":
            return nodeValue !== value;
        case "=":
            return nodeValue === value;
    }
}

const dynamicKeys = [
    "metadata",
    "flow",
    "sectioning",
    "heading",
    "phrasing",
    "embedded",
    "interactive",
    "labelable",
];
const functionTable = {
    isDescendant: isDescendantFacade,
    hasAttribute: hasAttributeFacade,
    matchAttribute: matchAttributeFacade,
};
const schemaCache = new Map();
function clone(src) {
    return JSON.parse(JSON.stringify(src));
}
function overwriteMerge$1(a, b) {
    return b;
}
/**
 * @public
 */
class MetaTable {
    /**
     * @internal
     */
    constructor() {
        this.elements = {};
        this.schema = clone(schema);
    }
    /**
     * @internal
     */
    init() {
        this.resolveGlobal();
    }
    /**
     * Extend validation schema.
     *
     * @public
     */
    extendValidationSchema(patch) {
        if (patch.properties) {
            this.schema = deepmerge__default.default(this.schema, {
                patternProperties: {
                    "^[^$].*$": {
                        properties: patch.properties,
                    },
                },
            });
        }
        if (patch.definitions) {
            this.schema = deepmerge__default.default(this.schema, {
                definitions: patch.definitions,
            });
        }
    }
    /**
     * Load metadata table from object.
     *
     * @public
     * @param obj - Object with metadata to load
     * @param filename - Optional filename used when presenting validation error
     */
    loadFromObject(obj, filename = null) {
        var _a;
        try {
            const validate = this.getSchemaValidator();
            if (!validate(obj)) {
                throw new SchemaValidationError(filename, `Element metadata is not valid`, obj, this.schema, 
                /* istanbul ignore next: AJV sets .errors when validate returns false */
                (_a = validate.errors) !== null && _a !== void 0 ? _a : []);
            }
            for (const [key, value] of Object.entries(obj)) {
                if (key === "$schema")
                    continue;
                this.addEntry(key, migrateElement(value));
            }
        }
        catch (err) {
            if (err instanceof InheritError) {
                err.filename = filename;
                throw err;
            }
            if (err instanceof SchemaValidationError) {
                throw err;
            }
            if (!filename) {
                throw err;
            }
            throw new UserError(`Failed to load element metadata from "${filename}"`, ensureError(err));
        }
    }
    /**
     * Get [[MetaElement]] for the given tag. If no specific metadata is present
     * the global metadata is returned or null if no global is present.
     *
     * @public
     * @returns A shallow copy of metadata.
     */
    getMetaFor(tagName) {
        /* try to locate by tagname */
        tagName = tagName.toLowerCase();
        if (this.elements[tagName]) {
            return { ...this.elements[tagName] };
        }
        /* try to locate global element */
        if (this.elements["*"]) {
            return { ...this.elements["*"] };
        }
        return null;
    }
    /**
     * Find all tags which has enabled given property.
     *
     * @public
     */
    getTagsWithProperty(propName) {
        return Object.entries(this.elements)
            .filter(([, entry]) => entry[propName])
            .map(([tagName]) => tagName);
    }
    /**
     * Find tag matching tagName or inheriting from it.
     *
     * @public
     */
    getTagsDerivedFrom(tagName) {
        return Object.entries(this.elements)
            .filter(([key, entry]) => key === tagName || entry.inherit === tagName)
            .map(([tagName]) => tagName);
    }
    addEntry(tagName, entry) {
        let parent = this.elements[tagName] || {};
        /* handle inheritance */
        if (entry.inherit) {
            const name = entry.inherit;
            parent = this.elements[name];
            if (!parent) {
                throw new InheritError({
                    tagName,
                    inherit: name,
                });
            }
        }
        /* merge all sources together */
        const expanded = this.mergeElement(parent, { ...entry, tagName });
        expandRegex(expanded);
        this.elements[tagName] = expanded;
    }
    /**
     * Construct a new AJV schema validator.
     */
    getSchemaValidator() {
        const hash = computeHash(JSON.stringify(this.schema));
        const cached = schemaCache.get(hash);
        if (cached) {
            return cached;
        }
        else {
            const ajv = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
            ajv.addMetaSchema(ajvSchemaDraft);
            ajv.addKeyword(ajvFunctionKeyword);
            ajv.addKeyword(ajvRegexpKeyword);
            ajv.addKeyword({ keyword: "copyable" });
            const validate = ajv.compile(this.schema);
            schemaCache.set(hash, validate);
            return validate;
        }
    }
    /**
     * @public
     */
    getJSONSchema() {
        return this.schema;
    }
    /**
     * Finds the global element definition and merges each known element with the
     * global, e.g. to assign global attributes.
     */
    resolveGlobal() {
        /* skip if there is no global elements */
        if (!this.elements["*"])
            return;
        /* fetch and remove the global element, it should not be resolvable by
         * itself */
        const global = this.elements["*"];
        delete this.elements["*"];
        /* hack: unset default properties which global should not override */
        delete global.tagName;
        delete global.void;
        /* merge elements */
        for (const [tagName, entry] of Object.entries(this.elements)) {
            this.elements[tagName] = this.mergeElement(global, entry);
        }
    }
    mergeElement(a, b) {
        const merged = deepmerge__default.default(a, b, { arrayMerge: overwriteMerge$1 });
        /* special handling when removing attributes by setting them to null
         * resulting in the deletion flag being set */
        const filteredAttrs = Object.entries(merged.attributes).filter(([, attr]) => {
            const val = !attr.delete;
            delete attr.delete;
            return val;
        });
        merged.attributes = Object.fromEntries(filteredAttrs);
        return merged;
    }
    /**
     * @internal
     */
    resolve(node) {
        if (node.meta) {
            expandProperties(node, node.meta);
        }
    }
}
function expandProperties(node, entry) {
    for (const key of dynamicKeys) {
        const property = entry[key];
        if (property && typeof property !== "boolean") {
            setMetaProperty(entry, key, evaluateProperty(node, property));
        }
    }
}
/**
 * Given a string it returns either the string as-is or if the string is wrapped
 * in /../ it creates and returns a regex instead.
 */
function expandRegexValue(value) {
    if (value instanceof RegExp) {
        return value;
    }
    const match = value.match(/^\/\^?([^/$]*)\$?\/([i]*)$/);
    if (match) {
        const [, expr, flags] = match;
        // eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp
        return new RegExp(`^${expr}$`, flags);
    }
    else {
        return value;
    }
}
/**
 * Expand all regular expressions in strings ("/../"). This mutates the object.
 */
function expandRegex(entry) {
    for (const [name, values] of Object.entries(entry.attributes)) {
        if (values.enum) {
            entry.attributes[name].enum = values.enum.map(expandRegexValue);
        }
    }
}
function evaluateProperty(node, expr) {
    const [func, options] = parseExpression(expr);
    return func(node, options);
}
function parseExpression(expr) {
    if (typeof expr === "string") {
        return parseExpression([expr, {}]);
    }
    else {
        /* eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- old style expressions should be replaced with typesafe functions */
        const [funcName, options] = expr;
        const func = functionTable[funcName];
        if (!func) {
            throw new Error(`Failed to find function "${funcName}" when evaluating property expression`);
        }
        return [func, options];
    }
}
function isDescendantFacade(node, tagName) {
    if (typeof tagName !== "string") {
        throw new Error(`Property expression "isDescendant" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    return isDescendant(node, tagName);
}
function hasAttributeFacade(node, attr) {
    if (typeof attr !== "string") {
        throw new Error(`Property expression "hasAttribute" must take string argument when evaluating metadata for <${node.tagName}>`);
    }
    return hasAttribute(node, attr);
}
function matchAttributeFacade(node, match) {
    if (!Array.isArray(match) || match.length !== 3) {
        throw new Error(`Property expression "matchAttribute" must take [key, op, value] array as argument when evaluating metadata for <${node.tagName}>`);
    }
    const [key, op, value] = match.map((x) => x.toLowerCase());
    switch (op) {
        case "!=":
        case "=":
            return matchAttribute(node, key, op, value);
        default:
            throw new Error(`Property expression "matchAttribute" has invalid operator "${op}" when evaluating metadata for <${node.tagName}>`);
    }
}

/**
 * @public
 */
class DynamicValue {
    constructor(expr) {
        this.expr = expr;
    }
    toString() {
        return this.expr;
    }
}

/**
 * DOM Attribute.
 *
 * Represents a HTML attribute. Can contain either a fixed static value or a
 * placeholder for dynamic values (e.g. interpolated).
 *
 * @public
 */
class Attribute {
    /**
     * @param key - Attribute name.
     * @param value - Attribute value. Set to `null` for boolean attributes.
     * @param keyLocation - Source location of attribute name.
     * @param valueLocation - Source location of attribute value.
     * @param originalAttribute - If this attribute was dynamically added via a
     * transformation (e.g. vuejs `:id` generating the `id` attribute) this
     * parameter should be set to the attribute name of the source attribute (`:id`).
     */
    constructor(key, value, keyLocation, valueLocation, originalAttribute) {
        this.key = key;
        this.value = value;
        this.keyLocation = keyLocation;
        this.valueLocation = valueLocation;
        this.originalAttribute = originalAttribute;
        /* force undefined to null */
        if (typeof this.value === "undefined") {
            this.value = null;
        }
    }
    /**
     * Flag set to true if the attribute value is static.
     */
    get isStatic() {
        return !this.isDynamic;
    }
    /**
     * Flag set to true if the attribute value is dynamic.
     */
    get isDynamic() {
        return this.value instanceof DynamicValue;
    }
    /**
     * Test attribute value.
     *
     * @param pattern - Pattern to match value against. Can be a RegExp, literal
     * string or an array of strings (returns true if any value matches the
     * array).
     * @param dynamicMatches - If true `DynamicValue` will always match, if false
     * it never matches.
     * @returns `true` if attribute value matches pattern.
     */
    valueMatches(pattern, dynamicMatches = true) {
        if (this.value === null) {
            return false;
        }
        /* dynamic values matches everything */
        if (this.value instanceof DynamicValue) {
            return dynamicMatches;
        }
        /* test against an array of keywords */
        if (Array.isArray(pattern)) {
            return pattern.includes(this.value);
        }
        /* test value against pattern */
        if (pattern instanceof RegExp) {
            return this.value.match(pattern) !== null;
        }
        else {
            return this.value === pattern;
        }
    }
}

function getCSSDeclarations(value) {
    return value
        .trim()
        .split(";")
        .filter(Boolean)
        .map((it) => {
        const [property, value] = it.split(":", 2);
        return [property.trim(), value ? value.trim() : ""];
    });
}
/**
 * @internal
 */
function parseCssDeclaration(value) {
    if (!value || value instanceof DynamicValue) {
        return {};
    }
    const pairs = getCSSDeclarations(value);
    return Object.fromEntries(pairs);
}

function sliceSize(size, begin, end) {
    if (typeof size !== "number") {
        return size;
    }
    if (typeof end !== "number") {
        return size - begin;
    }
    if (end < 0) {
        end = size + end;
    }
    return Math.min(size, end - begin);
}
function sliceLocation(location, begin, end, wrap) {
    if (!location)
        return null;
    const size = sliceSize(location.size, begin, end);
    const sliced = {
        filename: location.filename,
        offset: location.offset + begin,
        line: location.line,
        column: location.column + begin,
        size,
    };
    /* if text content is provided try to find all newlines and modify line/column accordingly */
    if (wrap) {
        let index = -1;
        const col = sliced.column;
        do {
            index = wrap.indexOf("\n", index + 1);
            if (index >= 0 && index < begin) {
                sliced.column = col - (index + 1);
                sliced.line++;
            }
            else {
                break;
            }
        } while (true); // eslint-disable-line no-constant-condition -- it will break out
    }
    return sliced;
}

var State;
(function (State) {
    State[State["INITIAL"] = 1] = "INITIAL";
    State[State["DOCTYPE"] = 2] = "DOCTYPE";
    State[State["TEXT"] = 3] = "TEXT";
    State[State["TAG"] = 4] = "TAG";
    State[State["ATTR"] = 5] = "ATTR";
    State[State["CDATA"] = 6] = "CDATA";
    State[State["SCRIPT"] = 7] = "SCRIPT";
    State[State["STYLE"] = 8] = "STYLE";
})(State || (State = {}));

var ContentModel;
(function (ContentModel) {
    ContentModel[ContentModel["TEXT"] = 1] = "TEXT";
    ContentModel[ContentModel["SCRIPT"] = 2] = "SCRIPT";
    ContentModel[ContentModel["STYLE"] = 3] = "STYLE";
})(ContentModel || (ContentModel = {}));
class Context {
    constructor(source) {
        var _a, _b, _c, _d;
        this.state = State.INITIAL;
        this.string = source.data;
        this.filename = (_a = source.filename) !== null && _a !== void 0 ? _a : "";
        this.offset = (_b = source.offset) !== null && _b !== void 0 ? _b : 0;
        this.line = (_c = source.line) !== null && _c !== void 0 ? _c : 1;
        this.column = (_d = source.column) !== null && _d !== void 0 ? _d : 1;
        this.contentModel = ContentModel.TEXT;
    }
    getTruncatedLine(n = 13) {
        return JSON.stringify(this.string.length > n ? `${this.string.slice(0, 10)}...` : this.string);
    }
    consume(n, state) {
        /* if "n" is an regex match the first value is the full matched
         * string so consume that many characters. */
        if (typeof n !== "number") {
            n = n[0].length; /* regex match */
        }
        /* poor mans line counter :( */
        let consumed = this.string.slice(0, n);
        let offset;
        while ((offset = consumed.indexOf("\n")) >= 0) {
            this.line++;
            this.column = 1;
            consumed = consumed.substr(offset + 1);
        }
        this.column += consumed.length;
        this.offset += n;
        /* remove N chars */
        this.string = this.string.substr(n);
        /* change state */
        this.state = state;
    }
    getLocation(size) {
        return {
            filename: this.filename,
            offset: this.offset,
            line: this.line,
            column: this.column,
            size,
        };
    }
}

/**
 * @public
 */
exports.NodeType = void 0;
(function (NodeType) {
    NodeType[NodeType["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
    NodeType[NodeType["TEXT_NODE"] = 3] = "TEXT_NODE";
    NodeType[NodeType["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
})(exports.NodeType || (exports.NodeType = {}));

const DOCUMENT_NODE_NAME = "#document";
const TEXT_CONTENT = Symbol("textContent");
let counter = 0;
/**
 * @public
 */
class DOMNode {
    /**
     * Create a new DOMNode.
     *
     * @param nodeType - What node type to create.
     * @param nodeName - What node name to use. For `HtmlElement` this corresponds
     * to the tagName but other node types have specific predefined values.
     * @param location - Source code location of this node.
     */
    constructor(nodeType, nodeName, location) {
        this.nodeType = nodeType;
        this.nodeName = nodeName !== null && nodeName !== void 0 ? nodeName : DOCUMENT_NODE_NAME;
        this.location = location;
        this.disabledRules = new Set();
        this.blockedRules = new Map();
        this.childNodes = [];
        this.unique = counter++;
        this.cache = null;
    }
    /**
     * Enable cache for this node.
     *
     * Should not be called before the node and all children are fully constructed.
     *
     * @internal
     */
    cacheEnable() {
        this.cache = new Map();
    }
    cacheGet(key) {
        if (this.cache) {
            return this.cache.get(key);
        }
        else {
            return undefined;
        }
    }
    cacheSet(key, value) {
        if (this.cache) {
            this.cache.set(key, value);
        }
        return value;
    }
    cacheRemove(key) {
        if (this.cache) {
            return this.cache.delete(key);
        }
        else {
            return false;
        }
    }
    cacheExists(key) {
        return Boolean(this.cache && this.cache.has(key));
    }
    /**
     * Get the text (recursive) from all child nodes.
     */
    get textContent() {
        const cached = this.cacheGet(TEXT_CONTENT);
        if (cached) {
            return cached;
        }
        const text = this.childNodes.map((node) => node.textContent).join("");
        this.cacheSet(TEXT_CONTENT, text);
        return text;
    }
    append(node) {
        this.childNodes.push(node);
    }
    isRootElement() {
        return this.nodeType === exports.NodeType.DOCUMENT_NODE;
    }
    /**
     * Tests if two nodes are the same (references the same object).
     *
     * @since v4.11.0
     */
    isSameNode(otherNode) {
        return this.unique === otherNode.unique;
    }
    /**
     * Returns a DOMNode representing the first direct child node or `null` if the
     * node has no children.
     */
    get firstChild() {
        return this.childNodes[0] || null;
    }
    /**
     * Returns a DOMNode representing the last direct child node or `null` if the
     * node has no children.
     */
    get lastChild() {
        return this.childNodes[this.childNodes.length - 1] || null;
    }
    /**
     * Block a rule for this node.
     *
     * @internal
     */
    blockRule(ruleId, blocker) {
        const current = this.blockedRules.get(ruleId);
        if (current) {
            current.push(blocker);
        }
        else {
            this.blockedRules.set(ruleId, [blocker]);
        }
    }
    /**
     * Blocks multiple rules.
     *
     * @internal
     */
    blockRules(rules, blocker) {
        for (const rule of rules) {
            this.blockRule(rule, blocker);
        }
    }
    /**
     * Disable a rule for this node.
     *
     * @internal
     */
    disableRule(ruleId) {
        this.disabledRules.add(ruleId);
    }
    /**
     * Disables multiple rules.
     *
     * @internal
     */
    disableRules(rules) {
        for (const rule of rules) {
            this.disableRule(rule);
        }
    }
    /**
     * Enable a previously disabled rule for this node.
     */
    enableRule(ruleId) {
        this.disabledRules.delete(ruleId);
    }
    /**
     * Enables multiple rules.
     */
    enableRules(rules) {
        for (const rule of rules) {
            this.enableRule(rule);
        }
    }
    /**
     * Test if a rule is enabled for this node.
     *
     * @internal
     */
    ruleEnabled(ruleId) {
        return !this.disabledRules.has(ruleId);
    }
    /**
     * Test if a rule is blocked for this node.
     *
     * @internal
     */
    ruleBlockers(ruleId) {
        var _a;
        return (_a = this.blockedRules.get(ruleId)) !== null && _a !== void 0 ? _a : [];
    }
    generateSelector() {
        return null;
    }
}

function parse(text, baseLocation) {
    const tokens = [];
    const locations = baseLocation ? [] : null;
    for (let begin = 0; begin < text.length;) {
        let end = text.indexOf(" ", begin);
        /* if the last space was found move the position to the last character
         * in the string */
        if (end === -1) {
            end = text.length;
        }
        /* handle multiple spaces */
        const size = end - begin;
        if (size === 0) {
            begin++;
            continue;
        }
        /* extract token */
        const token = text.substring(begin, end);
        tokens.push(token);
        /* extract location */
        if (locations && baseLocation) {
            const location = sliceLocation(baseLocation, begin, end);
            locations.push(location);
        }
        /* advance position to the character after the current end position */
        begin += size + 1;
    }
    return { tokens, locations };
}
/**
 * @public
 */
class DOMTokenList extends Array {
    constructor(value, location) {
        if (value && typeof value === "string") {
            /* replace all whitespace with a single space for easier parsing */
            const normalized = value.replace(/[\t\r\n]/g, " ");
            const { tokens, locations } = parse(normalized, location);
            super(...tokens);
            this.locations = locations;
        }
        else {
            super(0);
            this.locations = null;
        }
        if (value instanceof DynamicValue) {
            this.value = value.expr;
        }
        else {
            this.value = value !== null && value !== void 0 ? value : "";
        }
    }
    item(n) {
        return this[n];
    }
    location(n) {
        if (this.locations) {
            return this.locations[n];
        }
        else {
            throw new Error("Trying to access DOMTokenList location when base location isn't set");
        }
    }
    contains(token) {
        return this.includes(token);
    }
    *iterator() {
        for (let index = 0; index < this.length; index++) {
            /* eslint-disable @typescript-eslint/no-non-null-assertion -- as we loop over length this should always be set */
            const item = this.item(index);
            const location = this.location(index);
            /* eslint-enable @typescript-eslint/no-non-null-assertion */
            yield { index, item, location };
        }
    }
}

var Combinator;
(function (Combinator) {
    Combinator[Combinator["DESCENDANT"] = 1] = "DESCENDANT";
    Combinator[Combinator["CHILD"] = 2] = "CHILD";
    Combinator[Combinator["ADJACENT_SIBLING"] = 3] = "ADJACENT_SIBLING";
    Combinator[Combinator["GENERAL_SIBLING"] = 4] = "GENERAL_SIBLING";
    /* special cases */
    Combinator[Combinator["SCOPE"] = 5] = "SCOPE";
})(Combinator || (Combinator = {}));
function parseCombinator(combinator, pattern) {
    /* special case, when pattern is :scope [[Selector]] will handle this
     * "combinator" to match itself instead of descendants */
    if (pattern === ":scope") {
        return Combinator.SCOPE;
    }
    switch (combinator) {
        case undefined:
        case null:
        case "":
            return Combinator.DESCENDANT;
        case ">":
            return Combinator.CHILD;
        case "+":
            return Combinator.ADJACENT_SIBLING;
        case "~":
            return Combinator.GENERAL_SIBLING;
        default:
            throw new Error(`Unknown combinator "${combinator}"`);
    }
}

function firstChild(node) {
    return node.previousSibling === null;
}

function lastChild(node) {
    return node.nextSibling === null;
}

const cache = {};
function getNthChild(node) {
    if (!node.parent) {
        return -1;
    }
    if (!cache[node.unique]) {
        const parent = node.parent;
        const index = parent.childElements.findIndex((cur) => {
            return cur.unique === node.unique;
        });
        cache[node.unique] = index + 1; /* nthChild starts at 1 */
    }
    return cache[node.unique];
}
function nthChild(node, args) {
    if (!args) {
        throw new Error("Missing argument to nth-child");
    }
    const n = parseInt(args.trim(), 10);
    const cur = getNthChild(node);
    return cur === n;
}

function scope(node) {
    return node.isSameNode(this.scope);
}

const table = {
    "first-child": firstChild,
    "last-child": lastChild,
    "nth-child": nthChild,
    scope,
};
function factory(name, context) {
    const fn = table[name];
    if (fn) {
        return fn.bind(context);
    }
    else {
        throw new Error(`Pseudo-class "${name}" is not implemented`);
    }
}

/**
 * Homage to PHP: unescapes slashes.
 *
 * E.g. "foo\:bar" becomes "foo:bar"
 */
function stripslashes(value) {
    return value.replace(/\\(.)/g, "$1");
}
/**
 * @internal
 */
function escapeSelectorComponent(text) {
    return text.toString().replace(/([^a-z0-9_-])/gi, "\\$1");
}
/**
 * @internal
 */
function generateIdSelector(id) {
    const escaped = escapeSelectorComponent(id);
    return escaped.match(/^\d/) ? `[id="${escaped}"]` : `#${escaped}`;
}
/**
 * Returns true if the character is a delimiter for different kinds of selectors:
 *
 * - `.` - begins a class selector
 * - `#` - begins an id selector
 * - `[` - begins an attribute selector
 * - `:` - begins a pseudo class or element selector
 */
function isDelimiter(ch) {
    return /[.#[:]/.test(ch);
}
/**
 * Returns true if the character is a quotation mark.
 */
function isQuotationMark(ch) {
    return /['"]/.test(ch);
}
function isPseudoElement(ch, buffer) {
    return ch === ":" && buffer === ":";
}
/**
 * @internal
 */
function* splitPattern(pattern) {
    if (pattern === "") {
        return;
    }
    const end = pattern.length;
    let begin = 0;
    let cur = 1;
    let quoted = false;
    while (cur < end) {
        const ch = pattern[cur];
        const buffer = pattern.slice(begin, cur);
        /* escaped character, ignore whatever is next */
        if (ch === "\\") {
            cur += 2;
            continue;
        }
        /* if inside quoted string we only look for the end quotation mark */
        if (quoted) {
            if (ch === quoted) {
                quoted = false;
            }
            cur += 1;
            continue;
        }
        /* if the character is a quotation mark we store the character and the above
         * condition will look for a similar end quotation mark */
        if (isQuotationMark(ch)) {
            quoted = ch;
            cur += 1;
            continue;
        }
        /* special case when using :: pseudo element selector */
        if (isPseudoElement(ch, buffer)) {
            cur += 1;
            continue;
        }
        /* if the character is a delimiter we yield the string and reset the
         * position */
        if (isDelimiter(ch)) {
            begin = cur;
            yield buffer;
        }
        cur += 1;
    }
    /* yield the rest of the string */
    const tail = pattern.slice(begin, cur);
    yield tail;
}
class Matcher {
}
class ClassMatcher extends Matcher {
    constructor(classname) {
        super();
        this.classname = classname;
    }
    match(node) {
        return node.classList.contains(this.classname);
    }
}
class IdMatcher extends Matcher {
    constructor(id) {
        super();
        this.id = stripslashes(id);
    }
    match(node) {
        return node.id === this.id;
    }
}
class AttrMatcher extends Matcher {
    constructor(attr) {
        super();
        const [, key, op, value] = attr.match(/^(.+?)(?:([~^$*|]?=)"([^"]+?)")?$/); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
        this.key = key;
        this.op = op;
        this.value = value;
    }
    match(node) {
        const attr = node.getAttribute(this.key, true) || [];
        return attr.some((cur) => {
            switch (this.op) {
                case undefined:
                    return true; /* attribute exists */
                case "=":
                    return cur.value === this.value;
                default:
                    throw new Error(`Attribute selector operator ${this.op} is not implemented yet`);
            }
        });
    }
}
class PseudoClassMatcher extends Matcher {
    constructor(pseudoclass, context) {
        super();
        const match = pseudoclass.match(/^([^(]+)(?:\((.*)\))?$/);
        if (!match) {
            throw new Error(`Missing pseudo-class after colon in selector pattern "${context}"`);
        }
        const [, name, args] = match;
        this.name = name;
        this.args = args;
    }
    match(node, context) {
        const fn = factory(this.name, context);
        return fn(node, this.args);
    }
}
class Pattern {
    constructor(pattern) {
        const match = pattern.match(/^([~+\->]?)((?:[*]|[^.#[:]+)?)(.*)$/); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
        match.shift(); /* remove full matched string */
        this.selector = pattern;
        this.combinator = parseCombinator(match.shift(), pattern);
        this.tagName = match.shift() || "*"; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing -- empty string */
        this.pattern = Array.from(splitPattern(match[0]), (it) => this.createMatcher(it));
    }
    match(node, context) {
        return node.is(this.tagName) && this.pattern.every((cur) => cur.match(node, context));
    }
    createMatcher(pattern) {
        switch (pattern[0]) {
            case ".":
                return new ClassMatcher(pattern.slice(1));
            case "#":
                return new IdMatcher(pattern.slice(1));
            case "[":
                return new AttrMatcher(pattern.slice(1, -1));
            case ":":
                return new PseudoClassMatcher(pattern.slice(1), this.selector);
            default:
                /* istanbul ignore next: fallback solution, the switch cases should cover
                 * everything and there is no known way to trigger this fallback */
                throw new Error(`Failed to create matcher for "${pattern}"`);
        }
    }
}
/**
 * DOM Selector.
 */
class Selector {
    constructor(selector) {
        this.pattern = Selector.parse(selector);
    }
    /**
     * Match this selector against a HtmlElement.
     *
     * @param root - Element to match against.
     * @returns Iterator with matched elements.
     */
    *match(root) {
        const context = { scope: root };
        yield* this.matchInternal(root, 0, context);
    }
    *matchInternal(root, level, context) {
        if (level >= this.pattern.length) {
            yield root;
            return;
        }
        const pattern = this.pattern[level];
        const matches = Selector.findCandidates(root, pattern);
        for (const node of matches) {
            if (!pattern.match(node, context)) {
                continue;
            }
            yield* this.matchInternal(node, level + 1, context);
        }
    }
    static parse(selector) {
        /* strip whitespace before combinators, "ul > li" becomes "ul >li", for
         * easier parsing */
        selector = selector.replace(/([+~>]) /g, "$1");
        const pattern = selector.split(/(?:(?<!\\) )+/);
        return pattern.map((part) => new Pattern(part));
    }
    static findCandidates(root, pattern) {
        switch (pattern.combinator) {
            case Combinator.DESCENDANT:
                return root.getElementsByTagName(pattern.tagName);
            case Combinator.CHILD:
                return root.childElements.filter((node) => node.is(pattern.tagName));
            case Combinator.ADJACENT_SIBLING:
                return Selector.findAdjacentSibling(root);
            case Combinator.GENERAL_SIBLING:
                return Selector.findGeneralSibling(root);
            case Combinator.SCOPE:
                return [root];
        }
        /* istanbul ignore next: fallback solution, the switch cases should cover
         * everything and there is no known way to trigger this fallback */
        return [];
    }
    static findAdjacentSibling(node) {
        let adjacent = false;
        return node.siblings.filter((cur) => {
            if (adjacent) {
                adjacent = false;
                return true;
            }
            if (cur === node) {
                adjacent = true;
            }
            return false;
        });
    }
    static findGeneralSibling(node) {
        let after = false;
        return node.siblings.filter((cur) => {
            if (after) {
                return true;
            }
            if (cur === node) {
                after = true;
            }
            return false;
        });
    }
}

const TEXT_NODE_NAME = "#text";
/**
 * Returns true if the node is a text node.
 *
 * @public
 */
function isTextNode(node) {
    return Boolean(node && node.nodeType === exports.NodeType.TEXT_NODE);
}
/**
 * Represents a text in the HTML document.
 *
 * Text nodes are appended as children of `HtmlElement` and cannot have childen
 * of its own.
 *
 * @public
 */
class TextNode extends DOMNode {
    /**
     * @param text - Text to add. When a `DynamicValue` is used the expression is
     * used as "text".
     * @param location - Source code location of this node.
     */
    constructor(text, location) {
        super(exports.NodeType.TEXT_NODE, TEXT_NODE_NAME, location);
        this.text = text;
    }
    /**
     * Get the text from node.
     */
    get textContent() {
        return this.text.toString();
    }
    /**
     * Flag set to true if the attribute value is static.
     */
    get isStatic() {
        return !this.isDynamic;
    }
    /**
     * Flag set to true if the attribute value is dynamic.
     */
    get isDynamic() {
        return this.text instanceof DynamicValue;
    }
}

/**
 * @public
 */
exports.NodeClosed = void 0;
(function (NodeClosed) {
    NodeClosed[NodeClosed["Open"] = 0] = "Open";
    NodeClosed[NodeClosed["EndTag"] = 1] = "EndTag";
    NodeClosed[NodeClosed["VoidOmitted"] = 2] = "VoidOmitted";
    NodeClosed[NodeClosed["VoidSelfClosed"] = 3] = "VoidSelfClosed";
    NodeClosed[NodeClosed["ImplicitClosed"] = 4] = "ImplicitClosed";
})(exports.NodeClosed || (exports.NodeClosed = {}));
/**
 * Returns true if the node is an element node.
 *
 * @public
 */
function isElementNode(node) {
    return Boolean(node && node.nodeType === exports.NodeType.ELEMENT_NODE);
}
function isValidTagName(tagName) {
    return Boolean(tagName !== "" && tagName !== "*");
}
function createAdapter(node) {
    return {
        closest(selectors) {
            var _a;
            return (_a = node.closest(selectors)) === null || _a === void 0 ? void 0 : _a._adapter;
        },
        getAttribute(name) {
            var _a;
            return (_a = node.getAttribute(name)) === null || _a === void 0 ? void 0 : _a.value;
        },
        hasAttribute(name) {
            return node.hasAttribute(name);
        },
    };
}
/**
 * @public
 */
class HtmlElement extends DOMNode {
    constructor(tagName, parent, closed, meta, location) {
        const nodeType = tagName ? exports.NodeType.ELEMENT_NODE : exports.NodeType.DOCUMENT_NODE;
        super(nodeType, tagName, location);
        if (!isValidTagName(tagName)) {
            throw new Error(`The tag name provided ('${tagName}') is not a valid name`);
        }
        this.tagName = tagName !== null && tagName !== void 0 ? tagName : "#document";
        this.parent = parent !== null && parent !== void 0 ? parent : null;
        this.attr = {};
        this.metaElement = meta !== null && meta !== void 0 ? meta : null;
        this.closed = closed;
        this.voidElement = meta ? Boolean(meta.void) : false;
        this.depth = 0;
        this.annotation = null;
        this._adapter = createAdapter(this);
        if (parent) {
            parent.childNodes.push(this);
            /* calculate depth in domtree */
            let cur = parent;
            while (cur.parent) {
                this.depth++;
                cur = cur.parent;
            }
        }
    }
    /**
     * @internal
     */
    static rootNode(location) {
        const root = new HtmlElement(undefined, null, exports.NodeClosed.EndTag, null, location);
        root.setAnnotation("#document");
        return root;
    }
    /**
     * @internal
     *
     * @param namespace - If given it is appended to the tagName.
     */
    static fromTokens(startToken, endToken, parent, metaTable, namespace = "") {
        const name = startToken.data[2];
        const tagName = namespace ? `${namespace}:${name}` : name;
        if (!name) {
            throw new Error("tagName cannot be empty");
        }
        const meta = metaTable ? metaTable.getMetaFor(tagName) : null;
        const open = startToken.data[1] !== "/";
        const closed = isClosed(endToken, meta);
        /* location contains position of '<' so strip it out */
        const location = sliceLocation(startToken.location, 1);
        return new HtmlElement(tagName, open ? parent : null, closed, meta, location);
    }
    /**
     * Returns annotated name if set or defaults to `<tagName>`.
     *
     * E.g. `my-annotation` or `<div>`.
     */
    get annotatedName() {
        if (this.annotation) {
            return this.annotation;
        }
        else {
            return `<${this.tagName}>`;
        }
    }
    /**
     * Get list of IDs referenced by `aria-labelledby`.
     *
     * If the attribute is unset or empty this getter returns null.
     * If the attribute is dynamic the original {@link DynamicValue} is returned.
     *
     * @public
     */
    get ariaLabelledby() {
        const attr = this.getAttribute("aria-labelledby");
        if (!(attr === null || attr === void 0 ? void 0 : attr.value)) {
            return null;
        }
        if (attr.value instanceof DynamicValue) {
            return attr.value;
        }
        const list = new DOMTokenList(attr.value, attr.valueLocation);
        return list.length ? Array.from(list) : null;
    }
    /**
     * Similar to childNodes but only elements.
     */
    get childElements() {
        return this.childNodes.filter(isElementNode);
    }
    /**
     * Find the first ancestor matching a selector.
     *
     * Implementation of DOM specification of Element.closest(selectors).
     */
    closest(selectors) {
        /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive*/
        let node = this;
        while (node) {
            if (node.matches(selectors)) {
                return node;
            }
            node = node.parent;
        }
        return null;
    }
    /**
     * Generate a DOM selector for this element. The returned selector will be
     * unique inside the current document.
     */
    generateSelector() {
        /* root element cannot have a selector as it isn't a proper element */
        if (this.isRootElement()) {
            return null;
        }
        const parts = [];
        let root;
        /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive */
        for (root = this; root.parent; root = root.parent) {
            /* .. */
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive
        for (let cur = this; cur.parent; cur = cur.parent) {
            /* if a unique id is present, use it and short-circuit */
            if (cur.id) {
                const selector = generateIdSelector(cur.id);
                const matches = root.querySelectorAll(selector);
                if (matches.length === 1) {
                    parts.push(selector);
                    break;
                }
            }
            const parent = cur.parent;
            const child = parent.childElements;
            const index = child.findIndex((it) => it.unique === cur.unique);
            const numOfType = child.filter((it) => it.is(cur.tagName)).length;
            const solo = numOfType === 1;
            /* if this is the only tagName in this level of siblings nth-child isn't needed */
            if (solo) {
                parts.push(cur.tagName.toLowerCase());
                continue;
            }
            /* this will generate the worst kind of selector but at least it will be accurate (optimizations welcome) */
            parts.push(`${cur.tagName.toLowerCase()}:nth-child(${index + 1})`);
        }
        return parts.reverse().join(" > ");
    }
    /**
     * Tests if this element has given tagname.
     *
     * If passing "*" this test will pass if any tagname is set.
     */
    is(tagName) {
        return tagName === "*" || this.tagName.toLowerCase() === tagName.toLowerCase();
    }
    /**
     * Load new element metadata onto this element.
     *
     * Do note that semantics such as `void` cannot be changed (as the element has
     * already been created). In addition the element will still "be" the same
     * element, i.e. even if loading meta for a `<p>` tag upon a `<div>` tag it
     * will still be a `<div>` as far as the rest of the validator is concerned.
     *
     * In fact only certain properties will be copied onto the element:
     *
     * - content categories (flow, phrasing, etc)
     * - required attributes
     * - attribute allowed values
     * - permitted/required elements
     *
     * Properties *not* loaded:
     *
     * - inherit
     * - deprecated
     * - foreign
     * - void
     * - implicitClosed
     * - scriptSupporting
     * - deprecatedAttributes
     *
     * Changes to element metadata will only be visible after `element:ready` (and
     * the subsequent `dom:ready` event).
     */
    loadMeta(meta) {
        if (!this.metaElement) {
            this.metaElement = {};
        }
        for (const key of MetaCopyableProperty) {
            const value = meta[key];
            if (typeof value !== "undefined") {
                setMetaProperty(this.metaElement, key, value);
            }
            else {
                /* eslint-disable-next-line @typescript-eslint/no-dynamic-delete -- technical debt */
                delete this.metaElement[key];
            }
        }
    }
    /**
     * Match this element against given selectors. Returns true if any selector
     * matches.
     *
     * Implementation of DOM specification of Element.matches(selectors).
     */
    matches(selector) {
        /* find root element */
        /* eslint-disable-next-line @typescript-eslint/no-this-alias -- false positive */
        let root = this;
        while (root.parent) {
            root = root.parent;
        }
        /* a bit slow implementation as it finds all candidates for the selector and
         * then tests if any of them are the current element. A better
         * implementation would be to walk the selector right-to-left and test
         * ancestors. */
        for (const match of root.querySelectorAll(selector)) {
            if (match.unique === this.unique) {
                return true;
            }
        }
        return false;
    }
    get meta() {
        return this.metaElement;
    }
    /**
     * Set annotation for this element.
     */
    setAnnotation(text) {
        this.annotation = text;
    }
    /**
     * Set attribute. Stores all attributes set even with the same name.
     *
     * @param key - Attribute name
     * @param value - Attribute value. Use `null` if no value is present.
     * @param keyLocation - Location of the attribute name.
     * @param valueLocation - Location of the attribute value (excluding quotation)
     * @param originalAttribute - If attribute is an alias for another attribute
     * (dynamic attributes) set this to the original attribute name.
     */
    setAttribute(key, value, keyLocation, valueLocation, originalAttribute) {
        key = key.toLowerCase();
        if (!this.attr[key]) {
            this.attr[key] = [];
        }
        this.attr[key].push(new Attribute(key, value, keyLocation, valueLocation, originalAttribute));
    }
    /**
     * Get a list of all attributes on this node.
     */
    get attributes() {
        return Object.values(this.attr).reduce((result, cur) => {
            return result.concat(cur);
        }, []);
    }
    hasAttribute(key) {
        key = key.toLowerCase();
        return key in this.attr;
    }
    getAttribute(key, all = false) {
        key = key.toLowerCase();
        if (key in this.attr) {
            const matches = this.attr[key];
            return all ? matches : matches[0];
        }
        else {
            return null;
        }
    }
    /**
     * Get attribute value.
     *
     * Returns the attribute value if present.
     *
     * - Missing attributes return `null`.
     * - Boolean attributes return `null`.
     * - `DynamicValue` returns attribute expression.
     *
     * @param key - Attribute name
     * @returns Attribute value or null.
     */
    getAttributeValue(key) {
        const attr = this.getAttribute(key);
        if (attr) {
            return attr.value !== null ? attr.value.toString() : null;
        }
        else {
            return null;
        }
    }
    /**
     * Add text as a child node to this element.
     *
     * @param text - Text to add.
     * @param location - Source code location of this text.
     */
    appendText(text, location) {
        this.childNodes.push(new TextNode(text, location));
    }
    /**
     * Return a list of all known classes on the element. Dynamic values are
     * ignored.
     */
    get classList() {
        if (!this.hasAttribute("class")) {
            return new DOMTokenList(null, null);
        }
        const classes = this.getAttribute("class", true)
            .filter((attr) => attr.isStatic)
            .map((attr) => attr.value)
            .join(" ");
        return new DOMTokenList(classes, null);
    }
    /**
     * Get element ID if present.
     */
    get id() {
        return this.getAttributeValue("id");
    }
    get style() {
        const attr = this.getAttribute("style");
        return parseCssDeclaration(attr === null || attr === void 0 ? void 0 : attr.value);
    }
    /**
     * Returns the first child element or null if there are no child elements.
     */
    get firstElementChild() {
        const children = this.childElements;
        return children.length > 0 ? children[0] : null;
    }
    /**
     * Returns the last child element or null if there are no child elements.
     */
    get lastElementChild() {
        const children = this.childElements;
        return children.length > 0 ? children[children.length - 1] : null;
    }
    get siblings() {
        return this.parent ? this.parent.childElements : [this];
    }
    get previousSibling() {
        const i = this.siblings.findIndex((node) => node.unique === this.unique);
        return i >= 1 ? this.siblings[i - 1] : null;
    }
    get nextSibling() {
        const i = this.siblings.findIndex((node) => node.unique === this.unique);
        return i <= this.siblings.length - 2 ? this.siblings[i + 1] : null;
    }
    getElementsByTagName(tagName) {
        return this.childElements.reduce((matches, node) => {
            return matches.concat(node.is(tagName) ? [node] : [], node.getElementsByTagName(tagName));
        }, []);
    }
    querySelector(selector) {
        const it = this.querySelectorImpl(selector);
        const next = it.next();
        if (next.done) {
            return null;
        }
        else {
            return next.value;
        }
    }
    querySelectorAll(selector) {
        const it = this.querySelectorImpl(selector);
        const unique = new Set(it);
        return Array.from(unique.values());
    }
    *querySelectorImpl(selectorList) {
        if (!selectorList) {
            return;
        }
        for (const selector of selectorList.split(/,\s*/)) {
            const pattern = new Selector(selector);
            yield* pattern.match(this);
        }
    }
    /**
     * Visit all nodes from this node and down. Depth first.
     *
     * @internal
     */
    visitDepthFirst(callback) {
        function visit(node) {
            node.childElements.forEach(visit);
            if (!node.isRootElement()) {
                callback(node);
            }
        }
        visit(this);
    }
    /**
     * Evaluates callbackk on all descendants, returning true if any are true.
     *
     * @internal
     */
    someChildren(callback) {
        return this.childElements.some(visit);
        function visit(node) {
            if (callback(node)) {
                return true;
            }
            else {
                return node.childElements.some(visit);
            }
        }
    }
    /**
     * Evaluates callbackk on all descendants, returning true if all are true.
     *
     * @internal
     */
    everyChildren(callback) {
        return this.childElements.every(visit);
        function visit(node) {
            if (!callback(node)) {
                return false;
            }
            return node.childElements.every(visit);
        }
    }
    /**
     * Visit all nodes from this node and down. Breadth first.
     *
     * The first node for which the callback evaluates to true is returned.
     *
     * @internal
     */
    find(callback) {
        function visit(node) {
            if (callback(node)) {
                return node;
            }
            for (const child of node.childElements) {
                const match = child.find(callback);
                if (match) {
                    return match;
                }
            }
            return null;
        }
        return visit(this);
    }
}
function isClosed(endToken, meta) {
    let closed = exports.NodeClosed.Open;
    if (meta && meta.void) {
        closed = exports.NodeClosed.VoidOmitted;
    }
    if (endToken.data[0] === "/>") {
        closed = exports.NodeClosed.VoidSelfClosed;
    }
    return closed;
}

/**
 * @public
 */
class DOMTree {
    constructor(location) {
        this.root = HtmlElement.rootNode(location);
        this.active = this.root;
        this.doctype = null;
    }
    pushActive(node) {
        this.active = node;
    }
    popActive() {
        var _a;
        if (this.active.isRootElement()) {
            /* root element should never be popped, continue as if nothing happened */
            return;
        }
        this.active = (_a = this.active.parent) !== null && _a !== void 0 ? _a : this.root;
    }
    getActive() {
        return this.active;
    }
    /**
     * Resolve dynamic meta expressions.
     */
    resolveMeta(table) {
        this.visitDepthFirst((node) => {
            table.resolve(node);
        });
    }
    getElementsByTagName(tagName) {
        return this.root.getElementsByTagName(tagName);
    }
    visitDepthFirst(callback) {
        this.root.visitDepthFirst(callback);
    }
    find(callback) {
        return this.root.find(callback);
    }
    querySelector(selector) {
        return this.root.querySelector(selector);
    }
    querySelectorAll(selector) {
        return this.root.querySelectorAll(selector);
    }
}

const allowedKeys = ["exclude"];
/**
 * Helper class to validate elements against metadata rules.
 *
 * @public
 */
/* eslint-disable-next-line @typescript-eslint/no-extraneous-class -- technical debt, should probably be plain functions maybe in an object */
class Validator {
    /**
     * Test if element is used in a proper context.
     *
     * @param node - Element to test.
     * @param rules - List of rules.
     * @returns `true` if element passes all tests.
     */
    static validatePermitted(node, rules) {
        if (!rules) {
            return true;
        }
        return rules.some((rule) => {
            return Validator.validatePermittedRule(node, rule);
        });
    }
    /**
     * Test if an element is used the correct amount of times.
     *
     * For instance, a `<table>` element can only contain a single `<tbody>`
     * child. If multiple `<tbody>` exists this test will fail both nodes.
     * Note that this is called on the parent but will fail the children violating
     * the rule.
     *
     * @param children - Array of children to validate.
     * @param rules - List of rules of the parent element.
     * @returns `true` if the parent element of the children passes the test.
     */
    static validateOccurrences(children, rules, cb) {
        if (!rules) {
            return true;
        }
        let valid = true;
        for (const rule of rules) {
            /** @todo handle complex rules and not just plain arrays (but as of now
             * there is no use-case for it) */
            // istanbul ignore next
            if (typeof rule !== "string") {
                return false;
            }
            // Check if the rule has a quantifier
            const [, category, quantifier] = rule.match(/^(@?.*?)([?*]?)$/); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
            const limit = category && quantifier && parseQuantifier(quantifier);
            if (limit) {
                const siblings = children.filter((cur) => Validator.validatePermittedCategory(cur, rule, true));
                if (siblings.length > limit) {
                    // fail only the children above the limit (currently limit can only be 1)
                    for (const child of siblings.slice(limit)) {
                        cb(child, category);
                    }
                    valid = false;
                }
            }
        }
        return valid;
    }
    /**
     * Validate elements order.
     *
     * Given a parent element with children and metadata containing permitted
     * order it will validate each children and ensure each one exists in the
     * specified order.
     *
     * For instance, for a `<table>` element the `<caption>` element must come
     * before a `<thead>` which must come before `<tbody>`.
     *
     * @param children - Array of children to validate.
     */
    static validateOrder(children, rules, cb) {
        if (!rules) {
            return true;
        }
        let i = 0;
        let prev = null;
        for (const node of children) {
            const old = i;
            while (rules[i] && !Validator.validatePermittedCategory(node, rules[i], true)) {
                i++;
            }
            if (i >= rules.length) {
                /* Second check is if the order is specified for this element at all. It
                 * will be unspecified in two cases:
                 * - disallowed elements
                 * - elements where the order doesn't matter
                 * In both of these cases no error should be reported. */
                const orderSpecified = rules.find((cur) => Validator.validatePermittedCategory(node, cur, true));
                if (orderSpecified) {
                    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- technical debt, should never happen */
                    cb(node, prev);
                    return false;
                }
                /* if this element has unspecified order the index is restored so new
                 * elements of the same type can be specified again */
                i = old;
            }
            prev = node;
        }
        return true;
    }
    /**
     * Validate element ancestors.
     *
     * Check if an element has the required set of elements. At least one of the
     * selectors must match.
     */
    static validateAncestors(node, rules) {
        if (!rules || rules.length === 0) {
            return true;
        }
        return rules.some((rule) => node.closest(rule));
    }
    /**
     * Validate element required content.
     *
     * Check if an element has the required set of elements. At least one of the
     * selectors must match.
     *
     * Returns `[]` when valid or a list of required but missing tagnames or
     * categories.
     */
    static validateRequiredContent(node, rules) {
        if (!rules || rules.length === 0) {
            return [];
        }
        return rules.filter((tagName) => {
            const haveMatchingChild = node.childElements.some((child) => Validator.validatePermittedCategory(child, tagName, false));
            return !haveMatchingChild;
        });
    }
    /**
     * Test if an attribute has an allowed value and/or format.
     *
     * @param attr - Attribute to test.
     * @param rules - Element attribute metadta.
     * @returns `true` if attribute passes all tests.
     */
    static validateAttribute(attr, rules) {
        const rule = rules[attr.key];
        if (!rule) {
            return true;
        }
        /* consider dynamic values as valid as there is no way to properly test them
         * while using transformed sources, i.e. it must be tested when running in a
         * browser instead */
        const value = attr.value;
        if (value instanceof DynamicValue) {
            return true;
        }
        const empty = value === null || value === "";
        /* if boolean is set the value can be either null, empty string or the
         * attribute key (attribute-boolean-style regulates style) */
        if (rule.boolean) {
            return empty || value === attr.key;
        }
        /* if omit is set the value can be either null or empty string
         * (attribute-empty style regulates style) */
        if (rule.omit && empty) {
            return true;
        }
        /* validate each token when using list, all tokens must be valid */
        if (rule.list) {
            const tokens = new DOMTokenList(value, attr.valueLocation);
            return tokens.every((token) => {
                return this.validateAttributeValue(token, rule);
            });
        }
        return this.validateAttributeValue(value, rule);
    }
    static validateAttributeValue(value, rule) {
        /* skip attribute if it not have enumerated list */
        if (!rule.enum) {
            return true;
        }
        if (value === null || value === undefined) {
            return false;
        }
        const caseInsensitiveValue = value.toLowerCase();
        return rule.enum.some((entry) => {
            if (entry instanceof RegExp) {
                /* regular expressions are matched case-sensitive */
                return !!value.match(entry);
            }
            else {
                /* strings matched case-insensitive */
                return caseInsensitiveValue === entry;
            }
        });
    }
    static validatePermittedRule(node, rule, isExclude = false) {
        if (typeof rule === "string") {
            return Validator.validatePermittedCategory(node, rule, !isExclude);
        }
        else if (Array.isArray(rule)) {
            return rule.every((inner) => {
                return Validator.validatePermittedRule(node, inner, isExclude);
            });
        }
        else {
            validateKeys(rule);
            if (rule.exclude) {
                if (Array.isArray(rule.exclude)) {
                    return !rule.exclude.some((inner) => {
                        return Validator.validatePermittedRule(node, inner, true);
                    });
                }
                else {
                    return !Validator.validatePermittedRule(node, rule.exclude, true);
                }
            }
            else {
                return true;
            }
        }
    }
    /**
     * Validate node against a content category.
     *
     * When matching parent nodes against permitted parents use the superset
     * parameter to also match for `@flow`. E.g. if a node expects a `@phrasing`
     * parent it should also allow `@flow` parent since `@phrasing` is a subset of
     * `@flow`.
     *
     * @param node - The node to test against
     * @param category - Name of category with `@` prefix or tag name.
     * @param defaultMatch - The default return value when node categories is not known.
     */
    /* eslint-disable-next-line complexity -- rule does not like switch */
    static validatePermittedCategory(node, category, defaultMatch) {
        const [, rawCategory] = category.match(/^(@?.*?)([?*]?)$/); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- will always match
        /* match tagName when an explicit name is given */
        if (!rawCategory.startsWith("@")) {
            return node.tagName === rawCategory;
        }
        /* if the meta entry is missing assume any content model would match */
        if (!node.meta) {
            return defaultMatch;
        }
        switch (rawCategory) {
            case "@meta":
                return node.meta.metadata;
            case "@flow":
                return node.meta.flow;
            case "@sectioning":
                return node.meta.sectioning;
            case "@heading":
                return node.meta.heading;
            case "@phrasing":
                return node.meta.phrasing;
            case "@embedded":
                return node.meta.embedded;
            case "@interactive":
                return node.meta.interactive;
            case "@script":
                return Boolean(node.meta.scriptSupporting);
            case "@form":
                return Boolean(node.meta.form);
            default:
                throw new Error(`Invalid content category "${category}"`);
        }
    }
}
function validateKeys(rule) {
    for (const key of Object.keys(rule)) {
        if (!allowedKeys.includes(key)) {
            const str = JSON.stringify(rule);
            throw new Error(`Permitted rule "${str}" contains unknown property "${key}"`);
        }
    }
}
function parseQuantifier(quantifier) {
    switch (quantifier) {
        case "?":
            return 1;
        case "*":
            return null;
        // istanbul ignore next
        default:
            throw new Error(`Invalid quantifier "${quantifier}" used`);
    }
}

const $schema = "http://json-schema.org/draft-06/schema#";
const $id = "https://html-validate.org/schemas/config.json";
const type = "object";
const additionalProperties = false;
const properties = {
	$schema: {
		type: "string"
	},
	root: {
		type: "boolean",
		title: "Mark as root configuration",
		description: "If this is set to true no further configurations will be searched.",
		"default": false
	},
	"extends": {
		type: "array",
		items: {
			type: "string"
		},
		title: "Configurations to extend",
		description: "Array of shareable or builtin configurations to extend."
	},
	elements: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "object"
				}
			]
		},
		title: "Element metadata to load",
		description: "Array of modules, plugins or files to load element metadata from. Use <rootDir> to refer to the folder with the package.json file.",
		examples: [
			[
				"html-validate:recommended",
				"plugin:recommended",
				"module",
				"./local-file.json"
			]
		]
	},
	plugins: {
		type: "array",
		items: {
			anyOf: [
				{
					type: "string"
				},
				{
					type: "object"
				}
			]
		},
		title: "Plugins to load",
		description: "Array of plugins load. Use <rootDir> to refer to the folder with the package.json file.",
		examples: [
			[
				"my-plugin",
				"./local-plugin"
			]
		]
	},
	transform: {
		type: "object",
		additionalProperties: {
			type: "string"
		},
		title: "File transformations to use.",
		description: "Object where key is regular expression to match filename and value is name of transformer.",
		examples: [
			{
				"^.*\\.foo$": "my-transformer",
				"^.*\\.bar$": "my-plugin",
				"^.*\\.baz$": "my-plugin:named"
			}
		]
	},
	rules: {
		type: "object",
		patternProperties: {
			".*": {
				anyOf: [
					{
						"enum": [
							0,
							1,
							2,
							"off",
							"warn",
							"error"
						]
					},
					{
						type: "array",
						minItems: 1,
						maxItems: 1,
						items: [
							{
								"enum": [
									0,
									1,
									2,
									"off",
									"warn",
									"error"
								]
							}
						]
					},
					{
						type: "array",
						minItems: 2,
						maxItems: 2,
						items: [
							{
								"enum": [
									0,
									1,
									2,
									"off",
									"warn",
									"error"
								]
							},
							{
							}
						]
					}
				]
			}
		},
		title: "Rule configuration.",
		description: "Enable/disable rules, set severity. Some rules have additional configuration like style or patterns to use.",
		examples: [
			{
				foo: "error",
				bar: "off",
				baz: [
					"error",
					{
						style: "camelcase"
					}
				]
			}
		]
	}
};
var configurationSchema = {
	$schema: $schema,
	$id: $id,
	type: type,
	additionalProperties: additionalProperties,
	properties: properties
};

/**
 * @internal
 */
const TRANSFORMER_API = {
    VERSION: 1,
};

/**
 * @public
 */
exports.Severity = void 0;
(function (Severity) {
    Severity[Severity["DISABLED"] = 0] = "DISABLED";
    Severity[Severity["WARN"] = 1] = "WARN";
    Severity[Severity["ERROR"] = 2] = "ERROR";
})(exports.Severity || (exports.Severity = {}));
/**
 * @internal
 */
function parseSeverity(value) {
    switch (value) {
        case 0:
        case "off":
            return exports.Severity.DISABLED;
        case 1:
        case "warn":
            return exports.Severity.WARN;
        case 2:
        case "error":
            return exports.Severity.ERROR;
        default:
            throw new Error(`Invalid severity "${value}"`);
    }
}

function escape(value) {
    return JSON.stringify(value);
}
function format(value, quote = false) {
    if (value === null) {
        return "null";
    }
    if (typeof value === "number") {
        return value.toString();
    }
    if (typeof value === "string") {
        return quote ? escape(value) : value;
    }
    if (Array.isArray(value)) {
        const content = value.map((it) => format(it, true)).join(", ");
        return `[ ${content} ]`;
    }
    if (typeof value === "object") {
        const content = Object.entries(value)
            .map(([key, nested]) => `${key}: ${format(nested, true)}`)
            .join(", ");
        return `{ ${content} }`;
    }
    return String(value);
}
/**
 * Replaces placeholder `{{ ... }}` with values from given object.
 *
 * @internal
 */
function interpolate(text, data) {
    return text.replace(/{{\s*([^\s{}]+)\s*}}/g, (match, key) => {
        return typeof data[key] !== "undefined" ? format(data[key]) : match;
    });
}

const patternCache = new Map();
function compileStringPattern(pattern) {
    const regexp = pattern.replace(/[*]+/g, ".+");
    /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do input sanitation and precompilation */
    return new RegExp(`^${regexp}$`);
}
function compileRegExpPattern(pattern) {
    /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do input sanitation and precompilation */
    return new RegExp(`^${pattern}$`);
}
function compilePattern(pattern) {
    const cached = patternCache.get(pattern);
    if (cached) {
        return cached;
    }
    const match = pattern.match(/^\/(.*)\/$/);
    const regexp = match ? compileRegExpPattern(match[1]) : compileStringPattern(pattern);
    patternCache.set(pattern, regexp);
    return regexp;
}
/**
 * @internal
 */
function keywordPatternMatcher(list, keyword) {
    for (const pattern of list) {
        const regexp = compilePattern(pattern);
        if (regexp.test(keyword)) {
            return true;
        }
    }
    return false;
}
/**
 * @internal
 */
function isKeywordIgnored(options, keyword, matcher = (list, it) => list.includes(it)) {
    const { include, exclude } = options;
    /* ignore keyword if not present in "include" */
    if (include && !matcher(include, keyword)) {
        return true;
    }
    /* ignore keyword if present in "excludes" */
    if (exclude && matcher(exclude, keyword)) {
        return true;
    }
    return false;
}

const ARIA_HIDDEN_CACHE = Symbol(isAriaHidden.name);
const HTML_HIDDEN_CACHE = Symbol(isHTMLHidden.name);
const ROLE_PRESENTATION_CACHE = Symbol(isPresentation.name);
/**
 * Tests if this element is present in the accessibility tree.
 *
 * In practice it tests whenever the element or its parents has
 * `role="presentation"` or `aria-hidden="false"`. Dynamic values counts as
 * visible since the element might be in the visibility tree sometimes.
 */
function inAccessibilityTree(node) {
    return !isAriaHidden(node) && !isPresentation(node);
}
function isAriaHiddenImpl(node) {
    const isHidden = (node) => {
        const ariaHidden = node.getAttribute("aria-hidden");
        return Boolean(ariaHidden && ariaHidden.value === "true");
    };
    return {
        byParent: node.parent ? isAriaHidden(node.parent) : false,
        bySelf: isHidden(node),
    };
}
function isAriaHidden(node, details) {
    const cached = node.cacheGet(ARIA_HIDDEN_CACHE);
    if (cached) {
        return details ? cached : cached.byParent || cached.bySelf;
    }
    const result = node.cacheSet(ARIA_HIDDEN_CACHE, isAriaHiddenImpl(node));
    return details ? result : result.byParent || result.bySelf;
}
function isHTMLHiddenImpl(node) {
    const isHidden = (node) => {
        const hidden = node.getAttribute("hidden");
        return hidden !== null && hidden.isStatic;
    };
    return {
        byParent: node.parent ? isHTMLHidden(node.parent) : false,
        bySelf: isHidden(node),
    };
}
function isHTMLHidden(node, details) {
    const cached = node.cacheGet(HTML_HIDDEN_CACHE);
    if (cached) {
        return details ? cached : cached.byParent || cached.bySelf;
    }
    const result = node.cacheSet(HTML_HIDDEN_CACHE, isHTMLHiddenImpl(node));
    return details ? result : result.byParent || result.bySelf;
}
/**
 * Tests if this element or a parent element has role="presentation".
 *
 * Dynamic values yields `false` just as if the attribute wasn't present.
 */
function isPresentation(node) {
    if (node.cacheExists(ROLE_PRESENTATION_CACHE)) {
        return Boolean(node.cacheGet(ROLE_PRESENTATION_CACHE));
    }
    let cur = node;
    do {
        const role = cur.getAttribute("role");
        /* role="presentation" */
        if (role && role.value === "presentation") {
            return cur.cacheSet(ROLE_PRESENTATION_CACHE, true);
        }
        /* sanity check: break if no parent is present, normally not an issue as the
         * root element should be found first */
        if (!cur.parent) {
            break;
        }
        /* check parents */
        cur = cur.parent;
    } while (!cur.isRootElement());
    return node.cacheSet(ROLE_PRESENTATION_CACHE, false);
}

const cachePrefix = classifyNodeText.name;
const HTML_CACHE_KEY = Symbol(`${cachePrefix}|html`);
const A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y`);
const IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY = Symbol(`${cachePrefix}|html|ignore-hidden-root`);
const IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY = Symbol(`${cachePrefix}|a11y|ignore-hidden-root`);
/**
 * @public
 */
exports.TextClassification = void 0;
(function (TextClassification) {
    TextClassification[TextClassification["EMPTY_TEXT"] = 0] = "EMPTY_TEXT";
    TextClassification[TextClassification["DYNAMIC_TEXT"] = 1] = "DYNAMIC_TEXT";
    TextClassification[TextClassification["STATIC_TEXT"] = 2] = "STATIC_TEXT";
})(exports.TextClassification || (exports.TextClassification = {}));
/**
 * @internal
 */
function getCachekey(options) {
    const { accessible = false, ignoreHiddenRoot = false } = options;
    if (accessible && ignoreHiddenRoot) {
        return IGNORE_HIDDEN_ROOT_A11Y_CACHE_KEY;
    }
    else if (ignoreHiddenRoot) {
        return IGNORE_HIDDEN_ROOT_HTML_CACHE_KEY;
    }
    else if (accessible) {
        return A11Y_CACHE_KEY;
    }
    else {
        return HTML_CACHE_KEY;
    }
}
/* While I cannot find a reference about this in the standard the <select>
 * element kinda acts as if there is no text content, most particularly it
 * doesn't receive and accessible name. The `.textContent` property does
 * however include the <option> childrens text. But for the sake of the
 * validator it is probably best if the classification acts as if there is no
 * text as I think that is what is expected of the return values. Might have
 * to revisit this at some point or if someone could clarify what section of
 * the standard deals with this. */
function isSpecialEmpty(node) {
    return node.is("select") || node.is("textarea");
}
/**
 * Checks text content of an element.
 *
 * Any text is considered including text from descendant elements. Whitespace is
 * ignored.
 *
 * If any text is dynamic `TextClassification.DYNAMIC_TEXT` is returned.
 *
 * @public
 */
function classifyNodeText(node, options = {}) {
    const { accessible = false, ignoreHiddenRoot = false } = options;
    const cacheKey = getCachekey(options);
    if (node.cacheExists(cacheKey)) {
        return node.cacheGet(cacheKey); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- has/get combo
    }
    if (!ignoreHiddenRoot && isHTMLHidden(node)) {
        return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
    }
    if (!ignoreHiddenRoot && accessible && isAriaHidden(node)) {
        return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
    }
    if (isSpecialEmpty(node)) {
        return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
    }
    const text = findTextNodes(node, {
        ...options,
        ignoreHiddenRoot: false,
    });
    /* if any text is dynamic classify as dynamic */
    if (text.some((cur) => cur.isDynamic)) {
        return node.cacheSet(cacheKey, exports.TextClassification.DYNAMIC_TEXT);
    }
    /* if any text has non-whitespace character classify as static */
    if (text.some((cur) => cur.textContent.match(/\S/) !== null)) {
        return node.cacheSet(cacheKey, exports.TextClassification.STATIC_TEXT);
    }
    /* default to empty */
    return node.cacheSet(cacheKey, exports.TextClassification.EMPTY_TEXT);
}
function findTextNodes(node, options) {
    const { accessible = false } = options;
    let text = [];
    for (const child of node.childNodes) {
        if (isTextNode(child)) {
            text.push(child);
        }
        else if (isElementNode(child)) {
            if (isHTMLHidden(child, true).bySelf) {
                continue;
            }
            if (accessible && isAriaHidden(child, true).bySelf) {
                continue;
            }
            text = text.concat(findTextNodes(child, options));
        }
    }
    return text;
}

function hasAltText(image) {
    const alt = image.getAttribute("alt");
    /* missing attribute */
    if (!alt) {
        return false;
    }
    /* (incorrectly) set as boolean value */
    if (alt.value === null) {
        return false;
    }
    return alt.isDynamic || alt.value.toString() !== "";
}

function hasAriaLabel(node) {
    const label = node.getAttribute("aria-label");
    /* missing attribute */
    if (!label) {
        return false;
    }
    /* (incorrectly) set as boolean value */
    if (label.value === null) {
        return false;
    }
    return label.isDynamic || label.value.toString() !== "";
}

/**
 * Partition an array to two new lists based on the result of a
 * predicate. Similar to `Array.filter` but returns both matching and
 * non-matching in the same call.
 *
 * Elements matching the predicate is placed in the first array and elements not
 * matching is placed in the second.
 *
 * @public
 * @param values - The array of values to partition.
 * @param predicate - A predicate function taking a single element and returning
 * a boolean.
 * @returns - Two arrays where the first contains all elements where the
 * predicate matched and second contains the rest of the elements.
 */
function partition(values, predicate) {
    const initial = [[], []];
    return values.reduce((accumulator, value, index) => {
        const match = predicate(value, index, values);
        accumulator[match ? 0 : 1].push(value);
        return accumulator;
    }, initial);
}

const remapEvents = {
    "tag:open": "tag:start",
    "tag:close": "tag:end",
};
const ajv$1 = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
ajv$1.addMetaSchema(ajvSchemaDraft);
/**
 * Get (cached) schema validator for rule options.
 *
 * @param ruleId - Rule ID used as key for schema lookups.
 * @param properties - Uncompiled schema.
 */
function getSchemaValidator(ruleId, properties) {
    const $id = `rule/${ruleId}`;
    const cached = ajv$1.getSchema($id);
    if (cached) {
        return cached;
    }
    const schema = {
        $id,
        type: "object",
        additionalProperties: false,
        properties,
    };
    return ajv$1.compile(schema);
}
function isErrorDescriptor(value) {
    return Boolean(value[0] && value[0].message);
}
function unpackErrorDescriptor(value) {
    if (isErrorDescriptor(value)) {
        return value[0];
    }
    else {
        const [node, message, location, context] = value;
        return { node, message, location, context };
    }
}
/**
 * @public
 */
class Rule {
    constructor(options) {
        /* faux initialization, properly initialized by init(). This is to keep TS happy without adding null-checks everywhere */
        this.reporter = null;
        this.parser = null;
        this.meta = null;
        this.event = null;
        this.options = options;
        this.enabled = true;
        this.blockers = [];
        this.severity = exports.Severity.DISABLED;
        this.name = "";
    }
    getSeverity() {
        return this.severity;
    }
    setServerity(severity) {
        this.severity = severity;
    }
    /**
     * Block this rule from generating errors. Pass in an id generated by
     * `createBlocker`. Can be unblocked by {@link Rule.unblock}.
     *
     * A blocked rule is similar to disabling it but it will still receive parser
     * events. A list of all blockers is passed to the `rule:error` event.
     *
     * @internal
     */
    block(id) {
        this.blockers.push(id);
    }
    /**
     * Unblock a rule previously blocked by {@link Rule.block}.
     *
     * @internal
     */
    unblock(id) {
        this.blockers = this.blockers.filter((it) => it !== id);
    }
    setEnabled(enabled) {
        this.enabled = enabled;
    }
    /**
     * Returns `true` if rule is deprecated.
     *
     * Overridden by subclasses.
     */
    get deprecated() {
        return false;
    }
    /**
     * Test if rule is enabled.
     *
     * To be considered enabled the enabled flag must be true and the severity at
     * least warning.
     *
     * @internal
     */
    isEnabled(node) {
        return this.enabled && this.severity >= exports.Severity.WARN && (!node || node.ruleEnabled(this.name));
    }
    /**
     * Test if rule is enabled.
     *
     * To be considered enabled the enabled flag must be true and the severity at
     * least warning.
     *
     * @internal
     */
    isBlocked(node) {
        if (this.blockers.length > 0) {
            return true;
        }
        if (node && node.ruleBlockers(this.name).length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Get a list of all blockers currently active this rule.
     *
     * @internal
     */
    getBlockers(node) {
        return [...this.blockers, ...(node ? node.ruleBlockers(this.name) : [])];
    }
    /**
     * Check if keyword is being ignored by the current rule configuration.
     *
     * This method requires the [[RuleOption]] type to include two properties:
     *
     * - include: string[] | null
     * - exclude: string[] | null
     *
     * This methods checks if the given keyword is included by "include" but not
     * excluded by "exclude". If any property is unset it is skipped by the
     * condition. Usually the user would use either one but not both but there is
     * no limitation to use both but the keyword must satisfy both conditions. If
     * either condition fails `true` is returned.
     *
     * For instance, given `{ include: ["foo"] }` the keyword `"foo"` would match
     * but not `"bar"`.
     *
     * Similarly, given `{ exclude: ["foo"] }` the keyword `"bar"` would match but
     * not `"foo"`.
     *
     * @param keyword - Keyword to match against `include` and `exclude` options.
     * @param matcher - Optional function to compare items with.
     * @returns `true` if keyword is not present in `include` or is present in
     * `exclude`.
     */
    isKeywordIgnored(keyword, matcher = (list, it) => list.includes(it)) {
        return isKeywordIgnored(this.options, keyword, matcher);
    }
    /**
     * Get [[MetaElement]] for the given tag. If no specific metadata is present
     * the global metadata is returned or null if no global is present.
     *
     * @public
     * @returns A shallow copy of metadata.
     */
    getMetaFor(tagName) {
        return this.meta.getMetaFor(tagName);
    }
    /**
     * Find all tags which has enabled given property.
     */
    getTagsWithProperty(propName) {
        return this.meta.getTagsWithProperty(propName);
    }
    /**
     * Find tag matching tagName or inheriting from it.
     */
    getTagsDerivedFrom(tagName) {
        return this.meta.getTagsDerivedFrom(tagName);
    }
    /**
     * JSON schema for rule options.
     *
     * Rules should override this to return an object with JSON schema to validate
     * rule options. If `null` or `undefined` is returned no validation is
     * performed.
     */
    static schema() {
        return null;
    }
    report(...args) {
        const { node, message, location, context } = unpackErrorDescriptor(args);
        const enabled = this.isEnabled(node);
        const blocked = this.isBlocked(node);
        const where = this.findLocation({ node, location, event: this.event });
        this.parser.trigger("rule:error", {
            location: where,
            ruleId: this.name,
            enabled,
            blockers: this.getBlockers(node),
        });
        if (enabled && !blocked) {
            const interpolated = interpolate(message, context !== null && context !== void 0 ? context : {});
            this.reporter.add(this, interpolated, this.severity, node, where, context);
        }
    }
    findLocation(src) {
        var _a, _b;
        if (src.location) {
            return src.location;
        }
        if ((_a = src.event) === null || _a === void 0 ? void 0 : _a.location) {
            return src.event.location;
        }
        if ((_b = src.node) === null || _b === void 0 ? void 0 : _b.location) {
            return src.node.location;
        }
        return {};
    }
    on(event, ...args) {
        var _a;
        /* handle deprecated aliases */
        const remap = remapEvents[event];
        if (remap) {
            event = remap;
        }
        const callback = args.pop();
        const filter = (_a = args.pop()) !== null && _a !== void 0 ? _a : (() => true);
        return this.parser.on(event, (_event, data) => {
            if (this.isEnabled() && filter(data)) {
                this.event = data;
                callback(data);
            }
        });
    }
    /**
     * Called by [[Engine]] when initializing the rule.
     *
     * Do not override this, use the `setup` callback instead.
     *
     * @internal
     */
    init(parser, reporter, severity, meta) {
        this.parser = parser;
        this.reporter = reporter;
        this.severity = severity;
        this.meta = meta;
    }
    /**
     * Validate rule options against schema. Throws error if object does not validate.
     *
     * For rules without schema this function does nothing.
     *
     * @throws {@link SchemaValidationError}
     * Thrown when provided options does not validate against rule schema.
     *
     * @param cls - Rule class (constructor)
     * @param ruleId - Rule identifier
     * @param jsonPath - JSON path from which [[options]] can be found in [[config]]
     * @param options - User configured options to be validated
     * @param filename - Filename from which options originated
     * @param config - Configuration from which options originated
     *
     * @internal
     */
    static validateOptions(cls, ruleId, jsonPath, options, filename, config) {
        var _a;
        if (!cls) {
            return;
        }
        const schema = cls.schema();
        if (!schema) {
            return;
        }
        const isValid = getSchemaValidator(ruleId, schema);
        if (!isValid(options)) {
            /* istanbul ignore next: it is always set when validation fails */
            const errors = (_a = isValid.errors) !== null && _a !== void 0 ? _a : [];
            const mapped = errors.map((error) => {
                error.instancePath = `${jsonPath}${error.instancePath}`;
                return error;
            });
            throw new SchemaValidationError(filename, `Rule configuration error`, config, schema, mapped);
        }
    }
    /**
     * Rule documentation callback.
     *
     * Called when requesting additional documentation for a rule. Some rules
     * provide additional context to provide context-aware suggestions.
     *
     * @public
     * @virtual
     * @param context - Error context given by a reported error.
     * @returns Rule documentation and url with additional details or `null` if no
     * additional documentation is available.
     */
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- technical debt, prototype should be moved to interface */
    documentation(context) {
        return null;
    }
}

var Style$1;
(function (Style) {
    Style["EXTERNAL"] = "external";
    Style["RELATIVE_BASE"] = "relative-base";
    Style["RELATIVE_PATH"] = "relative-path";
    Style["ABSOLUTE"] = "absolute";
    Style["ANCHOR"] = "anchor";
})(Style$1 || (Style$1 = {}));
const defaults$u = {
    allowExternal: true,
    allowRelative: true,
    allowAbsolute: true,
    allowBase: true,
};
const mapping = {
    a: "href",
    img: "src",
    link: "href",
    script: "src",
};
const description = {
    [Style$1.EXTERNAL]: "External links are not allowed by current configuration.",
    [Style$1.RELATIVE_BASE]: "Links relative to <base> are not allowed by current configuration.",
    [Style$1.RELATIVE_PATH]: "Relative links are not allowed by current configuration.",
    [Style$1.ABSOLUTE]: "Absolute links are not allowed by current configuration.",
    [Style$1.ANCHOR]: null,
};
function parseAllow(value) {
    if (typeof value === "boolean") {
        return value;
    }
    return {
        /* eslint-disable security/detect-non-literal-regexp -- expected to be regexp  */
        include: value.include ? value.include.map((it) => new RegExp(it)) : null,
        exclude: value.exclude ? value.exclude.map((it) => new RegExp(it)) : null,
        /* eslint-enable security/detect-non-literal-regexp */
    };
}
/**
 * @internal
 */
function matchList(value, list) {
    if (list.include && !list.include.some((it) => it.test(value))) {
        return false;
    }
    if (list.exclude && list.exclude.some((it) => it.test(value))) {
        return false;
    }
    return true;
}
class AllowedLinks extends Rule {
    constructor(options) {
        super({ ...defaults$u, ...options });
        this.allowExternal = parseAllow(this.options.allowExternal);
        this.allowRelative = parseAllow(this.options.allowRelative);
        this.allowAbsolute = parseAllow(this.options.allowAbsolute);
    }
    static schema() {
        const booleanOrObject = {
            anyOf: [
                { type: "boolean" },
                {
                    type: "object",
                    properties: {
                        include: {
                            type: "array",
                            items: { type: "string" },
                        },
                        exclude: {
                            type: "array",
                            items: { type: "string" },
                        },
                    },
                },
            ],
        };
        return {
            allowExternal: { ...booleanOrObject },
            allowRelative: { ...booleanOrObject },
            allowAbsolute: { ...booleanOrObject },
            allowBase: { type: "boolean" },
        };
    }
    documentation(context) {
        var _a;
        const message = (_a = description[context]) !== null && _a !== void 0 ? _a : "This link type is not allowed by current configuration";
        return {
            description: message,
            url: "https://html-validate.org/rules/allowed-links.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (!event.value || !this.isRelevant(event)) {
                return;
            }
            const link = event.value.toString();
            const style = this.getStyle(link);
            switch (style) {
                case Style$1.ANCHOR:
                    /* anchor links are always allowed by this rule */
                    break;
                case Style$1.ABSOLUTE:
                    this.handleAbsolute(link, event, style);
                    break;
                case Style$1.EXTERNAL:
                    this.handleExternal(link, event, style);
                    break;
                case Style$1.RELATIVE_BASE:
                    this.handleRelativeBase(link, event, style);
                    break;
                case Style$1.RELATIVE_PATH:
                    this.handleRelativePath(link, event, style);
                    break;
            }
        });
    }
    isRelevant(event) {
        const { target, key, value } = event;
        /* don't check links with dynamic values */
        if (value instanceof DynamicValue) {
            return false;
        }
        const attr = mapping[target.tagName];
        return Boolean(attr && attr === key);
    }
    getStyle(value) {
        /* http://example.net or //example.net */
        if (value.match(/^([a-z]+:)?\/\//g)) {
            return Style$1.EXTERNAL;
        }
        switch (value[0]) {
            /* /foo/bar */
            case "/":
                return Style$1.ABSOLUTE;
            /* ../foo/bar */
            case ".":
                return Style$1.RELATIVE_PATH;
            /* #foo */
            case "#":
                return Style$1.ANCHOR;
            /* foo/bar */
            default:
                return Style$1.RELATIVE_BASE;
        }
    }
    handleAbsolute(target, event, style) {
        const { allowAbsolute } = this;
        if (allowAbsolute === true) {
            return;
        }
        else if (allowAbsolute === false) {
            this.report(event.target, "Link destination must not be absolute url", event.valueLocation, style);
        }
        else if (!matchList(target, allowAbsolute)) {
            this.report(event.target, "Absolute link to this destination is not allowed by current configuration", event.valueLocation, style);
        }
    }
    handleExternal(target, event, style) {
        const { allowExternal } = this;
        if (allowExternal === true) {
            return;
        }
        else if (allowExternal === false) {
            this.report(event.target, "Link destination must not be external url", event.valueLocation, style);
        }
        else if (!matchList(target, allowExternal)) {
            this.report(event.target, "External link to this destination is not allowed by current configuration", event.valueLocation, style);
        }
    }
    handleRelativePath(target, event, style) {
        const { allowRelative } = this;
        if (allowRelative === true) {
            return false;
        }
        else if (allowRelative === false) {
            this.report(event.target, "Link destination must not be relative url", event.valueLocation, style);
            return true;
        }
        else if (!matchList(target, allowRelative)) {
            this.report(event.target, "Relative link to this destination is not allowed by current configuration", event.valueLocation, style);
            return true;
        }
        return false;
    }
    handleRelativeBase(target, event, style) {
        const { allowBase } = this.options;
        if (this.handleRelativePath(target, event, style)) {
            return;
        }
        else if (!allowBase) {
            this.report(event.target, "Relative links must be relative to current folder", event.valueLocation, style);
        }
    }
}

var RuleContext$1;
(function (RuleContext) {
    RuleContext["MISSING_ALT"] = "missing-alt";
    RuleContext["MISSING_HREF"] = "missing-href";
})(RuleContext$1 || (RuleContext$1 = {}));
const defaults$t = {
    accessible: true,
};
function findByTarget(target, siblings) {
    return siblings.filter((it) => it.getAttributeValue("href") === target);
}
function getAltText(node) {
    return node.getAttributeValue("alt");
}
function getDescription$1(context) {
    switch (context) {
        case RuleContext$1.MISSING_ALT:
            return [
                "The `alt` attribute must be set (and not empty) when the `href` attribute is present on an `<area>` element.",
                "",
                "The attribute is used to provide an alternative text description for the area of the image map.",
                "The text should describe the purpose of area and the resource referenced by the `href` attribute.",
                "",
                "Either add the `alt` attribute or remove the `href` attribute.",
            ];
        case RuleContext$1.MISSING_HREF:
            return [
                "The `alt` attribute must not be set when the `href` attribute is missing on an `<area>` element.",
                "",
                "Either add the `href` attribute or remove the `alt` attribute.",
            ];
    }
}
class AreaAlt extends Rule {
    constructor(options) {
        super({ ...defaults$t, ...options });
    }
    static schema() {
        return {
            accessible: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        return {
            description: getDescription$1(context).join("\n"),
            url: "https://html-validate.org/rules/area-alt.html",
        };
    }
    setup() {
        this.on("element:ready", this.isRelevant, (event) => {
            const { target } = event;
            const siblings = target.querySelectorAll("area");
            for (const child of siblings) {
                this.validateArea(child, siblings);
            }
        });
    }
    validateArea(area, siblings) {
        const { accessible } = this.options;
        const href = area.getAttribute("href");
        const alt = area.getAttribute("alt");
        if (href) {
            if (alt && alt.isDynamic) {
                return;
            }
            const target = area.getAttributeValue("href");
            const altTexts = accessible
                ? [getAltText(area)]
                : findByTarget(target, siblings).map(getAltText);
            if (!altTexts.some(Boolean)) {
                this.report({
                    node: area,
                    message: `"alt" attribute must be set and non-empty when the "href" attribute is present`,
                    location: alt ? alt.keyLocation : href.keyLocation,
                    context: RuleContext$1.MISSING_ALT,
                });
            }
        }
        else if (alt) {
            this.report({
                node: area,
                message: `"alt" attribute cannot be used unless the "href" attribute is present`,
                location: alt.keyLocation,
                context: RuleContext$1.MISSING_HREF,
            });
        }
    }
    isRelevant(event) {
        const { target } = event;
        return target.is("map");
    }
}

class AriaHiddenBody extends Rule {
    documentation() {
        return {
            description: "`aria-hidden` must not be used on the `<body>` element as it makes the page inaccessible to assistive technology such as screenreaders",
            url: "https://html-validate.org/rules/aria-hidden-body.html",
        };
    }
    setup() {
        this.on("tag:ready", this.isRelevant, (event) => {
            const { target } = event;
            const attr = target.getAttribute("aria-hidden");
            if (!attr || !attr.valueMatches("true", true)) {
                return;
            }
            this.report(target, "aria-hidden must not be used on <body>", attr.keyLocation);
        });
    }
    isRelevant(event) {
        return event.target.is("body");
    }
}

const whitelisted = [
    "main",
    "nav",
    "table",
    "td",
    "th",
    "aside",
    "header",
    "footer",
    "section",
    "article",
    "form",
    "img",
    "area",
    "fieldset",
    "summary",
    "figure",
];
function isValidUsage(target, meta) {
    /* elements with explicit aria-label attribute are valid */
    const explicit = meta.attributes["aria-label"];
    if (explicit) {
        return true;
    }
    /* landmark and other whitelisted elements are valid */
    if (whitelisted.includes(target.tagName)) {
        return true;
    }
    /* elements with role are valid, @todo check if the role is widget or landmark */
    if (target.hasAttribute("role")) {
        return true;
    }
    /* elements with tabindex (implicit interactive) are valid */
    if (target.hasAttribute("tabindex")) {
        return true;
    }
    /* interactive and labelable elements are valid */
    if (Boolean(meta.interactive) || Boolean(meta.labelable)) {
        return true;
    }
    return false;
}
class AriaLabelMisuse extends Rule {
    documentation() {
        const valid = [
            "Interactive elements",
            "Labelable elements",
            "Landmark elements",
            "Elements with roles inheriting from widget",
            "`<area>`",
            "`<form>` and `<fieldset>`",
            "`<iframe>`",
            "`<img>` and `<figure>`",
            "`<summary>`",
            "`<table>`, `<td>` and `<th>`",
        ];
        const lines = valid.map((it) => `- ${it}\n`).join("");
        return {
            description: `\`aria-label\` can only be used on:\n\n${lines}`,
            url: "https://html-validate.org/rules/aria-label-misuse.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            for (const target of document.querySelectorAll("[aria-label]")) {
                this.validateElement(target);
            }
        });
    }
    validateElement(target) {
        /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- the
         * earier [aria-label] selector ensures this is always present */
        const attr = target.getAttribute("aria-label");
        if (!attr.value || attr.valueMatches("", false)) {
            return;
        }
        /* ignore elements without meta */
        const meta = target.meta;
        if (!meta) {
            return;
        }
        /* ignore elements which is valid usage */
        if (isValidUsage(target, meta)) {
            return;
        }
        this.report(target, `"aria-label" cannot be used on this element`, attr.keyLocation);
    }
}

/**
 * @public
 */
class ConfigError extends UserError {
    constructor(message, nested) {
        super(message, nested);
        Error.captureStackTrace(this, ConfigError);
        this.name = ConfigError.name;
    }
}

/**
 * Represents casing for a name, e.g. lowercase, uppercase, etc.
 */
class CaseStyle {
    /**
     * @param style - Name of a valid case style.
     */
    constructor(style, ruleId) {
        if (!Array.isArray(style)) {
            style = [style];
        }
        if (style.length === 0) {
            throw new ConfigError(`Missing style for ${ruleId} rule`);
        }
        this.styles = this.parseStyle(style, ruleId);
    }
    /**
     * Test if a text matches this case style.
     */
    match(text) {
        return this.styles.some((style) => text.match(style.pattern));
    }
    get name() {
        const names = this.styles.map((style) => style.name);
        switch (this.styles.length) {
            case 1:
                return names[0];
            case 2:
                return names.join(" or ");
            default: {
                const last = names.slice(-1);
                const rest = names.slice(0, -1);
                return `${rest.join(", ")} or ${last[0]}`;
            }
        }
    }
    parseStyle(style, ruleId) {
        return style.map((cur) => {
            switch (cur.toLowerCase()) {
                case "lowercase":
                    return { pattern: /^[a-z]*$/, name: "lowercase" };
                case "uppercase":
                    return { pattern: /^[A-Z]*$/, name: "uppercase" };
                case "pascalcase":
                    return { pattern: /^[A-Z][A-Za-z]*$/, name: "PascalCase" };
                case "camelcase":
                    return { pattern: /^[a-z][A-Za-z]*$/, name: "camelCase" };
                default:
                    throw new ConfigError(`Invalid style "${cur}" for ${ruleId} rule`);
            }
        });
    }
}

const defaults$s = {
    style: "lowercase",
    ignoreForeign: true,
};
class AttrCase extends Rule {
    constructor(options) {
        super({ ...defaults$s, ...options });
        this.style = new CaseStyle(this.options.style, "attr-case");
    }
    static schema() {
        const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
        return {
            ignoreForeign: {
                type: "boolean",
            },
            style: {
                anyOf: [
                    {
                        enum: styleEnum,
                        type: "string",
                    },
                    {
                        items: {
                            enum: styleEnum,
                            type: "string",
                        },
                        type: "array",
                    },
                ],
            },
        };
    }
    documentation() {
        const { style } = this.options;
        return {
            description: Array.isArray(style)
                ? [`Attribute name must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n")
                : `Attribute name must be in ${style}.`,
            url: "https://html-validate.org/rules/attr-case.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (this.isIgnored(event.target)) {
                return;
            }
            /* ignore case for dynamic attributes, the original attributes will be
             * checked instead (this prevents duplicated errors for the same source
             * attribute) */
            if (event.originalAttribute) {
                return;
            }
            const letters = event.key.replace(/[^a-z]+/gi, "");
            if (this.style.match(letters)) {
                return;
            }
            this.report({
                node: event.target,
                message: `Attribute "${event.key}" should be ${this.style.name}`,
                location: event.keyLocation,
            });
        });
    }
    isIgnored(node) {
        if (this.options.ignoreForeign) {
            return Boolean(node.meta && node.meta.foreign);
        }
        else {
            return false;
        }
    }
}

/**
 * @internal
 */
var TokenType;
(function (TokenType) {
    TokenType[TokenType["UNICODE_BOM"] = 1] = "UNICODE_BOM";
    TokenType[TokenType["WHITESPACE"] = 2] = "WHITESPACE";
    TokenType[TokenType["DOCTYPE_OPEN"] = 3] = "DOCTYPE_OPEN";
    TokenType[TokenType["DOCTYPE_VALUE"] = 4] = "DOCTYPE_VALUE";
    TokenType[TokenType["DOCTYPE_CLOSE"] = 5] = "DOCTYPE_CLOSE";
    TokenType[TokenType["TAG_OPEN"] = 6] = "TAG_OPEN";
    TokenType[TokenType["TAG_CLOSE"] = 7] = "TAG_CLOSE";
    TokenType[TokenType["ATTR_NAME"] = 8] = "ATTR_NAME";
    TokenType[TokenType["ATTR_VALUE"] = 9] = "ATTR_VALUE";
    TokenType[TokenType["TEXT"] = 10] = "TEXT";
    TokenType[TokenType["TEMPLATING"] = 11] = "TEMPLATING";
    TokenType[TokenType["SCRIPT"] = 12] = "SCRIPT";
    TokenType[TokenType["STYLE"] = 13] = "STYLE";
    TokenType[TokenType["COMMENT"] = 14] = "COMMENT";
    TokenType[TokenType["CONDITIONAL"] = 15] = "CONDITIONAL";
    TokenType[TokenType["DIRECTIVE"] = 16] = "DIRECTIVE";
    TokenType[TokenType["EOF"] = 17] = "EOF";
})(TokenType || (TokenType = {}));

/* eslint-disable no-useless-escape -- false positives */
const MATCH_UNICODE_BOM = /^\uFEFF/;
const MATCH_WHITESPACE = /^(?:\r\n|\r|\n|[ \t]+(?:\r\n|\r|\n)?)/;
const MATCH_DOCTYPE_OPEN = /^<!(DOCTYPE)\s/i;
const MATCH_DOCTYPE_VALUE = /^[^>]+/;
const MATCH_DOCTYPE_CLOSE = /^>/;
const MATCH_XML_TAG = /^<\?xml.*?\?>\s+/;
const MATCH_TAG_OPEN = /^<(\/?)([a-zA-Z0-9\-:]+)/; // https://www.w3.org/TR/html/syntax.html#start-tags
const MATCH_TAG_CLOSE = /^\/?>/;
const MATCH_TEXT = /^[^]*?(?=(?:[ \t]*(?:\r\n|\r|\n)|<[^ ]|$))/;
const MATCH_TEMPLATING = /^(?:<%.*?%>|<\?.*?\?>|<\$.*?\$>)/s;
const MATCH_TAG_LOOKAHEAD = /^[^]*?(?=<|$)/;
const MATCH_ATTR_START = /^([^\t\r\n\f \/><"'=]+)/; // https://www.w3.org/TR/html/syntax.html#elements-attributes
const MATCH_ATTR_SINGLE = /^(\s*=\s*)'([^']*?)(')/;
const MATCH_ATTR_DOUBLE = /^(\s*=\s*)"([^"]*?)(")/;
const MATCH_ATTR_UNQUOTED = /^(\s*=\s*)([^\t\r\n\f "'<>][^\t\r\n\f <>]*)/;
const MATCH_CDATA_BEGIN = /^<!\[CDATA\[/;
const MATCH_CDATA_END = /^[^]*?]]>/;
const MATCH_SCRIPT_DATA = /^[^]*?(?=<\/script)/;
const MATCH_SCRIPT_END = /^<(\/)(script)/;
const MATCH_STYLE_DATA = /^[^]*?(?=<\/style)/;
const MATCH_STYLE_END = /^<(\/)(style)/;
const MATCH_DIRECTIVE = /^(<!--\s*\[html-validate-)([a-z0-9-]+)(\s*)(.*?)(]?\s*-->)/;
const MATCH_COMMENT = /^<!--([^]*?)-->/;
const MATCH_CONDITIONAL = /^<!\[([^\]]*?)\]>/;
/* eslint-enable no-useless-escape */
class InvalidTokenError extends Error {
    constructor(location, message) {
        super(message);
        this.location = location;
    }
}
class Lexer {
    /* eslint-disable-next-line complexity -- there isn't really a good way to refactor this while keeping readability */
    *tokenize(source) {
        const context = new Context(source);
        /* for sanity check */
        let previousState = context.state;
        let previousLength = context.string.length;
        while (context.string.length > 0) {
            switch (context.state) {
                case State.INITIAL:
                    yield* this.tokenizeInitial(context);
                    break;
                case State.DOCTYPE:
                    yield* this.tokenizeDoctype(context);
                    break;
                case State.TAG:
                    yield* this.tokenizeTag(context);
                    break;
                case State.ATTR:
                    yield* this.tokenizeAttr(context);
                    break;
                case State.TEXT:
                    yield* this.tokenizeText(context);
                    break;
                case State.CDATA:
                    yield* this.tokenizeCDATA(context);
                    break;
                case State.SCRIPT:
                    yield* this.tokenizeScript(context);
                    break;
                case State.STYLE:
                    yield* this.tokenizeStyle(context);
                    break;
                /* istanbul ignore next: sanity check: should not happen unless adding new states */
                default:
                    this.unhandled(context);
            }
            /* sanity check: state or string must change, if both are intact
             * we are stuck in an endless loop. */
            /* istanbul ignore next: no easy way to test this as it is a condition which should never happen */
            if (context.state === previousState && context.string.length === previousLength) {
                this.errorStuck(context);
            }
            previousState = context.state;
            previousLength = context.string.length;
        }
        yield this.token(context, TokenType.EOF, []);
    }
    token(context, type, data) {
        const size = data.length > 0 ? data[0].length : 0;
        const location = context.getLocation(size);
        return {
            type,
            location,
            data: Array.from(data),
        };
    }
    /* istanbul ignore next: used to provide a better error when an unhandled state happens */
    unhandled(context) {
        const truncated = JSON.stringify(context.string.length > 13 ? `${context.string.slice(0, 15)}...` : context.string);
        const state = State[context.state];
        const message = `failed to tokenize ${truncated}, unhandled state ${state}.`;
        throw new InvalidTokenError(context.getLocation(1), message);
    }
    /* istanbul ignore next: used to provide a better error when lexer is detected to be stuck, no known way to reproduce */
    errorStuck(context) {
        const state = State[context.state];
        const message = `failed to tokenize ${context.getTruncatedLine()}, state ${state} failed to consume data or change state.`;
        throw new InvalidTokenError(context.getLocation(1), message);
    }
    evalNextState(nextState, token) {
        if (typeof nextState === "function") {
            return nextState(token);
        }
        else {
            return nextState;
        }
    }
    *match(context, tests, error) {
        const n = tests.length;
        for (let i = 0; i < n; i++) {
            const [regex, nextState, tokenType] = tests[i];
            const match = regex ? context.string.match(regex) : [""];
            if (match) {
                let token = null;
                if (tokenType !== false) {
                    token = this.token(context, tokenType, match);
                    yield token;
                }
                const state = this.evalNextState(nextState, token);
                context.consume(match, state);
                this.enter(context, state, match);
                return;
            }
        }
        const message = `failed to tokenize ${context.getTruncatedLine()}, ${error}.`;
        throw new InvalidTokenError(context.getLocation(1), message);
    }
    /**
     * Called when entering a new state.
     */
    enter(context, state, data) {
        /* script/style tags require a different content model */
        if (state === State.TAG && data && data[0].startsWith("<")) {
            if (data[0] === "<script") {
                context.contentModel = ContentModel.SCRIPT;
            }
            else if (data[0] === "<style") {
                context.contentModel = ContentModel.STYLE;
            }
            else {
                context.contentModel = ContentModel.TEXT;
            }
        }
    }
    *tokenizeInitial(context) {
        yield* this.match(context, [
            [MATCH_UNICODE_BOM, State.INITIAL, TokenType.UNICODE_BOM],
            [MATCH_XML_TAG, State.INITIAL, false],
            [MATCH_DOCTYPE_OPEN, State.DOCTYPE, TokenType.DOCTYPE_OPEN],
            [MATCH_WHITESPACE, State.INITIAL, TokenType.WHITESPACE],
            [MATCH_DIRECTIVE, State.INITIAL, TokenType.DIRECTIVE],
            [MATCH_CONDITIONAL, State.INITIAL, TokenType.CONDITIONAL],
            [MATCH_COMMENT, State.INITIAL, TokenType.COMMENT],
            [false, State.TEXT, false],
        ], "expected doctype");
    }
    *tokenizeDoctype(context) {
        yield* this.match(context, [
            [MATCH_WHITESPACE, State.DOCTYPE, TokenType.WHITESPACE],
            [MATCH_DOCTYPE_VALUE, State.DOCTYPE, TokenType.DOCTYPE_VALUE],
            [MATCH_DOCTYPE_CLOSE, State.TEXT, TokenType.DOCTYPE_CLOSE],
        ], "expected doctype name");
    }
    *tokenizeTag(context) {
        function nextState(token) {
            const tagCloseToken = token;
            switch (context.contentModel) {
                case ContentModel.TEXT:
                    return State.TEXT;
                case ContentModel.SCRIPT:
                    if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
                        return State.SCRIPT;
                    }
                    else {
                        return State.TEXT; /* <script/> (not legal but handle it anyway so the lexer doesn't choke on it) */
                    }
                case ContentModel.STYLE:
                    if (tagCloseToken && !tagCloseToken.data[0].startsWith("/")) {
                        return State.STYLE;
                    }
                    else {
                        return State.TEXT; /* <style/> */
                    }
            }
        }
        yield* this.match(context, [
            [MATCH_TAG_CLOSE, nextState, TokenType.TAG_CLOSE],
            [MATCH_ATTR_START, State.ATTR, TokenType.ATTR_NAME],
            [MATCH_WHITESPACE, State.TAG, TokenType.WHITESPACE],
        ], 'expected attribute, ">" or "/>"');
    }
    *tokenizeAttr(context) {
        yield* this.match(context, [
            [MATCH_ATTR_SINGLE, State.TAG, TokenType.ATTR_VALUE],
            [MATCH_ATTR_DOUBLE, State.TAG, TokenType.ATTR_VALUE],
            [MATCH_ATTR_UNQUOTED, State.TAG, TokenType.ATTR_VALUE],
            [false, State.TAG, false],
        ], 'expected attribute, ">" or "/>"');
    }
    *tokenizeText(context) {
        yield* this.match(context, [
            [MATCH_WHITESPACE, State.TEXT, TokenType.WHITESPACE],
            [MATCH_CDATA_BEGIN, State.CDATA, false],
            [MATCH_DIRECTIVE, State.TEXT, TokenType.DIRECTIVE],
            [MATCH_CONDITIONAL, State.TEXT, TokenType.CONDITIONAL],
            [MATCH_COMMENT, State.TEXT, TokenType.COMMENT],
            [MATCH_TEMPLATING, State.TEXT, TokenType.TEMPLATING],
            [MATCH_TAG_OPEN, State.TAG, TokenType.TAG_OPEN],
            [MATCH_TEXT, State.TEXT, TokenType.TEXT],
            [MATCH_TAG_LOOKAHEAD, State.TEXT, TokenType.TEXT],
        ], 'expected text or "<"');
    }
    *tokenizeCDATA(context) {
        yield* this.match(context, [[MATCH_CDATA_END, State.TEXT, false]], "expected ]]>");
    }
    *tokenizeScript(context) {
        yield* this.match(context, [
            [MATCH_SCRIPT_END, State.TAG, TokenType.TAG_OPEN],
            [MATCH_SCRIPT_DATA, State.SCRIPT, TokenType.SCRIPT],
        ], "expected </script>");
    }
    *tokenizeStyle(context) {
        yield* this.match(context, [
            [MATCH_STYLE_END, State.TAG, TokenType.TAG_OPEN],
            [MATCH_STYLE_DATA, State.STYLE, TokenType.STYLE],
        ], "expected </style>");
    }
}

const whitespace = /(\s+)/;
class AttrDelimiter extends Rule {
    documentation() {
        return {
            description: `Attribute value must not be separated by whitespace.`,
            url: "https://html-validate.org/rules/attr-delimiter.html",
        };
    }
    setup() {
        this.on("token", (event) => {
            const { token } = event;
            if (token.type !== TokenType.ATTR_VALUE) {
                return;
            }
            const delimiter = token.data[1];
            const match = whitespace.exec(delimiter);
            if (match) {
                const location = sliceLocation(event.location, 0, delimiter.length);
                this.report(null, "Attribute value must not be delimited by whitespace", location);
            }
        });
    }
}

const DEFAULT_PATTERN = "[a-z0-9-:]+";
const defaults$r = {
    pattern: DEFAULT_PATTERN,
    ignoreForeign: true,
};
function generateRegexp(pattern) {
    if (Array.isArray(pattern)) {
        /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp */
        return new RegExp(`^(${pattern.join("|")})$`, "i");
    }
    else {
        /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp  */
        return new RegExp(`^${pattern}$`, "i");
    }
}
function generateMessage(name, pattern) {
    if (Array.isArray(pattern)) {
        const patterns = pattern.map((it) => `/${it}/`).join(", ");
        return `Attribute "${name}" should match one of [${patterns}]`;
    }
    else {
        return `Attribute "${name}" should match /${pattern}/`;
    }
}
function generateDescription(name, pattern) {
    if (Array.isArray(pattern)) {
        return [
            `Attribute "${name}" should match one of the configured regular expressions:`,
            "",
            ...pattern.map((it) => `- \`/${it}/\``),
        ].join("\n");
    }
    else {
        return `Attribute "${name}" should match the regular expression \`/${pattern}/\``;
    }
}
class AttrPattern extends Rule {
    constructor(options) {
        super({ ...defaults$r, ...options });
        this.pattern = generateRegexp(this.options.pattern);
    }
    static schema() {
        return {
            pattern: {
                oneOf: [{ type: "array", items: { type: "string" }, minItems: 1 }, { type: "string" }],
            },
            ignoreForeign: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        return {
            description: generateDescription(context.attr, context.pattern),
            url: "https://html-validate.org/rules/attr-pattern.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (this.isIgnored(event.target)) {
                return;
            }
            /* ignore case for dynamic attributes, the original attributes will be
             * checked instead (this prevents duplicated errors for the same source
             * attribute) */
            if (event.originalAttribute) {
                return;
            }
            if (this.pattern.test(event.key)) {
                return;
            }
            const message = generateMessage(event.key, this.options.pattern);
            const context = {
                attr: event.key,
                pattern: this.options.pattern,
            };
            this.report(event.target, message, event.keyLocation, context);
        });
    }
    isIgnored(node) {
        if (this.options.ignoreForeign) {
            return Boolean(node.meta && node.meta.foreign);
        }
        else {
            return false;
        }
    }
}

var QuoteStyle;
(function (QuoteStyle) {
    QuoteStyle["SINGLE_QUOTE"] = "'";
    QuoteStyle["DOUBLE_QUOTE"] = "\"";
    QuoteStyle["AUTO_QUOTE"] = "auto";
    QuoteStyle["ANY_QUOTE"] = "any";
})(QuoteStyle || (QuoteStyle = {}));
const defaults$q = {
    style: "auto",
    unquoted: false,
};
function describeError(context) {
    switch (context.error) {
        case "style":
            return `Attribute \`${context.attr}\` must use \`${context.expected}\` instead of \`${context.actual}\`.`;
        case "unquoted":
            return `Attribute \`${context.attr}\` must not be unquoted.`;
    }
}
function describeStyle(style, unquoted) {
    const description = [];
    switch (style) {
        case QuoteStyle.AUTO_QUOTE:
            description.push("- quoted with double quotes `\"` unless the value contains double quotes in which case single quotes `'` should be used instead");
            break;
        case QuoteStyle.ANY_QUOTE:
            description.push("- quoted with single quotes `'`");
            description.push('- quoted with double quotes `"`');
            break;
        case QuoteStyle.SINGLE_QUOTE:
        case QuoteStyle.DOUBLE_QUOTE: {
            const name = style === QuoteStyle.SINGLE_QUOTE ? "single" : "double";
            description.push(`- quoted with ${name} quotes \`${style}\``);
            break;
        }
    }
    if (unquoted) {
        description.push("- unquoted (if applicable)");
    }
    return `${description.join(" or\n")}\n`;
}
class AttrQuotes extends Rule {
    static schema() {
        return {
            style: {
                enum: ["auto", "double", "single", "any"],
                type: "string",
            },
            unquoted: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        const { style } = this;
        const { unquoted } = this.options;
        const description = [
            describeError(context),
            "",
            "Under the current configuration attributes must be:",
            "",
            describeStyle(style, unquoted),
        ];
        return {
            description: description.join("\n"),
            url: "https://html-validate.org/rules/attr-quotes.html",
        };
    }
    constructor(options) {
        super({ ...defaults$q, ...options });
        this.style = parseStyle$3(this.options.style);
    }
    setup() {
        this.on("attr", (event) => {
            /* ignore attributes with no value */
            if (event.value === null) {
                return;
            }
            if (!event.quote) {
                if (!this.options.unquoted) {
                    const message = `Attribute "${event.key}" using unquoted value`;
                    const context = {
                        error: "unquoted",
                        attr: event.key,
                    };
                    this.report(event.target, message, null, context);
                }
                return;
            }
            /* if the style is set to any we skip the rest of the rule as the only
             * thing that matters is if the "unquoted" options triggers an error or
             * not */
            if (this.style === QuoteStyle.ANY_QUOTE) {
                return;
            }
            const expected = this.resolveQuotemark(event.value.toString(), this.style);
            if (event.quote !== expected) {
                const message = `Attribute "${event.key}" used ${event.quote} instead of expected ${expected}`;
                const context = {
                    error: "style",
                    attr: event.key,
                    actual: event.quote,
                    expected,
                };
                this.report(event.target, message, null, context);
            }
        });
    }
    resolveQuotemark(value, style) {
        if (style === QuoteStyle.AUTO_QUOTE) {
            return value.includes('"') ? "'" : '"';
        }
        else {
            return style;
        }
    }
}
function parseStyle$3(style) {
    switch (style.toLowerCase()) {
        case "auto":
            return QuoteStyle.AUTO_QUOTE;
        case "double":
            return QuoteStyle.DOUBLE_QUOTE;
        case "single":
            return QuoteStyle.SINGLE_QUOTE;
        case "any":
            return QuoteStyle.ANY_QUOTE;
        /* istanbul ignore next: covered by schema validation */
        default:
            throw new ConfigError(`Invalid style "${style}" for "attr-quotes" rule`);
    }
}

class AttrSpacing extends Rule {
    documentation() {
        return {
            description: `No space between attributes. At least one whitespace character (commonly space) must be used to separate attributes.`,
            url: "https://html-validate.org/rules/attr-spacing.html",
        };
    }
    setup() {
        let previousToken;
        this.on("token", (event) => {
            if (event.type === TokenType.ATTR_NAME && previousToken !== TokenType.WHITESPACE) {
                this.report(null, "No space between attributes", event.location);
            }
            previousToken = event.type;
        });
    }
}

function pick(attr) {
    const result = {};
    if (typeof attr.enum !== "undefined") {
        result.enum = attr.enum;
    }
    if (typeof attr.boolean !== "undefined") {
        result.boolean = attr.boolean;
    }
    return result;
}
class AttributeAllowedValues extends Rule {
    documentation(context) {
        const docs = {
            description: "Attribute has invalid value.",
            url: "https://html-validate.org/rules/attribute-allowed-values.html",
        };
        if (!context) {
            return docs;
        }
        const { allowed, attribute, element, value } = context;
        if (allowed.enum) {
            const allowedList = allowed.enum.map((value) => {
                if (typeof value === "string") {
                    return `- \`"${value}"\``;
                }
                else {
                    return `- \`${value.toString()}\``;
                }
            });
            docs.description = [
                `The \`<${element}>\` element does not allow the attribute \`${attribute}\` to have the value \`"${value}"\`.`,
                "",
                "It must match one of the following:",
                "",
                ...allowedList,
            ].join("\n");
        }
        else if (allowed.boolean) {
            docs.description = `The \`<${context.element}>\` attribute \`${context.attribute}\` must be a boolean attribute, e.g. \`<${context.element} ${context.attribute}>\``;
        }
        return docs;
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                const meta = node.meta;
                /* ignore rule if element has no meta or meta does not specify attribute
                 * allowed values */
                if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                    return;
                for (const attr of node.attributes) {
                    if (Validator.validateAttribute(attr, meta.attributes)) {
                        continue;
                    }
                    const value = attr.value ? attr.value.toString() : "";
                    const context = {
                        element: node.tagName,
                        attribute: attr.key,
                        value,
                        allowed: pick(meta.attributes[attr.key]),
                    };
                    const message = this.getMessage(attr);
                    const location = this.getLocation(attr);
                    this.report(node, message, location, context);
                }
            });
        });
    }
    getMessage(attr) {
        const { key, value } = attr;
        if (value !== null) {
            return `Attribute "${key}" has invalid value "${value.toString()}"`;
        }
        else {
            return `Attribute "${key}" is missing value`;
        }
    }
    getLocation(attr) {
        if (attr.value !== null) {
            return attr.valueLocation;
        }
        else {
            return attr.keyLocation;
        }
    }
}

const defaults$p = {
    style: "omit",
};
class AttributeBooleanStyle extends Rule {
    constructor(options) {
        super({ ...defaults$p, ...options });
        this.hasInvalidStyle = parseStyle$2(this.options.style);
    }
    static schema() {
        return {
            style: {
                enum: ["empty", "name", "omit"],
                type: "string",
            },
        };
    }
    documentation() {
        return {
            description: "Require a specific style when writing boolean attributes.",
            url: "https://html-validate.org/rules/attribute-boolean-style.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                const meta = node.meta;
                /* ignore rule if element has no meta or meta does not specify attribute
                 * allowed values */
                if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                    return;
                /* check all boolean attributes */
                for (const attr of node.attributes) {
                    if (!this.isBoolean(attr, meta.attributes))
                        continue;
                    /* ignore attribute if it is aliased by a dynamic value,
                     * e.g. ng-required or v-bind:required, since it will probably have a
                     * value despite the target attribute is a boolean. The framework is
                     * assumed to handle it properly */
                    if (attr.originalAttribute) {
                        continue;
                    }
                    if (this.hasInvalidStyle(attr)) {
                        this.report(node, reportMessage$1(attr, this.options.style), attr.keyLocation);
                    }
                }
            });
        });
    }
    isBoolean(attr, rules) {
        const meta = rules[attr.key];
        return Boolean(meta === null || meta === void 0 ? void 0 : meta.boolean);
    }
}
function parseStyle$2(style) {
    switch (style.toLowerCase()) {
        case "omit":
            return (attr) => attr.value !== null;
        case "empty":
            return (attr) => attr.value !== "";
        case "name":
            return (attr) => attr.value !== attr.key;
        /* istanbul ignore next: covered by schema validation */
        default:
            throw new Error(`Invalid style "${style}" for "attribute-boolean-style" rule`);
    }
}
function reportMessage$1(attr, style) {
    const key = attr.key;
    switch (style.toLowerCase()) {
        case "omit":
            return `Attribute "${key}" should omit value`;
        case "empty":
            return `Attribute "${key}" value should be empty string`;
        case "name":
            return `Attribute "${key}" should be set to ${key}="${key}"`;
    }
    /* istanbul ignore next: the above switch should cover all cases */
    return "";
}

const defaults$o = {
    style: "omit",
};
class AttributeEmptyStyle extends Rule {
    constructor(options) {
        super({ ...defaults$o, ...options });
        this.hasInvalidStyle = parseStyle$1(this.options.style);
    }
    static schema() {
        return {
            style: {
                enum: ["empty", "omit"],
                type: "string",
            },
        };
    }
    documentation() {
        return {
            description: "Require a specific style for attributes with empty values.",
            url: "https://html-validate.org/rules/attribute-empty-style.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                const meta = node.meta;
                /* ignore rule if element has no meta or meta does not specify attribute
                 * allowed values */
                if (!(meta === null || meta === void 0 ? void 0 : meta.attributes))
                    return;
                /* check all boolean attributes */
                for (const attr of node.attributes) {
                    /* only handle attributes which allows empty values */
                    if (!allowsEmpty(attr, meta.attributes)) {
                        continue;
                    }
                    /* skip attribute if the attribute is set to non-empty value
                     * (attribute-allowed-values deals with non-empty values)*/
                    if (!isEmptyValue(attr)) {
                        continue;
                    }
                    /* skip attribute if the style is valid */
                    if (!this.hasInvalidStyle(attr)) {
                        continue;
                    }
                    /* report error */
                    this.report(node, reportMessage(attr, this.options.style), attr.keyLocation);
                }
            });
        });
    }
}
function allowsEmpty(attr, rules) {
    const meta = rules[attr.key];
    return Boolean(meta === null || meta === void 0 ? void 0 : meta.omit);
}
function isEmptyValue(attr) {
    /* dynamic values are ignored, assumed to contain a value */
    if (attr.isDynamic) {
        return false;
    }
    return attr.value === null || attr.value === "";
}
function parseStyle$1(style) {
    switch (style.toLowerCase()) {
        case "omit":
            return (attr) => attr.value !== null;
        case "empty":
            return (attr) => attr.value !== "";
        /* istanbul ignore next: covered by schema validation */
        default:
            throw new Error(`Invalid style "${style}" for "attribute-empty-style" rule`);
    }
}
function reportMessage(attr, style) {
    const key = attr.key;
    switch (style.toLowerCase()) {
        case "omit":
            return `Attribute "${key}" should omit value`;
        case "empty":
            return `Attribute "${key}" value should be empty string`;
    }
    /* istanbul ignore next: the above switch should cover all cases */
    return "";
}

function ruleDescription(context) {
    const { attr, details } = context;
    return `The "${attr}" attribute cannot be used in this context: ${details}`;
}
class AttributeMisuse extends Rule {
    documentation(context) {
        return {
            description: ruleDescription(context),
            url: "https://html-validate.org/rules/attribute-misuse.html",
        };
    }
    setup() {
        this.on("element:ready", (event) => {
            const { target } = event;
            const { meta } = target;
            if (!meta) {
                return;
            }
            for (const attr of target.attributes) {
                const key = attr.key.toLowerCase();
                this.validateAttr(target, attr, meta.attributes[key]);
            }
        });
    }
    validateAttr(node, attr, meta) {
        if (!(meta === null || meta === void 0 ? void 0 : meta.allowed)) {
            return;
        }
        const details = meta.allowed(node._adapter, attr.value);
        if (details) {
            this.report({
                node,
                message: `"{{ attr }}" attribute cannot be used in this context: {{ details }}`,
                location: attr.keyLocation,
                context: {
                    attr: attr.key,
                    details,
                },
            });
        }
    }
}

function parsePattern(pattern) {
    switch (pattern) {
        case "kebabcase":
            return /^[a-z0-9-]+$/;
        case "camelcase":
            return /^[a-z][a-zA-Z0-9]+$/;
        case "underscore":
            return /^[a-z0-9_]+$/;
        default:
            /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be regexp */
            return new RegExp(pattern);
    }
}
function describePattern(pattern) {
    const regexp = parsePattern(pattern).toString();
    switch (pattern) {
        case "kebabcase":
        case "camelcase":
        case "underscore": {
            return `${regexp} (${pattern})`;
        }
        default:
            return regexp;
    }
}

const defaults$n = {
    pattern: "kebabcase",
};
class ClassPattern extends Rule {
    constructor(options) {
        super({ ...defaults$n, ...options });
        this.pattern = parsePattern(this.options.pattern);
    }
    static schema() {
        return {
            pattern: {
                type: "string",
            },
        };
    }
    documentation() {
        const pattern = describePattern(this.options.pattern);
        return {
            description: `For consistency all classes are required to match the pattern ${pattern}.`,
            url: "https://html-validate.org/rules/class-pattern.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (event.key.toLowerCase() !== "class") {
                return;
            }
            const classes = new DOMTokenList(event.value, event.valueLocation);
            classes.forEach((cur, index) => {
                if (!cur.match(this.pattern)) {
                    const location = classes.location(index);
                    const pattern = this.pattern.toString();
                    const message = `Class "${cur}" does not match required pattern "${pattern}"`;
                    this.report(event.target, message, location);
                }
            });
        });
    }
}

class CloseAttr extends Rule {
    documentation() {
        return {
            description: "HTML disallows end tags to have attributes.",
            url: "https://html-validate.org/rules/close-attr.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            /* handle unclosed tags */
            if (!event.target) {
                return;
            }
            /* ignore self-closed and void */
            if (event.previous === event.target) {
                return;
            }
            const node = event.target;
            if (Object.keys(node.attributes).length > 0) {
                const first = node.attributes[0];
                this.report(null, "Close tags cannot have attributes", first.keyLocation);
            }
        });
    }
}

class CloseOrder extends Rule {
    documentation() {
        return {
            description: "HTML requires elements to be closed in the same order as they were opened.",
            url: "https://html-validate.org/rules/close-order.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const current = event.target; // The current element being closed
            const active = event.previous; // The current active element (that is, the current element on the stack)
            /* handle unclosed tags */
            if (!current) {
                this.report(null, `Missing close-tag, expected '</${active.tagName}>' but document ended before it was found.`, event.location);
                return;
            }
            /* void elements are always closed in correct order but if the markup contains
             * an end-tag for it it should be ignored here since the void element is
             * implicitly closed in the right order, so the current active element is the
             * parent. */
            if (current.voidElement) {
                return;
            }
            /* if the active element is implicitly closed when the parent is closed
             * (such as a <li> by </ul>) no error should be reported. */
            if (active.closed === exports.NodeClosed.ImplicitClosed) {
                return;
            }
            /* handle unopened tags */
            if (active.isRootElement()) {
                const location = {
                    filename: current.location.filename,
                    line: current.location.line,
                    column: current.location.column,
                    offset: current.location.offset,
                    size: current.tagName.length + 1,
                };
                this.report(null, "Unexpected close-tag, expected opening tag.", location);
                return;
            }
            /* check for matching tagnames */
            if (current.tagName !== active.tagName) {
                this.report(null, `Mismatched close-tag, expected '</${active.tagName}>' but found '</${current.tagName}>'.`, current.location);
            }
        });
    }
}

const defaults$m = {
    include: null,
    exclude: null,
};
class Deprecated extends Rule {
    constructor(options) {
        super({ ...defaults$m, ...options });
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
        };
    }
    documentation(context) {
        const text = [];
        if (context.source) {
            const source = prettySource(context.source);
            const message = `The \`<$tagname>\` element is deprecated ${source} and should not be used in new code.`;
            text.push(message);
        }
        else {
            const message = `The \`<$tagname>\` element is deprecated and should not be used in new code.`;
            text.push(message);
        }
        if (context.documentation) {
            text.push(context.documentation);
        }
        const doc = {
            description: text.map((cur) => cur.replace(/\$tagname/g, context.tagName)).join("\n\n"),
            url: "https://html-validate.org/rules/deprecated.html",
        };
        return doc;
    }
    setup() {
        this.on("tag:start", (event) => {
            const node = event.target;
            /* cannot validate if meta isn't known */
            if (node.meta === null) {
                return;
            }
            /* ignore if element is not deprecated */
            const deprecated = node.meta.deprecated;
            if (!deprecated) {
                return;
            }
            /* ignore if element is ignored by used configuration */
            if (this.isKeywordIgnored(node.tagName)) {
                return;
            }
            const location = sliceLocation(event.location, 1);
            if (typeof deprecated === "string") {
                this.reportString(deprecated, node, location);
            }
            else if (typeof deprecated === "boolean") {
                this.reportBoolean(node, location);
            }
            else {
                this.reportObject(deprecated, node, location);
            }
        });
    }
    reportString(deprecated, node, location) {
        const context = { tagName: node.tagName };
        const message = `<${node.tagName}> is deprecated: ${deprecated}`;
        this.report(node, message, location, context);
    }
    reportBoolean(node, location) {
        const context = { tagName: node.tagName };
        const message = `<${node.tagName}> is deprecated`;
        this.report(node, message, location, context);
    }
    reportObject(deprecated, node, location) {
        const context = { ...deprecated, tagName: node.tagName };
        const notice = deprecated.message ? `: ${deprecated.message}` : "";
        const message = `<${node.tagName}> is deprecated${notice}`;
        this.report(node, message, location, context);
    }
}
function prettySource(source) {
    const match = source.match(/html(\d)(\d)?/);
    if (match) {
        const [, ...parts] = match;
        const version = parts.filter(Boolean).join(".");
        return `in HTML ${version}`;
    }
    switch (source) {
        case "whatwg":
            return "in HTML Living Standard";
        case "non-standard":
            return "and non-standard";
        default:
            return `by ${source}`;
    }
}

class DeprecatedRule extends Rule {
    documentation(context) {
        const preamble = context ? `The rule "${context}"` : "This rule";
        return {
            description: `${preamble} is deprecated and should not be used any longer, consult documentation for further information.`,
            url: "https://html-validate.org/rules/deprecated-rule.html",
        };
    }
    setup() {
        this.on("config:ready", (event) => {
            for (const rule of this.getDeprecatedRules(event)) {
                if (rule.getSeverity() > exports.Severity.DISABLED) {
                    this.report(null, `Usage of deprecated rule "${rule.name}"`, null, rule.name);
                }
            }
        });
    }
    getDeprecatedRules(event) {
        const rules = Object.values(event.rules);
        return rules.filter((rule) => rule.deprecated);
    }
}

let NoStyleTag$1 = class NoStyleTag extends Rule {
    documentation() {
        return {
            description: [
                'HTML5 documents should use the "html" doctype (short `form`, not legacy string):',
                "",
                "```html",
                "<!DOCTYPE html>",
                "```",
            ].join("\n"),
            url: "https://html-validate.org/rules/doctype-html.html",
        };
    }
    setup() {
        this.on("doctype", (event) => {
            const doctype = event.value.toLowerCase();
            if (doctype !== "html") {
                this.report(null, 'doctype should be "html"', event.valueLocation);
            }
        });
    }
};

const defaults$l = {
    style: "uppercase",
};
class DoctypeStyle extends Rule {
    constructor(options) {
        super({ ...defaults$l, ...options });
    }
    static schema() {
        return {
            style: {
                enum: ["lowercase", "uppercase"],
                type: "string",
            },
        };
    }
    documentation(context) {
        return {
            description: `While DOCTYPE is case-insensitive in the standard the current configuration requires it to be ${context.style}`,
            url: "https://html-validate.org/rules/doctype-style.html",
        };
    }
    setup() {
        this.on("doctype", (event) => {
            if (this.options.style === "uppercase" && event.tag !== "DOCTYPE") {
                this.report(null, "DOCTYPE should be uppercase", event.location, this.options);
            }
            if (this.options.style === "lowercase" && event.tag !== "doctype") {
                this.report(null, "DOCTYPE should be lowercase", event.location, this.options);
            }
        });
    }
}

const defaults$k = {
    style: "lowercase",
};
class ElementCase extends Rule {
    constructor(options) {
        super({ ...defaults$k, ...options });
        this.style = new CaseStyle(this.options.style, "element-case");
    }
    static schema() {
        const styleEnum = ["lowercase", "uppercase", "pascalcase", "camelcase"];
        return {
            style: {
                anyOf: [
                    {
                        enum: styleEnum,
                        type: "string",
                    },
                    {
                        items: {
                            enum: styleEnum,
                            type: "string",
                        },
                        type: "array",
                    },
                ],
            },
        };
    }
    documentation() {
        const { style } = this.options;
        return {
            description: Array.isArray(style)
                ? [`Element tagname must be in one of:`, "", ...style.map((it) => `- ${it}`)].join("\n")
                : `Element tagname must be in ${style}.`,
            url: "https://html-validate.org/rules/element-case.html",
        };
    }
    setup() {
        this.on("tag:start", (event) => {
            const { target, location } = event;
            this.validateCase(target, location);
        });
        this.on("tag:end", (event) => {
            const { target, previous } = event;
            this.validateMatchingCase(previous, target);
        });
    }
    validateCase(target, targetLocation) {
        const letters = target.tagName.replace(/[^a-z]+/gi, "");
        if (!this.style.match(letters)) {
            const location = sliceLocation(targetLocation, 1);
            this.report(target, `Element "${target.tagName}" should be ${this.style.name}`, location);
        }
    }
    validateMatchingCase(start, end) {
        /* handle when elements have have missing start or end tag */
        if (!start || !end || !start.tagName || !end.tagName) {
            return;
        }
        /* only check case if the names are a lowercase match to each other or it
         * will yield false positives when elements are closed in wrong order or
         * otherwise mismatched */
        if (start.tagName.toLowerCase() !== end.tagName.toLowerCase()) {
            return;
        }
        if (start.tagName !== end.tagName) {
            this.report(start, "Start and end tag must not differ in casing", end.location);
        }
    }
}

const defaults$j = {
    pattern: "^[a-z][a-z0-9\\-._]*-[a-z0-9\\-._]*$",
    whitelist: [],
    blacklist: [],
};
class ElementName extends Rule {
    constructor(options) {
        super({ ...defaults$j, ...options });
        /* eslint-disable-next-line security/detect-non-literal-regexp -- expected to be a regexp */
        this.pattern = new RegExp(this.options.pattern);
    }
    static schema() {
        return {
            blacklist: {
                items: {
                    type: "string",
                },
                type: "array",
            },
            pattern: {
                type: "string",
            },
            whitelist: {
                items: {
                    type: "string",
                },
                type: "array",
            },
        };
    }
    documentation(context) {
        return {
            description: this.documentationMessages(context).join("\n"),
            url: "https://html-validate.org/rules/element-name.html",
        };
    }
    documentationMessages(context) {
        if (context.blacklist.includes(context.tagName)) {
            return [
                `<${context.tagName}> is blacklisted by the project configuration.`,
                "",
                "The following names are blacklisted:",
                ...context.blacklist.map((cur) => `- ${cur}`),
            ];
        }
        if (context.pattern !== defaults$j.pattern) {
            return [
                `<${context.tagName}> is not a valid element name. This project is configured to only allow names matching the following regular expression:`,
                "",
                `- \`${context.pattern}\``,
            ];
        }
        return [
            `<${context.tagName}> is not a valid element name. If this is a custom element HTML requires the name to follow these rules:`,
            "",
            "- The name must begin with `a-z`",
            "- The name must include a hyphen `-`",
            "- It may include alphanumerical characters `a-z0-9` or hyphens `-`, dots `.` or underscores `_`.",
        ];
    }
    setup() {
        const xmlns = /^(.+):.+$/;
        this.on("tag:start", (event) => {
            const target = event.target;
            const tagName = target.tagName;
            const location = sliceLocation(event.location, 1);
            const context = {
                tagName,
                pattern: this.options.pattern,
                blacklist: this.options.blacklist,
            };
            /* check if element is blacklisted */
            if (this.options.blacklist.includes(tagName)) {
                this.report(target, `<${tagName}> element is blacklisted`, location, context);
            }
            /* assume that an element with meta has valid name as it is a builtin
             * element */
            if (target.meta) {
                return;
            }
            /* ignore elements in xml namespaces, they should be validated against a
             * DTD instead */
            if (tagName.match(xmlns)) {
                return;
            }
            /* check if element is whitelisted */
            if (this.options.whitelist.includes(tagName)) {
                return;
            }
            if (!tagName.match(this.pattern)) {
                this.report(target, `<${tagName}> is not a valid element name`, location, context);
            }
        });
    }
}

var ErrorKind;
(function (ErrorKind) {
    ErrorKind["CONTENT"] = "content";
    ErrorKind["DESCENDANT"] = "descendant";
})(ErrorKind || (ErrorKind = {}));
function getTransparentChildren(node, transparent) {
    if (typeof transparent === "boolean") {
        return node.childElements;
    }
    else {
        /* only return children which matches one of the given content categories */
        return node.childElements.filter((it) => {
            return transparent.some((category) => {
                return Validator.validatePermittedCategory(it, category, false);
            });
        });
    }
}
function getRuleDescription$2(context) {
    switch (context.kind) {
        case ErrorKind.CONTENT:
            return [
                `The \`${context.child}\` element is not permitted as content under the parent \`${context.parent}\` element.`,
            ];
        case ErrorKind.DESCENDANT:
            return [
                `The \`${context.child}\` element is not permitted as a descendant of the \`${context.ancestor}\` element.`,
            ];
    }
}
class ElementPermittedContent extends Rule {
    documentation(context) {
        return {
            description: getRuleDescription$2(context).join("\n"),
            url: "https://html-validate.org/rules/element-permitted-content.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                const parent = node.parent;
                /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                 * will not yield nodes without a parent */
                if (!parent) {
                    return;
                }
                /* Run each validation step, stop as soon as any errors are
                 * reported. This is to prevent multiple similar errors on the same
                 * element, such as "<dd> is not permitted content under <span>" and
                 * "<dd> has no permitted ancestors". */
                [
                    () => this.validatePermittedContent(node, parent),
                    () => this.validatePermittedDescendant(node, parent),
                ].some((fn) => fn());
            });
        });
    }
    validatePermittedContent(cur, parent) {
        var _a;
        /* if parent doesn't have metadata (unknown element) skip checking permitted
         * content */
        if (!parent.meta) {
            return false;
        }
        const rules = (_a = parent.meta.permittedContent) !== null && _a !== void 0 ? _a : null;
        return this.validatePermittedContentImpl(cur, parent, rules);
    }
    validatePermittedContentImpl(cur, parent, rules) {
        if (!Validator.validatePermitted(cur, rules)) {
            const child = `<${cur.tagName}>`;
            const message = `${child} element is not permitted as content under ${parent.annotatedName}`;
            const context = {
                kind: ErrorKind.CONTENT,
                parent: parent.annotatedName,
                child,
            };
            this.report(cur, message, null, context);
            return true;
        }
        /* for transparent elements all/listed children must be validated against
         * the (this elements) parent, i.e. if this node was removed from the DOM it
         * should still be valid. */
        if (cur.meta && cur.meta.transparent) {
            const children = getTransparentChildren(cur, cur.meta.transparent);
            return children
                .map((child) => {
                return this.validatePermittedContentImpl(child, parent, rules);
            })
                .some(Boolean);
        }
        return false;
    }
    validatePermittedDescendant(node, parent) {
        var _a;
        for (let cur = parent; cur && !cur.isRootElement(); cur = /* istanbul ignore next */ (_a = cur === null || cur === void 0 ? void 0 : cur.parent) !== null && _a !== void 0 ? _a : null) {
            const meta = cur.meta;
            /* ignore checking parent without meta */
            if (!meta) {
                continue;
            }
            const rules = meta.permittedDescendants;
            if (!rules) {
                continue;
            }
            if (Validator.validatePermitted(node, rules)) {
                continue;
            }
            const child = `<${node.tagName}>`;
            const ancestor = cur.annotatedName;
            const message = `${child} element is not permitted as a descendant of ${ancestor}`;
            const context = {
                kind: ErrorKind.DESCENDANT,
                ancestor,
                child,
            };
            this.report(node, message, null, context);
            return true;
        }
        return false;
    }
}

class ElementPermittedOccurrences extends Rule {
    documentation() {
        return {
            description: "Some elements may only be used a fixed amount of times in given context.",
            url: "https://html-validate.org/rules/element-permitted-occurrences.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                if (!node.meta) {
                    return;
                }
                const rules = node.meta.permittedContent;
                if (!rules) {
                    return;
                }
                Validator.validateOccurrences(node.childElements, rules, (child, category) => {
                    this.report(child, `Element <${category}> can only appear once under ${node.annotatedName}`);
                });
            });
        });
    }
}

class ElementPermittedOrder extends Rule {
    documentation() {
        return {
            description: "Some elements has a specific order the children must use.",
            url: "https://html-validate.org/rules/element-permitted-order.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                if (!node.meta) {
                    return;
                }
                const rules = node.meta.permittedOrder;
                if (!rules) {
                    return;
                }
                Validator.validateOrder(node.childElements, rules, (child, prev) => {
                    this.report(child, `Element <${child.tagName}> must be used before <${prev.tagName}> in this context`);
                });
            });
        });
    }
}

function isCategoryOrTag(value) {
    return typeof value === "string";
}
function isCategory$1(value) {
    return value.startsWith("@");
}
function formatCategoryOrTag(value) {
    return isCategory$1(value) ? value.slice(1) : `<${value}>`;
}
function isFormattable(rules) {
    return rules.length > 0 && rules.every(isCategoryOrTag);
}
function getRuleDescription$1(context) {
    const { child, parent, rules } = context;
    const preamble = `The \`${child}\` element cannot have a \`${parent}\` element as parent.`;
    if (isFormattable(rules)) {
        const allowed = rules.filter(isCategoryOrTag).map((it) => {
            if (isCategory$1(it)) {
                return `- any ${it.slice(1)} element`;
            }
            else {
                return `- \`<${it}>\``;
            }
        });
        return [preamble, "", "Allowed parents one of:", "", ...allowed];
    }
    else {
        return [preamble];
    }
}
function formatMessage$1(node, parent, rules) {
    const nodeName = node.annotatedName;
    const parentName = parent.annotatedName;
    if (!isFormattable(rules)) {
        return `${nodeName} element cannot have ${parentName} element as parent`;
    }
    const allowed = utils_naturalJoin.naturalJoin(rules.filter(isCategoryOrTag).map(formatCategoryOrTag));
    return `${nodeName} element requires a ${allowed} element as parent`;
}
class ElementPermittedParent extends Rule {
    documentation(context) {
        return {
            description: getRuleDescription$1(context).join("\n"),
            url: "https://html-validate.org/rules/element-permitted-parent.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                var _a;
                const parent = node.parent;
                /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                 * will not yield nodes without a parent */
                if (!parent) {
                    return;
                }
                /* don't validate root element as the <html> and <body> tag is optional
                 * so anything could be directly under the root element. */
                if (parent.isRootElement()) {
                    return;
                }
                /* when the parent element is the same as the current element we ignore
                 * this rule and let `element-permitted-content` handle it as it will
                 * create a lot of duplicate errors otherwise */
                if (parent.tagName === node.tagName) {
                    return;
                }
                /* if parent doesn't have metadata (unknown element) skip checking permitted
                 * content */
                const rules = (_a = node.meta) === null || _a === void 0 ? void 0 : _a.permittedParent;
                if (!rules) {
                    return false;
                }
                if (Validator.validatePermitted(parent, rules)) {
                    return;
                }
                const message = formatMessage$1(node, parent, rules);
                const context = {
                    parent: parent.annotatedName,
                    child: node.annotatedName,
                    rules,
                };
                this.report(node, message, null, context);
            });
        });
    }
}

function isTagnameOnly(value) {
    return Boolean(value.match(/^[a-zA-Z0-9-]+$/));
}
function getRuleDescription(context) {
    const escaped = context.ancestor.map((it) => `\`${it}\``);
    return [`The \`${context.child}\` element requires a ${utils_naturalJoin.naturalJoin(escaped)} ancestor.`];
}
class ElementRequiredAncestor extends Rule {
    documentation(context) {
        return {
            description: getRuleDescription(context).join("\n"),
            url: "https://html-validate.org/rules/element-required-ancestor.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                const parent = node.parent;
                /* istanbul ignore next: satisfy typescript but will visitDepthFirst()
                 * will not yield nodes without a parent */
                if (!parent) {
                    return;
                }
                this.validateRequiredAncestors(node);
            });
        });
    }
    validateRequiredAncestors(node) {
        if (!node.meta) {
            return;
        }
        const rules = node.meta.requiredAncestors;
        if (!rules) {
            return;
        }
        if (Validator.validateAncestors(node, rules)) {
            return;
        }
        const ancestor = rules.map((it) => (isTagnameOnly(it) ? `<${it}>` : `"${it}"`));
        const child = `<${node.tagName}>`;
        const message = `<${node.tagName}> element requires a ${utils_naturalJoin.naturalJoin(ancestor)} ancestor`;
        const context = {
            ancestor,
            child,
        };
        this.report(node, message, null, context);
    }
}

class ElementRequiredAttributes extends Rule {
    documentation(context) {
        const docs = {
            description: "Element is missing a required attribute",
            url: "https://html-validate.org/rules/element-required-attributes.html",
        };
        if (context) {
            docs.description = `The <${context.element}> element is required to have a "${context.attribute}" attribute.`;
        }
        return docs;
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.previous;
            const meta = node.meta;
            /* handle missing metadata and missing attributes */
            if (!(meta === null || meta === void 0 ? void 0 : meta.attributes)) {
                return;
            }
            for (const [key, attr] of Object.entries(meta.attributes)) {
                if (!attr.required) {
                    continue;
                }
                if (node.hasAttribute(key))
                    continue;
                const context = {
                    element: node.tagName,
                    attribute: key,
                };
                this.report(node, `${node.annotatedName} is missing required "${key}" attribute`, node.location, context);
            }
        });
    }
}

function isCategory(value) {
    return value.startsWith("@");
}
class ElementRequiredContent extends Rule {
    documentation(context) {
        const { element, missing } = context;
        return {
            description: `The \`${element}\` element requires a \`${missing}\` to be present as content.`,
            url: "https://html-validate.org/rules/element-required-content.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            doc.visitDepthFirst((node) => {
                /* if element doesn't have metadata (unknown element) skip checking
                 * required content */
                if (!node.meta) {
                    return;
                }
                const rules = node.meta.requiredContent;
                if (!rules) {
                    return;
                }
                for (const missing of Validator.validateRequiredContent(node, rules)) {
                    const context = {
                        element: node.annotatedName,
                        missing: `<${missing}>`,
                    };
                    const tag = isCategory(missing) ? `${missing.slice(1)} element` : `<${missing}>`;
                    const message = `${node.annotatedName} element must have ${tag} as content`;
                    this.report(node, message, null, context);
                }
            });
        });
    }
}

const selector = ["h1", "h2", "h3", "h4", "h5", "h6"].join(",");
function hasImgAltText$1(node) {
    if (node.is("img")) {
        return hasAltText(node);
    }
    else if (node.is("svg")) {
        return node.textContent.trim() !== "";
    }
    /* istanbul ignore next -- querySelector(..) is only going to return the two
     * above tags but this serves as a sane default if above assumption changes  */
    return false;
}
class EmptyHeading extends Rule {
    documentation() {
        return {
            description: `Assistive technology such as screen readers require textual content in headings. Whitespace only is considered empty.`,
            url: "https://html-validate.org/rules/empty-heading.html",
        };
    }
    setup() {
        this.on("dom:ready", ({ document }) => {
            const headings = document.querySelectorAll(selector);
            for (const heading of headings) {
                this.validateHeading(heading);
            }
        });
    }
    validateHeading(heading) {
        const images = heading.querySelectorAll("img, svg");
        for (const child of images) {
            if (hasImgAltText$1(child)) {
                return;
            }
        }
        switch (classifyNodeText(heading, { ignoreHiddenRoot: true })) {
            case exports.TextClassification.DYNAMIC_TEXT:
            case exports.TextClassification.STATIC_TEXT:
                /* have some text content, consider ok */
                break;
            case exports.TextClassification.EMPTY_TEXT:
                /* no content or whitespace only */
                this.report(heading, `<${heading.tagName}> cannot be empty, must have text content`);
                break;
        }
    }
}

class EmptyTitle extends Rule {
    documentation() {
        return {
            description: [
                "The `<title>` element cannot be empty, it must have textual content.",
                "",
                "It is used to describe the document and is shown in the browser tab and titlebar.",
                "WCAG and SEO requires a descriptive title and preferably unique within the site.",
                "",
                "Whitespace is ignored.",
            ].join("\n"),
            url: "https://html-validate.org/rules/empty-title.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.previous;
            if (node.tagName !== "title")
                return;
            switch (classifyNodeText(node)) {
                case exports.TextClassification.DYNAMIC_TEXT:
                case exports.TextClassification.STATIC_TEXT:
                    /* have some text content, consider ok */
                    break;
                case exports.TextClassification.EMPTY_TEXT:
                    /* no content or whitespace only */
                    {
                        const message = `<${node.tagName}> cannot be empty, must have text content`;
                        this.report(node, message, node.location);
                    }
                    break;
            }
        });
    }
}

const defaults$i = {
    allowArrayBrackets: true,
    shared: ["radio", "button", "reset", "submit"],
};
const UNIQUE_CACHE_KEY = Symbol("form-elements-unique");
const SHARED_CACHE_KEY = Symbol("form-elements-shared");
function haveName(name) {
    return typeof name === "string" && name !== "";
}
function allowSharedName(node, shared) {
    const type = node.getAttribute("type");
    return Boolean(type && type.valueMatches(shared, false));
}
function getDocumentation(context) {
    const trailer = "Each form control must have a unique name.";
    const { name } = context;
    switch (context.kind) {
        case "duplicate":
            return [`Duplicate form control name "${name}"`, trailer].join("\n");
        case "mix":
            return [
                `Form control name cannot mix regular name "{{ name }}" with array brackets "{{ name }}[]"`,
                trailer,
            ].join("\n");
    }
}
class FormDupName extends Rule {
    constructor(options) {
        super({ ...defaults$i, ...options });
    }
    static schema() {
        return {
            allowArrayBrackets: {
                type: "boolean",
            },
            shared: {
                type: "array",
                items: {
                    enum: ["radio", "checkbox", "submit", "button", "reset"],
                },
            },
        };
    }
    documentation(context) {
        return {
            description: getDocumentation(context),
            url: "https://html-validate.org/rules/form-dup-name.html",
        };
    }
    setup() {
        const selector = this.getSelector();
        const { shared } = this.options;
        this.on("dom:ready", (event) => {
            var _a, _b;
            const { document } = event;
            const controls = document.querySelectorAll(selector);
            const [sharedControls, uniqueControls] = partition(controls, (it) => {
                return allowSharedName(it, shared);
            });
            /* validate all form controls which require unique elements first so each
             * form has a populated list of unique names */
            for (const control of uniqueControls) {
                const attr = control.getAttribute("name");
                const name = attr === null || attr === void 0 ? void 0 : attr.value;
                if (!attr || !haveName(name)) {
                    continue;
                }
                const form = (_a = control.closest("form")) !== null && _a !== void 0 ? _a : document.root;
                this.validateUniqueName(control, form, attr, name);
            }
            /* validate all form controls which allows shared names to ensure there is
             * no collision with other form controls */
            for (const control of sharedControls) {
                const attr = control.getAttribute("name");
                const name = attr === null || attr === void 0 ? void 0 : attr.value;
                if (!attr || !haveName(name)) {
                    continue;
                }
                const form = (_b = control.closest("form")) !== null && _b !== void 0 ? _b : document.root;
                this.validateSharedName(control, form, attr, name);
            }
        });
    }
    validateUniqueName(control, form, attr, name) {
        const elements = this.getUniqueElements(form);
        const { allowArrayBrackets } = this.options;
        if (allowArrayBrackets) {
            const isarray = name.endsWith("[]");
            const basename = isarray ? name.slice(0, -2) : name;
            const details = elements.get(basename);
            if (details && details.array !== isarray) {
                const context = {
                    name: basename,
                    kind: "mix",
                };
                this.report({
                    node: control,
                    location: attr.valueLocation,
                    message: 'Cannot mix "{{ name }}[]" and "{{ name }}"',
                    context,
                });
                return;
            }
            else if (!details && isarray) {
                elements.set(basename, {
                    array: true,
                });
                return;
            }
        }
        if (elements.has(name)) {
            const context = {
                name,
                kind: "duplicate",
            };
            this.report({
                node: control,
                location: attr.valueLocation,
                message: 'Duplicate form control name "{{ name }}"',
                context,
            });
        }
        else {
            elements.set(name, {
                array: false,
            });
        }
    }
    validateSharedName(control, form, attr, name) {
        var _a;
        const uniqueElements = this.getUniqueElements(form);
        const sharedElements = this.getSharedElements(form);
        /* istanbul ignore next: type will always be set or shared name wouldn't be allowed */
        const type = (_a = control.getAttributeValue("type")) !== null && _a !== void 0 ? _a : "";
        if (uniqueElements.has(name) ||
            (sharedElements.has(name) && sharedElements.get(name) !== type)) {
            const context = {
                name,
                kind: "duplicate",
            };
            this.report({
                node: control,
                location: attr.valueLocation,
                message: 'Duplicate form control name "{{ name }}"',
                context,
            });
        }
        sharedElements.set(name, type);
    }
    getSelector() {
        const tags = this.getTagsWithProperty("formAssociated").filter((it) => {
            return this.isListedElement(it);
        });
        return tags.join(", ");
    }
    isListedElement(tagName) {
        const meta = this.getMetaFor(tagName);
        /* istanbul ignore next: the earlier check for getTagsWithProperty ensures
         * these will actually be set so this is just an untestable fallback */
        if (!(meta === null || meta === void 0 ? void 0 : meta.formAssociated)) {
            return false;
        }
        return meta.formAssociated.listed;
    }
    getUniqueElements(form) {
        const existing = form.cacheGet(UNIQUE_CACHE_KEY);
        if (existing) {
            return existing;
        }
        else {
            const elements = new Map();
            form.cacheSet(UNIQUE_CACHE_KEY, elements);
            return elements;
        }
    }
    getSharedElements(form) {
        const existing = form.cacheGet(SHARED_CACHE_KEY);
        if (existing) {
            return existing;
        }
        else {
            const elements = new Map();
            form.cacheSet(SHARED_CACHE_KEY, elements);
            return elements;
        }
    }
}

const defaults$h = {
    allowMultipleH1: false,
    minInitialRank: "h1",
    sectioningRoots: ["dialog", '[role="dialog"]', '[role="alertdialog"]'],
};
function isRelevant$4(event) {
    const node = event.target;
    return Boolean(node.meta && node.meta.heading);
}
function extractLevel(node) {
    const match = node.tagName.match(/^[hH](\d)$/);
    if (match) {
        return parseInt(match[1], 10);
    }
    else {
        return null;
    }
}
function parseMaxInitial(value) {
    if (value === false || value === "any") {
        return 6;
    }
    const match = value.match(/^h(\d)$/);
    /* istanbul ignore next: should never happen, schema validation should catch invalid values */
    if (!match) {
        return 1;
    }
    return parseInt(match[1], 10);
}
class HeadingLevel extends Rule {
    constructor(options) {
        super({ ...defaults$h, ...options });
        this.stack = [];
        this.minInitialRank = parseMaxInitial(this.options.minInitialRank);
        this.sectionRoots = this.options.sectioningRoots.map((it) => new Pattern(it));
        /* add a global sectioning root used by default */
        this.stack.push({
            node: null,
            current: 0,
            h1Count: 0,
        });
    }
    static schema() {
        return {
            allowMultipleH1: {
                type: "boolean",
            },
            minInitialRank: {
                enum: ["h1", "h2", "h3", "h4", "h5", "h6", "any", false],
            },
            sectioningRoots: {
                items: {
                    type: "string",
                },
                type: "array",
            },
        };
    }
    documentation() {
        const text = [];
        const modality = this.minInitialRank > 1 ? "should" : "must";
        text.push(`Headings ${modality} start at <h1> and can only increase one level at a time.`);
        text.push("The headings should form a table of contents and make sense on its own.");
        if (!this.options.allowMultipleH1) {
            text.push("");
            text.push("Under the current configuration only a single <h1> can be present at a time in the document.");
        }
        return {
            description: text.join("\n"),
            url: "https://html-validate.org/rules/heading-level.html",
        };
    }
    setup() {
        this.on("tag:start", isRelevant$4, (event) => {
            this.onTagStart(event);
        });
        this.on("tag:ready", (event) => {
            this.onTagReady(event);
        });
        this.on("tag:close", (event) => {
            this.onTagClose(event);
        });
    }
    onTagStart(event) {
        /* extract heading level from tagName (e.g "h1" -> 1)*/
        const level = extractLevel(event.target);
        if (!level)
            return;
        /* fetch the current sectioning root */
        const root = this.getCurrentRoot();
        /* do not allow multiple h1 */
        if (!this.options.allowMultipleH1 && level === 1) {
            if (root.h1Count >= 1) {
                const location = sliceLocation(event.location, 1);
                this.report(event.target, `Multiple <h1> are not allowed`, location);
                return;
            }
            root.h1Count++;
        }
        /* allow same level or decreasing to any level (e.g. from h4 to h2) */
        if (level <= root.current) {
            root.current = level;
            return;
        }
        this.checkLevelIncrementation(root, event, level);
        root.current = level;
    }
    /**
     * Validate heading level was only incremented by one.
     */
    checkLevelIncrementation(root, event, level) {
        const expected = root.current + 1;
        /* check if the new level is the expected one (headings with higher ranks
         * are skipped already) */
        if (level === expected) {
            return;
        }
        /* if this is the initial heading of the document it is compared to the
         * minimal allowed (default h1) */
        const isInitial = this.stack.length === 1 && expected === 1;
        if (isInitial && level <= this.minInitialRank) {
            return;
        }
        /* if we reach this far the heading level is not accepted */
        const location = sliceLocation(event.location, 1);
        if (root.current > 0) {
            const msg = `Heading level can only increase by one, expected <h${expected}> but got <h${level}>`;
            this.report(event.target, msg, location);
        }
        else {
            this.checkInitialLevel(event, location, level, expected);
        }
    }
    checkInitialLevel(event, location, level, expected) {
        if (this.stack.length === 1) {
            const msg = this.minInitialRank > 1
                ? `Initial heading level must be <h${this.minInitialRank}> or higher rank but got <h${level}>`
                : `Initial heading level must be <h${expected}> but got <h${level}>`;
            this.report(event.target, msg, location);
        }
        else {
            const prevRoot = this.getPrevRoot();
            const prevRootExpected = prevRoot.current + 1;
            if (level > prevRootExpected) {
                if (expected === prevRootExpected) {
                    const msg = `Initial heading level for sectioning root must be <h${expected}> but got <h${level}>`;
                    this.report(event.target, msg, location);
                }
                else {
                    const msg = `Initial heading level for sectioning root must be between <h${expected}> and <h${prevRootExpected}> but got <h${level}>`;
                    this.report(event.target, msg, location);
                }
            }
        }
    }
    /**
     * Check if the current element is a sectioning root and push a new root entry
     * on the stack if it is.
     */
    onTagReady(event) {
        const { target } = event;
        if (this.isSectioningRoot(target)) {
            this.stack.push({
                node: target.unique,
                current: 0,
                h1Count: 0,
            });
        }
    }
    /**
     * Check if the current element being closed is the element which opened the
     * current sectioning root, in which case the entry is popped from the stack.
     */
    onTagClose(event) {
        const { previous: target } = event;
        const root = this.getCurrentRoot();
        if (target.unique !== root.node) {
            return;
        }
        this.stack.pop();
    }
    getPrevRoot() {
        return this.stack[this.stack.length - 2];
    }
    getCurrentRoot() {
        return this.stack[this.stack.length - 1];
    }
    isSectioningRoot(node) {
        const context = {
            scope: node,
        };
        return this.sectionRoots.some((it) => it.match(node, context));
    }
}

const defaults$g = {
    pattern: "kebabcase",
};
class IdPattern extends Rule {
    constructor(options) {
        super({ ...defaults$g, ...options });
        this.pattern = parsePattern(this.options.pattern);
    }
    static schema() {
        return {
            pattern: {
                type: "string",
            },
        };
    }
    documentation() {
        const pattern = describePattern(this.options.pattern);
        return {
            description: `For consistency all IDs are required to match the pattern ${pattern}.`,
            url: "https://html-validate.org/rules/id-pattern.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            var _a, _b;
            if (event.key.toLowerCase() !== "id") {
                return;
            }
            /* consider dynamic value as always matching the pattern */
            if (event.value instanceof DynamicValue) {
                return;
            }
            if (!((_a = event.value) === null || _a === void 0 ? void 0 : _a.match(this.pattern))) {
                const value = (_b = event.value) !== null && _b !== void 0 ? _b : "";
                const pattern = this.pattern.toString();
                const message = `ID "${value}" does not match required pattern "${pattern}"`;
                this.report(event.target, message, event.valueLocation);
            }
        });
    }
}

/* eslint-disable sonarjs/no-duplicate-string -- wont be easier to read or manage with constants */
const restricted = new Map([
    ["accept", ["file"]],
    ["alt", ["image"]],
    [
        "autocomplete",
        [
            "hidden",
            "text",
            "search",
            "url",
            "tel",
            "email",
            "password",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
            "range",
            "color",
        ],
    ],
    ["capture", ["file"]],
    ["checked", ["checkbox", "radio"]],
    ["dirname", ["text", "search"]],
    ["height", ["image"]],
    [
        "list",
        [
            "text",
            "search",
            "url",
            "tel",
            "email",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
            "range",
            "color",
        ],
    ],
    ["max", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
    ["maxlength", ["text", "search", "url", "tel", "email", "password"]],
    ["min", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
    ["minlength", ["text", "search", "url", "tel", "email", "password"]],
    ["multiple", ["email", "file"]],
    ["pattern", ["text", "search", "url", "tel", "email", "password"]],
    ["placeholder", ["text", "search", "url", "tel", "email", "password", "number"]],
    [
        "readonly",
        [
            "text",
            "search",
            "url",
            "tel",
            "email",
            "password",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
        ],
    ],
    [
        "required",
        [
            "text",
            "search",
            "url",
            "tel",
            "email",
            "password",
            "date",
            "month",
            "week",
            "time",
            "datetime-local",
            "number",
            "checkbox",
            "radio",
            "file",
        ],
    ],
    ["size", ["text", "search", "url", "tel", "email", "password"]],
    ["src", ["image"]],
    ["step", ["date", "month", "week", "time", "datetime-local", "number", "range"]],
    ["width", ["image"]],
]);
function isInput(event) {
    const { target } = event;
    return target.is("input");
}
class InputAttributes extends Rule {
    documentation(context) {
        var _a, _b;
        const { attribute, type } = context;
        const summary = `Attribute \`${attribute}\` is not allowed on \`<input type="${type}">\`\n`;
        const details = `\`${attribute}\` can only be used when \`type\` is:`;
        const list = (_b = (_a = restricted.get(attribute)) === null || _a === void 0 ? void 0 : _a.map((it) => `- \`${it}\``)) !== null && _b !== void 0 ? _b : [];
        return {
            description: [summary, details, ...list].join("\n"),
            url: "https://html-validate.org/rules/input-attributes.html",
        };
    }
    setup() {
        this.on("tag:ready", isInput, (event) => {
            const { target } = event;
            const type = target.getAttribute("type");
            if (!type || type.isDynamic || !type.value) {
                return;
            }
            const typeValue = type.value.toString();
            for (const attr of target.attributes) {
                const validTypes = restricted.get(attr.key);
                if (!validTypes) {
                    continue;
                }
                if (validTypes.includes(typeValue)) {
                    continue;
                }
                const context = {
                    attribute: attr.key,
                    type: typeValue,
                };
                const message = `Attribute "${attr.key}" is not allowed on <input type="${typeValue}">`;
                this.report(target, message, attr.keyLocation, context);
            }
        });
    }
}

const HAS_ACCESSIBLE_TEXT_CACHE = Symbol(hasAccessibleName.name);
function isHidden(node, context) {
    const { reference } = context;
    if (reference && reference.isSameNode(node)) {
        return false;
    }
    else {
        return isHTMLHidden(node) || !inAccessibilityTree(node);
    }
}
function hasImgAltText(node, context) {
    if (node.is("img")) {
        return hasAltText(node);
    }
    else if (node.is("svg")) {
        return node.textContent.trim() !== "";
    }
    else {
        for (const img of node.querySelectorAll("img, svg")) {
            const hasName = hasAccessibleNameImpl(img, context);
            if (hasName) {
                return true;
            }
        }
        return false;
    }
}
function hasLabel(node) {
    var _a;
    const value = (_a = node.getAttributeValue("aria-label")) !== null && _a !== void 0 ? _a : "";
    return Boolean(value.trim());
}
function isLabelledby(node, context) {
    const { document, reference } = context;
    /* if we already have resolved one level of reference we don't resolve another
     * level (as per accname step 2B) */
    if (reference) {
        return false;
    }
    const ariaLabelledby = node.ariaLabelledby;
    /* consider dynamic aria-labelledby as having a name as we cannot resolve it
     * so no way to prove correctness */
    if (ariaLabelledby instanceof DynamicValue) {
        return true;
    }
    /* ignore elements without aria-labelledby */
    if (ariaLabelledby === null) {
        return false;
    }
    return ariaLabelledby.some((id) => {
        const selector = generateIdSelector(id);
        return document.querySelectorAll(selector).some((child) => {
            return hasAccessibleNameImpl(child, {
                document,
                reference: child,
            });
        });
    });
}
/**
 * This algorithm is based on ["Accessible Name and Description Computation
 * 1.2"][accname] with some exceptions:
 *
 * It doesn't compute the actual name but only the presence of one, e.g. if a
 * non-empty flat string is present the algorithm terminates with a positive
 * result.
 *
 * It takes some optimization shortcuts such as starting with step F as it
 * would be more common usage and as there is no actual name being computed
 * the order wont matter.
 *
 * [accname]: https://w3c.github.io/accname
 */
function hasAccessibleNameImpl(current, context) {
    const { reference } = context;
    /* if this element is hidden (see function for exceptions) it does not have an accessible name */
    if (isHidden(current, context)) {
        return false;
    }
    /* special case: when this element is directly referenced by aria-labelledby
     * we ignore `hidden` */
    const ignoreHiddenRoot = Boolean(reference && reference.isSameNode(current));
    const text = classifyNodeText(current, { accessible: true, ignoreHiddenRoot });
    if (text !== exports.TextClassification.EMPTY_TEXT) {
        return true;
    }
    if (hasImgAltText(current, context)) {
        return true;
    }
    if (hasLabel(current)) {
        return true;
    }
    if (isLabelledby(current, context)) {
        return true;
    }
    return false;
}
/**
 * Returns `true` if the element has an accessible name.
 *
 * It does not yet consider if the elements role prohibits naming, e.g. a `<p>`
 * element will still show up as having an accessible name.
 *
 * @public
 * @param document - Document element.
 * @param current - The element to get accessible name for
 * @returns `true` if the element has an accessible name.
 */
function hasAccessibleName(document, current) {
    /* istanbul ignore next: we're not testing cache */
    if (current.cacheExists(HAS_ACCESSIBLE_TEXT_CACHE)) {
        return Boolean(current.cacheGet(HAS_ACCESSIBLE_TEXT_CACHE));
    }
    const result = hasAccessibleNameImpl(current, {
        document,
        reference: null,
    });
    return current.cacheSet(HAS_ACCESSIBLE_TEXT_CACHE, result);
}

function isIgnored(node) {
    var _a;
    if (node.is("input")) {
        const type = (_a = node.getAttributeValue("type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        const ignored = ["hidden", "submit", "reset", "button"];
        return Boolean(type && ignored.includes(type));
    }
    return false;
}
class InputMissingLabel extends Rule {
    documentation() {
        return {
            description: [
                "Each form element must have an a label or accessible name.",
                'Typically this is implemented using a `<label for="..">` element describing the purpose of the form element.',
                "",
                "This can be resolved in one of the following ways:",
                "",
                '  - Use an associated `<label for="..">` element.',
                "  - Use a nested `<label>` as parent element.",
                "  - Use `aria-label` or `aria-labelledby` attributes.",
            ].join("\n"),
            url: "https://html-validate.org/rules/input-missing-label.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const root = event.document;
            for (const elem of root.querySelectorAll("input, textarea, select")) {
                this.validateInput(root, elem);
            }
        });
    }
    validateInput(root, elem) {
        if (isHTMLHidden(elem) || isAriaHidden(elem)) {
            return;
        }
        /* hidden, submit, reset or button should not have label */
        if (isIgnored(elem)) {
            return;
        }
        if (hasAccessibleName(root, elem)) {
            return;
        }
        let label = [];
        /* try to find label by id */
        if ((label = findLabelById(root, elem.id)).length > 0) {
            this.validateLabel(root, elem, label);
            return;
        }
        /* try to find parent label (input nested in label) */
        if ((label = findLabelByParent(elem)).length > 0) {
            this.validateLabel(root, elem, label);
            return;
        }
        if (elem.hasAttribute("aria-label")) {
            this.report(elem, `<${elem.tagName}> element has aria-label but label has no text`);
        }
        else if (elem.hasAttribute("aria-labelledby")) {
            this.report(elem, `<${elem.tagName}> element has aria-labelledby but referenced element has no text`);
        }
        else {
            this.report(elem, `<${elem.tagName}> element does not have a <label>`);
        }
    }
    /**
     * Reports error if none of the labels are accessible.
     */
    validateLabel(root, elem, labels) {
        const visible = labels.filter(isVisible);
        if (visible.length === 0) {
            this.report(elem, `<${elem.tagName}> element has <label> but <label> element is hidden`);
            return;
        }
        if (!labels.some((label) => hasAccessibleName(root, label))) {
            this.report(elem, `<${elem.tagName}> element has <label> but <label> has no text`);
        }
    }
}
function isVisible(elem) {
    const hidden = isHTMLHidden(elem) || isAriaHidden(elem);
    return !hidden;
}
function findLabelById(root, id) {
    if (!id)
        return [];
    return root.querySelectorAll(`label[for="${id}"]`);
}
function findLabelByParent(el) {
    let cur = el.parent;
    while (cur) {
        if (cur.is("label")) {
            return [cur];
        }
        cur = cur.parent;
    }
    return [];
}

const defaults$f = {
    maxlength: 70,
};
class LongTitle extends Rule {
    constructor(options) {
        super({ ...defaults$f, ...options });
        this.maxlength = this.options.maxlength;
    }
    static schema() {
        return {
            maxlength: {
                type: "number",
            },
        };
    }
    documentation() {
        return {
            description: `Search engines truncates titles with long text, possibly down-ranking the page in the process.`,
            url: "https://html-validate.org/rules/long-title.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.previous;
            if (node.tagName !== "title")
                return;
            const text = node.textContent;
            if (text.length > this.maxlength) {
                this.report(node, `title text cannot be longer than ${this.maxlength} characters`);
            }
        });
    }
}

class MetaRefresh extends Rule {
    documentation() {
        return {
            description: `Meta refresh directive must use the \`0;url=...\` format. Non-zero values for time interval is disallowed as people with assistive technology might be unable to read and understand the page content before automatically reloading. For the same reason skipping the url is disallowed as it would put the browser in an infinite loop reloading the same page over and over again.`,
            url: "https://html-validate.org/rules/meta-refresh.html",
        };
    }
    setup() {
        this.on("element:ready", ({ target }) => {
            /* only handle <meta> */
            if (!target.is("meta")) {
                return;
            }
            /* only handle refresh */
            const httpEquiv = target.getAttributeValue("http-equiv");
            if (httpEquiv !== "refresh") {
                return;
            }
            /* ensure content attribute is set */
            const content = target.getAttribute("content");
            if (!(content === null || content === void 0 ? void 0 : content.value) || content.isDynamic) {
                return;
            }
            /* ensure content attribute is valid */
            const location = content.valueLocation;
            const value = parseContent(content.value.toString());
            if (!value) {
                this.report(target, "Malformed meta refresh directive", location);
                return;
            }
            /* ensure a url is set */
            if (!value.url) {
                this.report(target, "Don't use meta refresh to reload the page", location);
            }
            /* ensure delay is exactly 0 seconds */
            if (value.delay !== 0) {
                this.report(target, "Meta refresh must use 0 second delay", location);
            }
        });
    }
}
function parseContent(text) {
    const match = text.match(/^(\d+)(?:\s*;\s*url=(.*))?/);
    if (match) {
        return {
            delay: parseInt(match[1], 10),
            url: match[2],
        };
    }
    else {
        return null;
    }
}

function getName(attr) {
    const name = attr.value;
    if (!name || name instanceof DynamicValue) {
        return null;
    }
    return name;
}
class MapDupName extends Rule {
    documentation() {
        return {
            description: "`<map>` must have a unique name, it cannot be the same name as another `<map>` element",
            url: "https://html-validate.org/rules/map-dup-name.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            const maps = document.querySelectorAll("map[name]");
            const names = new Set();
            for (const map of maps) {
                const attr = map.getAttribute("name");
                /* istanbul ignore next -- should not happen as querySelector matches
                 * only the elements with the name attribute */
                if (!attr) {
                    continue;
                }
                const name = getName(attr);
                if (!name) {
                    continue;
                }
                if (names.has(name)) {
                    this.report({
                        node: map,
                        message: `<map> name must be unique`,
                        location: attr.keyLocation,
                    });
                }
                names.add(name);
            }
        });
    }
}

function isRelevant$3(event) {
    return event.target.is("map");
}
function hasStaticValue(attr) {
    return Boolean(attr && !(attr.value instanceof DynamicValue));
}
class MapIdName extends Rule {
    documentation() {
        return {
            description: "When the `id` attribute is present on a `<map>` element it must be equal to the `name` attribute.",
            url: "https://html-validate.org/rules/map-id-name.html",
        };
    }
    setup() {
        this.on("tag:ready", isRelevant$3, (event) => {
            var _a;
            const { target } = event;
            const id = target.getAttribute("id");
            const name = target.getAttribute("name");
            // /* ignore missing attributes or dynamic value */
            if (!hasStaticValue(id) || !hasStaticValue(name)) {
                return;
            }
            /* ignore when id and name is the same */
            if (id.value === name.value) {
                return;
            }
            this.report({
                node: event.target,
                message: `"id" and "name" attribute must be the same on <map> elements`,
                location: (_a = id.valueLocation) !== null && _a !== void 0 ? _a : name.valueLocation,
            });
        });
    }
}

class MissingDoctype extends Rule {
    documentation() {
        return {
            description: "Requires that the document contains a doctype.",
            url: "https://html-validate.org/rules/missing-doctype.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const dom = event.document;
            if (!dom.doctype) {
                this.report(dom.root, "Document is missing doctype");
            }
        });
    }
}

class MultipleLabeledControls extends Rule {
    constructor() {
        super(...arguments);
        this.labelable = "";
    }
    documentation() {
        return {
            description: `A \`<label>\` element can only be associated with one control at a time.`,
            url: "https://html-validate.org/rules/multiple-labeled-controls.html",
        };
    }
    setup() {
        this.labelable = this.getTagsWithProperty("labelable").join(",");
        this.on("element:ready", (event) => {
            const { target } = event;
            /* only handle <label> */
            if (target.tagName !== "label") {
                return;
            }
            /* no error if it references 0 or 1 controls */
            const numControls = this.getNumLabledControls(target);
            if (numControls <= 1) {
                return;
            }
            this.report(target, "<label> is associated with multiple controls", target.location);
        });
    }
    getNumLabledControls(src) {
        /* get all controls wrapped by label element */
        const controls = src.querySelectorAll(this.labelable).map((node) => node.id);
        /* only count wrapped controls if the "for" attribute is missing or static,
         * for dynamic "for" attributes it is better to run in document mode later */
        const attr = src.getAttribute("for");
        if (!attr || attr.isDynamic || !attr.value) {
            return controls.length;
        }
        /* if "for" attribute references a wrapped element it should not be counted
         * multiple times */
        const redundant = controls.includes(attr.value.toString());
        if (redundant) {
            return controls.length;
        }
        /* has "for" attribute pointing to element outside wrapped controls */
        return controls.length + 1;
    }
}

const defaults$e = {
    include: null,
    exclude: null,
};
class NoAutoplay extends Rule {
    constructor(options) {
        super({ ...defaults$e, ...options });
    }
    documentation(context) {
        return {
            description: [
                `The autoplay attribute is not allowed on <${context.tagName}>.`,
                "Autoplaying content can be disruptive for users and has accessibilty concerns.",
                "Prefer to let the user control playback.",
            ].join("\n"),
            url: "https://html-validate.org/rules/no-autoplay.html",
        };
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
        };
    }
    setup() {
        this.on("attr", (event) => {
            /* only handle autoplay attribute */
            if (event.key.toLowerCase() !== "autoplay") {
                return;
            }
            /* ignore dynamic values */
            if (event.value && event.value instanceof DynamicValue) {
                return;
            }
            /* ignore tagnames configured to be ignored */
            const tagName = event.target.tagName;
            if (this.isKeywordIgnored(tagName)) {
                return;
            }
            /* report error */
            const context = { tagName };
            const location = event.location;
            this.report(event.target, `The autoplay attribute is not allowed on <${tagName}>`, location, context);
        });
    }
}

class NoConditionalComment extends Rule {
    documentation() {
        return {
            description: "Microsoft Internet Explorer previously supported using special HTML comments (conditional comments) for targeting specific versions of IE but since IE 10 it is deprecated and not supported in standards mode.",
            url: "https://html-validate.org/rules/no-conditional-comment.html",
        };
    }
    setup() {
        this.on("conditional", (event) => {
            this.report(event.parent, "Use of conditional comments are deprecated", event.location);
        });
    }
}

class NoDeprecatedAttr extends Rule {
    documentation() {
        return {
            description: "HTML5 deprecated many old attributes.",
            url: "https://html-validate.org/rules/no-deprecated-attr.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            const node = event.target;
            const meta = node.meta;
            const attr = event.key.toLowerCase();
            /* cannot validate if meta isn't known */
            if (meta === null) {
                return;
            }
            const metaAttribute = meta.attributes[attr];
            if (!metaAttribute) {
                return;
            }
            const deprecated = metaAttribute.deprecated;
            if (deprecated) {
                this.report(node, `Attribute "${event.key}" is deprecated on <${node.tagName}> element`, event.keyLocation);
            }
        });
    }
}

class NoDupAttr extends Rule {
    documentation() {
        return {
            description: "HTML disallows two or more attributes with the same (case-insensitive) name.",
            url: "https://html-validate.org/rules/no-dup-attr.html",
        };
    }
    setup() {
        let attr = {};
        this.on("tag:start", () => {
            /* reset any time a new tag is opened */
            attr = {};
        });
        this.on("attr", (event) => {
            /* ignore dynamic attributes aliasing another, e.g class and ng-class */
            if (event.originalAttribute) {
                return;
            }
            const name = event.key.toLowerCase();
            if (name in attr) {
                this.report(event.target, `Attribute "${name}" duplicated`, event.keyLocation);
            }
            attr[event.key] = true;
        });
    }
}

class NoDupClass extends Rule {
    documentation() {
        return {
            description: "Prevents unnecessary duplication of class names.",
            url: "https://html-validate.org/rules/no-dup-class.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            if (event.key.toLowerCase() !== "class") {
                return;
            }
            const classes = new DOMTokenList(event.value, event.valueLocation);
            const unique = new Set();
            classes.forEach((cur, index) => {
                if (unique.has(cur)) {
                    const location = classes.location(index);
                    this.report(event.target, `Class "${cur}" duplicated`, location);
                }
                unique.add(cur);
            });
        });
    }
}

class NoDupID extends Rule {
    documentation() {
        return {
            description: "The ID of an element must be unique.",
            url: "https://html-validate.org/rules/no-dup-id.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            const existing = new Set();
            const elements = document.querySelectorAll("[id]");
            const relevant = elements.filter(isRelevant$2);
            for (const el of relevant) {
                const attr = el.getAttribute("id");
                /* istanbul ignore next: this has already been tested in isRelevant once but for type-safety it is checked again */
                if (!(attr === null || attr === void 0 ? void 0 : attr.value)) {
                    continue;
                }
                const id = attr.value.toString();
                if (existing.has(id)) {
                    this.report(el, `Duplicate ID "${id}"`, attr.valueLocation);
                }
                existing.add(id);
            }
        });
    }
}
function isRelevant$2(element) {
    const attr = element.getAttribute("id");
    /* istanbul ignore next: can not really happen as querySelector will only return elements with id present */
    if (!attr) {
        return false;
    }
    /* id without value is not relevant, e.g. <p id></p> */
    if (!attr.value) {
        return false;
    }
    /* dynamic id (interpolated or otherwise currently unknown value) is not relevant */
    if (attr.isDynamic) {
        return false;
    }
    return true;
}

function isRelevant$1(event) {
    return event.target.is("button");
}
class NoImplicitButtonType extends Rule {
    documentation() {
        return {
            description: [
                "`<button>` is missing required `type` attribute",
                "",
                "When the `type` attribute is omitted it defaults to `submit`.",
                "Submit buttons are triggered when a keyboard user presses <kbd>Enter</kbd>.",
                "",
                "As this may or may not be inteded this rule enforces that the `type` attribute be explicitly set to one of the valid types:",
                "",
                "- `button` - a generic button.",
                "- `submit` - a submit button.",
                "- `reset`- a button to reset form fields.",
            ].join("\n"),
            url: "https://html-validate.org/rules/no-implicit-button-type.html",
        };
    }
    setup() {
        this.on("element:ready", isRelevant$1, (event) => {
            const { target } = event;
            const attr = target.getAttribute("type");
            if (!attr) {
                this.report({
                    node: event.target,
                    message: `<button> is missing required "type" attribute`,
                });
            }
        });
    }
}

class NoImplicitClose extends Rule {
    documentation() {
        return {
            description: `Some elements in HTML has optional end tags. When an optional tag is omitted a browser must handle it as if the end tag was present.

Omitted end tags can be ambigious for humans to read and many editors have trouble formatting the markup.`,
            url: "https://html-validate.org/rules/no-implicit-close.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const closed = event.previous;
            const by = event.target;
            /* not set when unclosed elements are being closed by tree, this rule does
             * not consider such events (handled by close-order instead) */
            if (!by) {
                return;
            }
            if (closed.closed !== exports.NodeClosed.ImplicitClosed) {
                return;
            }
            const closedByParent = closed.parent && closed.parent.tagName === by.tagName; /* <ul><li></ul> */
            const sameTag = closed.tagName === by.tagName; /* <p>foo<p>bar */
            if (closedByParent) {
                this.report(closed, `Element <${closed.tagName}> is implicitly closed by parent </${by.tagName}>`, closed.location);
            }
            else if (sameTag) {
                this.report(closed, `Element <${closed.tagName}> is implicitly closed by sibling`, closed.location);
            }
            else {
                this.report(closed, `Element <${closed.tagName}> is implicitly closed by adjacent <${by.tagName}>`, closed.location);
            }
        });
    }
}

const defaults$d = {
    include: null,
    exclude: null,
    allowedProperties: ["display"],
};
class NoInlineStyle extends Rule {
    constructor(options) {
        super({ ...defaults$d, ...options });
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            allowedProperties: {
                items: {
                    type: "string",
                },
                type: "array",
            },
        };
    }
    documentation() {
        const text = [
            "Inline style is not allowed.\n",
            "Inline style is a sign of unstructured CSS. Use class or ID with a separate stylesheet.\n",
        ];
        if (this.options.allowedProperties.length > 0) {
            text.push("Under the current configuration the following CSS properties are allowed:\n");
            text.push(this.options.allowedProperties.map((it) => `- \`${it}\``).join("\n"));
        }
        return {
            description: text.join("\n"),
            url: "https://html-validate.org/rules/no-inline-style.html",
        };
    }
    setup() {
        this.on("attr", (event) => this.isRelevant(event), (event) => {
            const { value } = event;
            if (this.allPropertiesAllowed(value)) {
                return;
            }
            this.report(event.target, "Inline style is not allowed");
        });
    }
    isRelevant(event) {
        var _a;
        if (event.key !== "style") {
            return false;
        }
        const { include, exclude } = this.options;
        const key = (_a = event.originalAttribute) !== null && _a !== void 0 ? _a : event.key;
        /* ignore attributes not present in "include" */
        if (include && !include.includes(key)) {
            return false;
        }
        /* ignore attributes present in "exclude" */
        if (exclude && exclude.includes(key)) {
            return false;
        }
        return true;
    }
    allPropertiesAllowed(value) {
        const allowProperties = this.options.allowedProperties;
        /* quick path: no properties are allowed, no need to check each one individually */
        if (allowProperties.length === 0) {
            return false;
        }
        const declarations = Object.keys(parseCssDeclaration(value));
        return (declarations.length > 0 &&
            declarations.every((it) => {
                return allowProperties.includes(it);
            }));
    }
}

const ARIA = [
    { property: "aria-activedescendant", isList: false },
    { property: "aria-controls", isList: true },
    { property: "aria-describedby", isList: true },
    { property: "aria-details", isList: false },
    { property: "aria-errormessage", isList: false },
    { property: "aria-flowto", isList: true },
    { property: "aria-labelledby", isList: true },
    { property: "aria-owns", isList: true },
];
function idMissing(document, id) {
    const nodes = document.querySelectorAll(`[id="${id}"]`);
    return nodes.length === 0;
}
class NoMissingReferences extends Rule {
    documentation(context) {
        return {
            description: `The element ID "${context.value}" referenced by the ${context.key} attribute must point to an existing element.`,
            url: "https://html-validate.org/rules/no-missing-references.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const document = event.document;
            /* verify <label for=".."> */
            for (const node of document.querySelectorAll("label[for]")) {
                const attr = node.getAttribute("for");
                this.validateReference(document, node, attr, false);
            }
            /* verify <input list=".."> */
            for (const node of document.querySelectorAll("input[list]")) {
                const attr = node.getAttribute("list");
                this.validateReference(document, node, attr, false);
            }
            /* verify WAI-ARIA properties */
            for (const { property, isList } of ARIA) {
                for (const node of document.querySelectorAll(`[${property}]`)) {
                    const attr = node.getAttribute(property);
                    this.validateReference(document, node, attr, isList);
                }
            }
        });
    }
    validateReference(document, node, attr, isList) {
        /* sanity check: querySelector should never return elements without the attribute */
        /* istanbul ignore next */
        if (!attr) {
            return;
        }
        /* skip dynamic and empty values */
        const value = attr.value;
        if (value instanceof DynamicValue || value === null || value === "") {
            return;
        }
        if (isList) {
            this.validateList(document, node, attr, value);
        }
        else {
            this.validateSingle(document, node, attr, value);
        }
    }
    validateSingle(document, node, attr, id) {
        if (idMissing(document, id)) {
            const context = { key: attr.key, value: id };
            this.report(node, `Element references missing id "${id}"`, attr.valueLocation, context);
        }
    }
    validateList(document, node, attr, values) {
        const parsed = new DOMTokenList(values, attr.valueLocation);
        for (const entry of parsed.iterator()) {
            const id = entry.item;
            if (idMissing(document, id)) {
                const context = { key: attr.key, value: id };
                this.report(node, `Element references missing id "${id}"`, entry.location, context);
            }
        }
    }
}

class NoMultipleMain extends Rule {
    documentation() {
        return {
            description: [
                "Only a single visible `<main>` element can be present at in a document at a time.",
                "",
                "Multiple `<main>` can be present in the DOM as long the others are hidden using the HTML5 `hidden` attribute.",
            ].join("\n"),
            url: "https://html-validate.org/rules/no-multiple-main.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            const main = document.querySelectorAll("main").filter((cur) => !cur.hasAttribute("hidden"));
            main.shift(); /* ignore the first occurrence */
            /* report all other occurrences */
            for (const elem of main) {
                this.report(elem, "Multiple <main> elements present in document");
            }
        });
    }
}

const defaults$c = {
    relaxed: false,
};
const textRegexp = /([<>]|&(?![a-zA-Z0-9#]+;))/g;
const unquotedAttrRegexp = /([<>"'=`]|&(?![a-zA-Z0-9#]+;))/g;
const matchTemplate = /^(<%.*?%>|<\?.*?\?>|<\$.*?\$>)$/s;
const replacementTable = {
    '"': "&quot;",
    "&": "&amp;",
    "'": "&apos;",
    "<": "&lt;",
    "=": "&equals;",
    ">": "&gt;",
    "`": "&grave;",
};
class NoRawCharacters extends Rule {
    constructor(options) {
        super({ ...defaults$c, ...options });
        this.relaxed = this.options.relaxed;
    }
    static schema() {
        return {
            relaxed: {
                type: "boolean",
            },
        };
    }
    documentation() {
        return {
            description: `Some characters such as \`<\`, \`>\` and \`&\` hold special meaning in HTML and must be escaped using a character reference (html entity).`,
            url: "https://html-validate.org/rules/no-raw-characters.html",
        };
    }
    setup() {
        this.on("element:ready", (event) => {
            const node = event.target;
            /* only iterate over direct descendants */
            for (const child of node.childNodes) {
                if (child.nodeType !== exports.NodeType.TEXT_NODE) {
                    continue;
                }
                /* workaround for templating <% ... %> etc */
                if (child.textContent.match(matchTemplate)) {
                    continue;
                }
                this.findRawChars(node, child.textContent, child.location, textRegexp);
            }
        });
        this.on("attr", (event) => {
            /* boolean attributes has no value so nothing to validate */
            if (!event.value) {
                return;
            }
            /* quoted attribute values can contain most symbols except the quotemark
             * itself but unescaped quotemarks would cause a parsing error */
            if (event.quote) {
                return;
            }
            this.findRawChars(event.target, event.value.toString(), event.valueLocation, // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation is always set if a value is provided
            unquotedAttrRegexp);
        });
    }
    /**
     * Find raw special characters and report as errors.
     *
     * @param text - The full text to find unescaped raw characters in.
     * @param location - Location of text.
     * @param regexp - Regexp pattern to match using.
     */
    findRawChars(node, text, location, regexp) {
        let match;
        do {
            match = regexp.exec(text);
            if (match) {
                const char = match[0];
                /* In relaxed mode & only needs to be encoded if it is ambiguous,
                 * however this rule will only match either non-ambiguous ampersands or
                 * ampersands part of a character reference. Whenever it is a valid
                 * character reference or not not checked by this rule */
                if (this.relaxed && char === "&") {
                    continue;
                }
                /* determine replacement character and location */
                const replacement = replacementTable[char];
                const charLocation = sliceLocation(location, match.index, match.index + 1);
                /* report as error */
                this.report(node, `Raw "${char}" must be encoded as "${replacement}"`, charLocation);
            }
        } while (match);
    }
}

const selectors = ["input[aria-label]", "textarea[aria-label]", "select[aria-label]"];
class NoRedundantAriaLabel extends Rule {
    documentation() {
        return {
            description: "`aria-label` is redundant when an associated `<label>` element containing the same text exists.",
            url: "https://html-validate.org/rules/no-redundant-aria-label.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            const elements = document.querySelectorAll(selectors.join(","));
            for (const element of elements) {
                const ariaLabel = element.getAttribute("aria-label");
                const id = element.id;
                if (!id) {
                    continue;
                }
                const label = document.querySelector(`label[for="${id}"]`);
                if (!ariaLabel || !label || label.textContent.trim() !== ariaLabel.value) {
                    continue;
                }
                const message = "aria-label is redundant when label containing same text exists";
                this.report({
                    message,
                    node: element,
                    location: ariaLabel.keyLocation,
                });
            }
        });
    }
}

class NoRedundantFor extends Rule {
    documentation() {
        return {
            description: `When the \`<label>\` element wraps the labelable control the \`for\` attribute is redundant and better left out.`,
            url: "https://html-validate.org/rules/no-redundant-for.html",
        };
    }
    setup() {
        this.on("element:ready", (event) => {
            const { target } = event;
            /* only handle <label> */
            if (target.tagName !== "label") {
                return;
            }
            /* ignore label without for or dynamic value */
            const attr = target.getAttribute("for");
            if (!attr || attr.isDynamic) {
                return;
            }
            /* ignore omitted/empty values */
            const id = attr.value;
            if (!id) {
                return;
            }
            /* try to find labeled control */
            const escaped = escapeSelectorComponent(id);
            const control = target.querySelector(`[id="${escaped}"]`);
            if (!control) {
                return;
            }
            this.report(target, 'Redundant "for" attribute', attr.keyLocation);
        });
    }
}

class NoRedundantRole extends Rule {
    documentation(context) {
        const { role, tagName } = context;
        return {
            description: `Using the \`${role}\` role is redundant as it is already implied by the \`<${tagName}>\` element.`,
            url: "https://html-validate.org/rules/no-redundant-role.html",
        };
    }
    setup() {
        this.on("tag:ready", (event) => {
            const { target } = event;
            const role = target.getAttribute("role");
            /* ignore missing and dynamic values */
            if (!(role === null || role === void 0 ? void 0 : role.value) || role.value instanceof DynamicValue) {
                return;
            }
            /* ignore elements without metadata */
            const { meta } = target;
            if (!meta) {
                return;
            }
            /* ignore elements without implicit role */
            const implicitRole = meta.implicitRole(target._adapter);
            if (!implicitRole) {
                return;
            }
            /* ignore elements with non-redundant roles */
            if (role.value !== implicitRole) {
                return;
            }
            /* report error */
            const context = {
                tagName: target.tagName,
                role: role.value,
            };
            this.report(event.target, `Redundant role "${role.value}" on <${target.tagName}>`, role.valueLocation, context);
        });
    }
}

const xmlns = /^(.+):.+$/;
const defaults$b = {
    ignoreForeign: true,
    ignoreXML: true,
};
class NoSelfClosing extends Rule {
    constructor(options) {
        super({ ...defaults$b, ...options });
    }
    static schema() {
        return {
            ignoreForeign: {
                type: "boolean",
            },
            ignoreXML: {
                type: "boolean",
            },
        };
    }
    documentation(tagName) {
        tagName = tagName || "element";
        return {
            description: `Self-closing elements are disallowed. Use regular end tag <${tagName}></${tagName}> instead of self-closing <${tagName}/>.`,
            url: "https://html-validate.org/rules/no-self-closing.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const active = event.previous; // The current active element (that is, the current element on the stack)
            if (!isRelevant(active, this.options)) {
                return;
            }
            this.validateElement(active);
        });
    }
    validateElement(node) {
        if (node.closed !== exports.NodeClosed.VoidSelfClosed) {
            return;
        }
        this.report(node, `<${node.tagName}> must not be self-closed`, null, node.tagName);
    }
}
function isRelevant(node, options) {
    /* tags in XML namespaces are relevant only if ignoreXml is false, in which
     * case assume all xml elements must not be self-closed */
    if (node.tagName.match(xmlns)) {
        return !options.ignoreXML;
    }
    /* nodes with missing metadata is assumed relevant */
    if (!node.meta) {
        return true;
    }
    if (node.meta.void) {
        return false;
    }
    /* foreign elements are relevant only if ignoreForeign is false, in which case
     * assume all foreign must not be self-closed */
    if (node.meta.foreign) {
        return !options.ignoreForeign;
    }
    return true;
}

class NoStyleTag extends Rule {
    documentation() {
        return {
            description: "Prefer to use external stylesheets with the `<link>` tag instead of inlining the styling.",
            url: "https://html-validate.org/rules/no-style-tag.html",
        };
    }
    setup() {
        this.on("tag:start", (event) => {
            const node = event.target;
            if (node.tagName === "style") {
                this.report(node, "Use external stylesheet with <link> instead of <style> tag");
            }
        });
    }
}

class NoTrailingWhitespace extends Rule {
    documentation() {
        return {
            description: "Lines with trailing whitespace cause unnessecary diff when using version control and usually serve no special purpose in HTML.",
            url: "https://html-validate.org/rules/no-trailing-whitespace.html",
        };
    }
    setup() {
        this.on("whitespace", (event) => {
            if (event.text.match(/^[ \t]+\r?\n$/)) {
                this.report(null, "Trailing whitespace", event.location);
            }
        });
    }
}

const defaults$a = {
    include: null,
    exclude: null,
};
class NoUnknownElements extends Rule {
    constructor(options) {
        super({ ...defaults$a, ...options });
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
        };
    }
    documentation(context) {
        const element = context ? ` <${context}>` : "";
        return {
            description: `An unknown element${element} was used. If this is a Custom Element you need to supply element metadata for it.`,
            url: "https://html-validate.org/rules/no-unknown-elements.html",
        };
    }
    setup() {
        this.on("tag:start", (event) => {
            const node = event.target;
            if (node.meta) {
                return;
            }
            if (this.isKeywordIgnored(node.tagName, keywordPatternMatcher)) {
                return;
            }
            this.report(node, `Unknown element <${node.tagName}>`, null, node.tagName);
        });
    }
}

class NoUnusedDisable extends Rule {
    documentation(context) {
        return {
            description: `\`${context.ruleId}\` rule is disabled but no error was reported.`,
            url: "https://html-validate.org/rules/no-unused-disable.html",
        };
    }
    setup() {
        /* this is a special rule, the `Engine` class directly emits errors on this
         * rule, it exists only to be able to configure whenever the rule is enabled
         * or not and to get the regular documentation and contextual help. */
    }
    reportUnused(unused, options, location) {
        const tokens = new DOMTokenList(options.replace(/,/g, " "), location);
        for (const ruleId of unused) {
            const index = tokens.indexOf(ruleId);
            /* istanbul ignore next: the token should be present or it wouldn't be
             * reported as unused, this is just a sanity check and fallback */
            const tokenLocation = index >= 0 ? tokens.location(index) : location;
            this.report({
                node: null,
                message: '"{{ ruleId }}" rule is disabled but no error was reported',
                location: tokenLocation,
                context: {
                    ruleId,
                },
            });
        }
    }
}

class NoUtf8Bom extends Rule {
    documentation() {
        return {
            description: `This file is saved with the UTF-8 byte order mark (BOM) present. It is neither required or recommended to use.\n\nInstead the document should be served with the \`Content-Type: application/javascript; charset=utf-8\` header.`,
            url: "https://html-validate.org/rules/no-utf8-bom.html",
        };
    }
    setup() {
        const unregister = this.on("token", (event) => {
            if (event.type === TokenType.UNICODE_BOM) {
                this.report(null, "File should be saved without UTF-8 BOM", event.location);
            }
            /* since the BOM must be the very first thing the rule can now be disabled for the rest of the run */
            this.setEnabled(false);
            unregister();
        });
    }
}

const types = ["button", "submit", "reset", "image"];
const replacement = {
    button: '<button type="button">',
    submit: '<button type="submit">',
    reset: '<button type="reset">',
    image: '<button type="button">',
};
const defaults$9 = {
    include: null,
    exclude: null,
};
class PreferButton extends Rule {
    constructor(options) {
        super({ ...defaults$9, ...options });
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
        };
    }
    documentation(context) {
        const src = `<input type="${context.type}">`;
        const dst = replacement[context.type] || `<button>`;
        return {
            description: `Prefer to use \`${dst}\` instead of \`"${src}\`.`,
            url: "https://html-validate.org/rules/prefer-button.html",
        };
    }
    setup() {
        this.on("attr", (event) => {
            const node = event.target;
            /* only handle input elements */
            if (node.tagName.toLowerCase() !== "input") {
                return;
            }
            /* only handle type attribute */
            if (event.key.toLowerCase() !== "type") {
                return;
            }
            /* sanity check: handle missing, boolean and dynamic attributes */
            if (!event.value || event.value instanceof DynamicValue) {
                return;
            }
            /* ignore types configured to be ignored */
            const type = event.value.toLowerCase();
            if (this.isKeywordIgnored(type)) {
                return;
            }
            /* only values matching known type triggers error */
            if (!types.includes(type)) {
                return;
            }
            const context = { type };
            const message = `Prefer to use <button> instead of <input type="${type}"> when adding buttons`;
            this.report(node, message, event.valueLocation, context);
        });
    }
}

const defaults$8 = {
    mapping: {
        article: "article",
        banner: "header",
        button: "button",
        cell: "td",
        checkbox: "input",
        complementary: "aside",
        contentinfo: "footer",
        figure: "figure",
        form: "form",
        heading: "hN",
        input: "input",
        link: "a",
        list: "ul",
        listbox: "select",
        listitem: "li",
        main: "main",
        navigation: "nav",
        progressbar: "progress",
        radio: "input",
        region: "section",
        table: "table",
        textbox: "textarea",
    },
    include: null,
    exclude: null,
};
class PreferNativeElement extends Rule {
    constructor(options) {
        super({ ...defaults$8, ...options });
    }
    static schema() {
        return {
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            mapping: {
                type: "object",
            },
        };
    }
    documentation(context) {
        return {
            description: `Instead of using the WAI-ARIA role "${context.role}" prefer to use the native <${context.replacement}> element.`,
            url: "https://html-validate.org/rules/prefer-native-element.html",
        };
    }
    setup() {
        const { mapping } = this.options;
        this.on("attr", (event) => {
            /* ignore non-role attributes */
            if (event.key.toLowerCase() !== "role") {
                return;
            }
            /* ignore missing and dynamic values */
            if (!event.value || event.value instanceof DynamicValue) {
                return;
            }
            /* ignore roles configured to be ignored */
            const role = event.value.toLowerCase();
            if (this.isIgnored(role)) {
                return;
            }
            /* dont report when the element is already of the right type but has a
             * redundant role, such as <main role="main"> */
            const replacement = mapping[role];
            if (event.target.is(replacement)) {
                return;
            }
            /* report error */
            const context = { role, replacement };
            const location = this.getLocation(event);
            this.report(event.target, `Prefer to use the native <${replacement}> element`, location, context);
        });
    }
    isIgnored(role) {
        const { mapping } = this.options;
        /* ignore roles not mapped to native elements */
        const replacement = mapping[role];
        if (!replacement) {
            return true;
        }
        return this.isKeywordIgnored(role);
    }
    getLocation(event) {
        const begin = event.location;
        const end = event.valueLocation; // eslint-disable-line @typescript-eslint/no-non-null-assertion -- technical debt, valueLocation will always be set when a value is provided
        const quote = event.quote ? 1 : 0;
        const size = end.offset + end.size - begin.offset + quote;
        return {
            filename: begin.filename,
            line: begin.line,
            column: begin.column,
            offset: begin.offset,
            size,
        };
    }
}

class PreferTbody extends Rule {
    documentation() {
        return {
            description: `While \`<tbody>\` is optional is relays semantic information about its contents. Where applicable it should also be combined with \`<thead>\` and \`<tfoot>\`.`,
            url: "https://html-validate.org/rules/prefer-tbody.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const doc = event.document;
            for (const table of doc.querySelectorAll("table")) {
                if (table.querySelector("> tbody")) {
                    continue;
                }
                const tr = table.querySelectorAll("> tr");
                if (tr.length >= 1) {
                    this.report(tr[0], "Prefer to wrap <tr> elements in <tbody>");
                }
            }
        });
    }
}

const defaults$7 = {
    tags: ["script", "style"],
};
class RequireCSPNonce extends Rule {
    constructor(options) {
        super({ ...defaults$7, ...options });
    }
    static schema() {
        return {
            tags: {
                type: "array",
                items: {
                    enum: ["script", "style"],
                    type: "string",
                },
            },
        };
    }
    documentation() {
        return {
            description: [
                "Required Content-Security-Policy (CSP) nonce is missing or empty.",
                "",
                "This is set by the `nonce` attribute and must match the `Content-Security-Policy` header.",
                "For instance, if the header contains `script-src 'nonce-r4nd0m'` the `nonce` attribute must be set to `nonce=\"r4nd0m\">`",
                "",
                "The nonce should be unique per each request and set to a cryptography secure random token.",
                "It is used to prevent cross site scripting (XSS) by preventing malicious actors from injecting scripts onto the page.",
            ].join("\n"),
            url: "https://html-validate.org/rules/require-csp-nonce.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            var _a;
            const { tags } = this.options;
            const node = event.previous;
            /* ignore other tags */
            if (!tags.includes(node.tagName)) {
                return;
            }
            /* ignore if nonce is set to non-empty value (or dynamic) */
            const nonce = (_a = node.getAttribute("nonce")) === null || _a === void 0 ? void 0 : _a.value;
            if (nonce && nonce !== "") {
                return;
            }
            /* ignore <script src> */
            if (node.is("script") && node.hasAttribute("src")) {
                return;
            }
            const message = `required CSP nonce is missing`;
            this.report(node, message, node.location);
        });
    }
}

const defaults$6 = {
    target: "all",
    include: null,
    exclude: null,
};
const crossorigin = new RegExp("^(\\w+://|//)"); /* e.g. https:// or // */
const supportSri = {
    link: "href",
    script: "src",
};
class RequireSri extends Rule {
    constructor(options) {
        super({ ...defaults$6, ...options });
        this.target = this.options.target;
    }
    static schema() {
        return {
            target: {
                enum: ["all", "crossorigin"],
                type: "string",
            },
            include: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
            exclude: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "null",
                    },
                ],
            },
        };
    }
    documentation() {
        return {
            description: `Subresource Integrity (SRI) \`integrity\` attribute is required to prevent manipulation from Content Delivery Networks or other third-party hosting.`,
            url: "https://html-validate.org/rules/require-sri.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            /* only handle thats supporting and requires sri */
            const node = event.previous;
            if (!(this.supportSri(node) && this.needSri(node))) {
                return;
            }
            /* check if sri attribute is present */
            if (node.hasAttribute("integrity")) {
                return;
            }
            this.report(node, `SRI "integrity" attribute is required on <${node.tagName}> element`, node.location);
        });
    }
    supportSri(node) {
        return Object.keys(supportSri).includes(node.tagName);
    }
    needSri(node) {
        const attr = this.elementSourceAttr(node);
        if (!attr) {
            return false;
        }
        if (attr.value === null || attr.value === "" || attr.isDynamic) {
            return false;
        }
        const url = attr.value.toString();
        if (this.target === "all" || crossorigin.test(url)) {
            return !this.isIgnored(url);
        }
        return false;
    }
    elementSourceAttr(node) {
        const key = supportSri[node.tagName];
        return node.getAttribute(key);
    }
    isIgnored(url) {
        return this.isKeywordIgnored(url, (list, it) => {
            return list.some((pattern) => it.includes(pattern));
        });
    }
}

class ScriptElement extends Rule {
    documentation() {
        return {
            description: "The end tag for `<script>` is a hard requirement and must never be omitted even when using the `src` attribute.",
            url: "https://html-validate.org/rules/script-element.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.target; // The current element being closed.
            if (!node || node.tagName !== "script") {
                return;
            }
            if (node.closed !== exports.NodeClosed.EndTag) {
                this.report(node, `End tag for <${node.tagName}> must not be omitted`);
            }
        });
    }
}

const javascript = [
    "",
    "application/ecmascript",
    "application/javascript",
    "text/ecmascript",
    "text/javascript",
];
class ScriptType extends Rule {
    documentation() {
        return {
            description: "While valid the HTML5 standard encourages authors to omit the type element for JavaScript resources.",
            url: "https://html-validate.org/rules/script-type.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.previous;
            if (node.tagName !== "script") {
                return;
            }
            const attr = node.getAttribute("type");
            if (!attr || attr.isDynamic) {
                return;
            }
            const value = attr.value ? attr.value.toString() : "";
            if (!this.isJavascript(value)) {
                return;
            }
            this.report(node, '"type" attribute is unnecessary for javascript resources', attr.keyLocation);
        });
    }
    isJavascript(mime) {
        /* remove mime parameters, e.g. ";charset=utf-8" */
        const type = mime.replace(/;.*/, "");
        return javascript.includes(type);
    }
}

class SvgFocusable extends Rule {
    documentation() {
        return {
            description: `Inline SVG elements in IE are focusable by default which may cause issues with tab-ordering. The \`focusable\` attribute should explicitly be set to avoid unintended behaviour.`,
            url: "https://html-validate.org/rules/svg-focusable.html",
        };
    }
    setup() {
        this.on("element:ready", (event) => {
            if (event.target.is("svg")) {
                this.validate(event.target);
            }
        });
    }
    validate(svg) {
        if (svg.hasAttribute("focusable")) {
            return;
        }
        this.report(svg, `<${svg.tagName}> is missing required "focusable" attribute`);
    }
}

const defaults$5 = {
    characters: [
        { pattern: " ", replacement: "&nbsp;", description: "non-breaking space" },
        { pattern: "-", replacement: "&#8209;", description: "non-breaking hyphen" },
    ],
    ignoreClasses: [],
    ignoreStyle: true,
};
function constructRegex(characters) {
    const disallowed = characters
        .map((it) => {
        return it.pattern;
    })
        .join("|");
    const pattern = `(${disallowed})`;
    /* eslint-disable-next-line security/detect-non-literal-regexp -- technical debt, should do more input sanitation */
    return new RegExp(pattern, "g");
}
function getText(node) {
    /* eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- this will always match something, it cannot be null */
    const match = node.textContent.match(/^(\s*)(.*)$/);
    const [, leading, text] = match;
    return [leading.length, text.trimEnd()];
}
/**
 * Node 12 does not support String.matchAll, this simulates it's behavior.
 */
function matchAll(text, regexp) {
    /* eslint-disable-next-line security/detect-non-literal-regexp -- makes copy of existing one only */
    const copy = new RegExp(regexp);
    const matches = [];
    let match;
    while ((match = copy.exec(text))) {
        matches.push(match);
    }
    return matches;
}
class TelNonBreaking extends Rule {
    constructor(options) {
        super({ ...defaults$5, ...options });
        this.regex = constructRegex(this.options.characters);
    }
    static schema() {
        return {
            characters: {
                type: "array",
                items: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        pattern: {
                            type: "string",
                        },
                        replacement: {
                            type: "string",
                        },
                        description: {
                            type: "string",
                        },
                    },
                },
            },
            ignoreClasses: {
                type: "array",
                items: {
                    type: "string",
                },
            },
            ignoreStyle: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        const { characters } = this.options;
        const replacements = characters.map((it) => {
            return `  - \`${it.pattern}\` - replace with \`${it.replacement}\` (${it.description}).`;
        });
        return {
            description: [
                `The \`${context.pattern}\` character should be replaced with \`${context.replacement}\` character (${context.description}) when used in a telephone number.`,
                "",
                "Unless non-breaking characters is used there could be a line break inserted at that character.",
                "Line breaks make is harder to read and understand the telephone number.",
                "",
                "The following characters should be avoided:",
                "",
                ...replacements,
            ].join("\n"),
            url: "https://html-validate.org/rules/tel-non-breaking.html",
        };
    }
    setup() {
        this.on("element:ready", this.isRelevant, (event) => {
            const { target } = event;
            if (this.isIgnored(target)) {
                return;
            }
            this.walk(target, target);
        });
    }
    isRelevant(event) {
        const { target } = event;
        /* should only deal with anchors */
        if (!target.is("a")) {
            return false;
        }
        /* ignore if anchor does not have tel href */
        const attr = target.getAttribute("href");
        if (!attr || !attr.valueMatches(/^tel:/, false)) {
            return false;
        }
        return true;
    }
    isIgnoredClass(node) {
        const { ignoreClasses } = this.options;
        const { classList } = node;
        return ignoreClasses.some((it) => classList.contains(it));
    }
    isIgnoredStyle(node) {
        const { ignoreStyle } = this.options;
        const { style } = node;
        if (!ignoreStyle) {
            return false;
        }
        if (style["white-space"] === "nowrap" || style["white-space"] === "pre") {
            return true;
        }
        return false;
    }
    isIgnored(node) {
        return this.isIgnoredClass(node) || this.isIgnoredStyle(node);
    }
    walk(anchor, node) {
        for (const child of node.childNodes) {
            if (isTextNode(child)) {
                this.detectDisallowed(anchor, child);
            }
            else if (isElementNode(child)) {
                this.walk(anchor, child);
            }
        }
    }
    detectDisallowed(anchor, node) {
        const [offset, text] = getText(node);
        const matches = matchAll(text, this.regex);
        for (const match of matches) {
            const detected = match[0];
            const entry = this.options.characters.find((it) => it.pattern === detected);
            /* istanbul ignore next: should never happen and cannot be tested, just a sanity check */
            if (!entry) {
                throw new Error(`Failed to find entry for "${detected}" when searching text "${text}"`);
            }
            const message = `"${detected}" should be replaced with "${entry.replacement}" (${entry.description}) in telephone number`;
            const begin = offset + match.index;
            const end = begin + detected.length;
            const location = sliceLocation(node.location, begin, end);
            const context = entry;
            this.report(anchor, message, location, context);
        }
    }
}

/**
 * Check if attribute is present and non-empty or dynamic.
 */
function hasNonEmptyAttribute(node, key) {
    const attr = node.getAttribute(key);
    return Boolean(attr && attr.valueMatches(/.+/, true));
}
/**
 * Check if element has default text.
 *
 * Only <input type="submit"> and <input type="reset"> at the moment.
 */
function hasDefaultText(node) {
    /* only input element have default text */
    if (!node.is("input")) {
        return false;
    }
    /* default text is not available if value attribute is present */
    if (node.hasAttribute("value")) {
        return false;
    }
    /* default text is only present when type is submit or reset */
    const type = node.getAttribute("type");
    return Boolean(type && type.valueMatches(/submit|reset/, false));
}
function isNonEmptyText(node) {
    if (isTextNode(node)) {
        return node.isDynamic || node.textContent.trim() !== "";
    }
    else {
        return false;
    }
}
/**
 * Walk nodes (depth-first, preorder) searching for accessible text. Children
 * hidden from accessibility tree are ignored.
 *
 * For each node the current conditions satisfies as accessible text:
 *
 * - Non-empty or dynamic `aria-label`
 * - Non-empty or dynamic `aria-labelledby` (reference not validated, use [[no-missing-references]]
 * - Image with non-empty or dynamic `alt` text
 * - Elements with default text
 */
function haveAccessibleText(node) {
    if (!inAccessibilityTree(node)) {
        return false;
    }
    /* check direct descendants for non-empty or dynamic text */
    const haveText = node.childNodes.some((child) => isNonEmptyText(child));
    if (haveText) {
        return true;
    }
    if (hasNonEmptyAttribute(node, "aria-label")) {
        return true;
    }
    if (hasNonEmptyAttribute(node, "aria-labelledby")) {
        return true;
    }
    if (node.is("img") && hasNonEmptyAttribute(node, "alt")) {
        return true;
    }
    if (hasDefaultText(node)) {
        return true;
    }
    return node.childElements.some((child) => {
        return haveAccessibleText(child);
    });
}
class TextContent extends Rule {
    documentation(context) {
        const doc = {
            description: `The textual content for this element is not valid.`,
            url: "https://html-validate.org/rules/text-content.html",
        };
        switch (context.textContent) {
            case exports.TextContent.NONE:
                doc.description = `The \`<${context.tagName}>\` element must not have textual content.`;
                break;
            case exports.TextContent.REQUIRED:
                doc.description = `The \`<${context.tagName}>\` element must have textual content.`;
                break;
            case exports.TextContent.ACCESSIBLE:
                doc.description = `The \`<${context.tagName}>\` element must have accessible text.`;
                break;
        }
        return doc;
    }
    static filter(event) {
        const { target } = event;
        /* skip elements without metadata */
        if (!target.meta) {
            return false;
        }
        /* skip elements without explicit and default textContent */
        const { textContent } = target.meta;
        if (!textContent || textContent === exports.TextContent.DEFAULT) {
            return false;
        }
        return true;
    }
    setup() {
        this.on("element:ready", TextContent.filter, (event) => {
            const target = event.target;
            const { textContent } = target.meta;
            switch (textContent) {
                case exports.TextContent.NONE:
                    this.validateNone(target);
                    break;
                case exports.TextContent.REQUIRED:
                    this.validateRequired(target);
                    break;
                case exports.TextContent.ACCESSIBLE:
                    this.validateAccessible(target);
                    break;
            }
        });
    }
    /**
     * Validate element has empty text (inter-element whitespace is not considered text)
     */
    validateNone(node) {
        if (classifyNodeText(node) === exports.TextClassification.EMPTY_TEXT) {
            return;
        }
        this.reportError(node, node.meta, `${node.annotatedName} must not have text content`);
    }
    /**
     * Validate element has any text (inter-element whitespace is not considered text)
     */
    validateRequired(node) {
        if (classifyNodeText(node) !== exports.TextClassification.EMPTY_TEXT) {
            return;
        }
        this.reportError(node, node.meta, `${node.annotatedName} must have text content`);
    }
    /**
     * Validate element has accessible text (either regular text or text only
     * exposed in accessibility tree via aria-label or similar)
     */
    validateAccessible(node) {
        /* skip this element if the element isn't present in accessibility tree */
        if (!inAccessibilityTree(node)) {
            return;
        }
        /* if the element or a child has aria-label, alt or default text, etc the
         * element has accessible text */
        if (haveAccessibleText(node)) {
            return;
        }
        this.reportError(node, node.meta, `${node.annotatedName} must have accessible text`);
    }
    reportError(node, meta, message) {
        this.report(node, message, null, {
            tagName: node.tagName,
            textContent: meta.textContent,
        });
    }
}

const defaults$4 = {
    ignoreCase: false,
    requireSemicolon: true,
};
const regexp$1 = /&(?:[a-z0-9]+|#x?[0-9a-f]+)(;|[^a-z0-9]|$)/gi;
const lowercaseEntities = elements.entities.map((it) => it.toLowerCase());
function isNumerical(entity) {
    return entity.startsWith("&#");
}
function getLocation(location, entity, match) {
    var _a;
    /* istanbul ignore next: never happens in practive */
    const index = (_a = match.index) !== null && _a !== void 0 ? _a : 0;
    return sliceLocation(location, index, index + entity.length);
}
function getDescription(context, options) {
    const url = "https://html.spec.whatwg.org/multipage/named-characters.html";
    let message;
    if (context.terminated) {
        message = `Unrecognized character reference \`${context.entity}\`.`;
    }
    else {
        message = `Character reference \`${context.entity}\` must be terminated by a semicolon.`;
    }
    return [
        message,
        `HTML5 defines a set of [valid character references](${url}) but this is not a valid one.`,
        "",
        "Ensure that:",
        "",
        "1. The character is one of the listed names.",
        ...(options.ignoreCase ? [] : ["1. The case is correct (names are case sensitive)."]),
        ...(options.requireSemicolon ? ["1. The name is terminated with a `;`."] : []),
    ].join("\n");
}
class UnknownCharReference extends Rule {
    constructor(options) {
        super({ ...defaults$4, ...options });
    }
    static schema() {
        return {
            ignoreCase: {
                type: "boolean",
            },
            requireSemicolon: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        return {
            description: getDescription(context, this.options),
            url: "https://html-validate.org/rules/unrecognized-char-ref.html",
        };
    }
    setup() {
        this.on("element:ready", (event) => {
            const node = event.target;
            /* only iterate over direct descendants */
            for (const child of node.childNodes) {
                if (child.nodeType !== exports.NodeType.TEXT_NODE) {
                    continue;
                }
                this.findCharacterReferences(node, child.textContent, child.location, {
                    isAttribute: false,
                });
            }
        });
        this.on("attr", (event) => {
            /* boolean attributes has no value so nothing to validate */
            if (!event.value) {
                return;
            }
            this.findCharacterReferences(event.target, event.value.toString(), event.valueLocation, {
                isAttribute: true,
            });
        });
    }
    get entities() {
        if (this.options.ignoreCase) {
            return lowercaseEntities;
        }
        else {
            return elements.entities;
        }
    }
    findCharacterReferences(node, text, location, { isAttribute }) {
        const isQuerystring = isAttribute && text.includes("?");
        for (const match of this.getMatches(text)) {
            this.validateCharacterReference(node, location, match, { isQuerystring });
        }
    }
    validateCharacterReference(node, location, foobar, { isQuerystring }) {
        const { requireSemicolon } = this.options;
        const { match, entity, raw, terminated } = foobar;
        /* assume numeric entities are valid for now */
        if (isNumerical(entity)) {
            return;
        }
        /* special case: when attributes use query parameters we skip checking
         * unterminated attributes */
        if (isQuerystring && !terminated) {
            return;
        }
        const found = this.entities.includes(entity);
        /* ignore if this is a known character reference name */
        if (found && (terminated || !requireSemicolon)) {
            return;
        }
        if (found && !terminated) {
            const entityLocation = getLocation(location, entity, match);
            const message = `Character reference "{{ entity }}" must be terminated by a semicolon`;
            const context = {
                entity: raw,
                terminated: false,
            };
            this.report(node, message, entityLocation, context);
            return;
        }
        const entityLocation = getLocation(location, entity, match);
        const message = `Unrecognized character reference "{{ entity }}"`;
        const context = {
            entity: raw,
            terminated: true,
        };
        this.report(node, message, entityLocation, context);
    }
    *getMatches(text) {
        let match;
        do {
            match = regexp$1.exec(text);
            if (match) {
                const terminator = match[1]; // === ";" ? match[1] : "";
                const terminated = terminator === ";";
                const needSlice = terminator !== ";" && terminator.length > 0;
                const entity = needSlice ? match[0].slice(0, -1) : match[0];
                if (this.options.ignoreCase) {
                    yield { match, entity: entity.toLowerCase(), raw: entity, terminated };
                }
                else {
                    yield { match, entity, raw: entity, terminated };
                }
            }
        } while (match);
    }
}

var RuleContext;
(function (RuleContext) {
    RuleContext[RuleContext["EMPTY"] = 1] = "EMPTY";
    RuleContext[RuleContext["WHITESPACE"] = 2] = "WHITESPACE";
    RuleContext[RuleContext["LEADING_CHARACTER"] = 3] = "LEADING_CHARACTER";
    RuleContext[RuleContext["DISALLOWED_CHARACTER"] = 4] = "DISALLOWED_CHARACTER";
})(RuleContext || (RuleContext = {}));
const defaults$3 = {
    relaxed: false,
};
class ValidID extends Rule {
    constructor(options) {
        super({ ...defaults$3, ...options });
    }
    static schema() {
        return {
            relaxed: {
                type: "boolean",
            },
        };
    }
    documentation(context) {
        const { relaxed } = this.options;
        const message = this.messages[context]
            .replace("id", "ID")
            .replace(/^(.)/, (m) => m.toUpperCase());
        const relaxedDescription = relaxed
            ? []
            : [
                "  - ID must begin with a letter",
                "  - ID must only contain alphanumerical characters, `-` and `_`",
            ];
        return {
            description: [
                `${message}.`,
                "",
                "Under the current configuration the following rules are applied:",
                "",
                "  - ID must not be empty",
                "  - ID must not contain any whitespace characters",
                ...relaxedDescription,
            ].join("\n"),
            url: "https://html-validate.org/rules/valid-id.html",
        };
    }
    setup() {
        this.on("attr", this.isRelevant, (event) => {
            const { value } = event;
            if (value === null || value instanceof DynamicValue) {
                return;
            }
            if (value === "") {
                const context = RuleContext.EMPTY;
                this.report(event.target, this.messages[context], event.location, context);
                return;
            }
            if (value.match(/\s/)) {
                const context = RuleContext.WHITESPACE;
                this.report(event.target, this.messages[context], event.valueLocation, context);
                return;
            }
            const { relaxed } = this.options;
            if (relaxed) {
                return;
            }
            if (value.match(/^[^a-zA-Z]/)) {
                const context = RuleContext.LEADING_CHARACTER;
                this.report(event.target, this.messages[context], event.valueLocation, context);
                return;
            }
            if (value.match(/[^a-zA-Z0-9-_]/)) {
                const context = RuleContext.DISALLOWED_CHARACTER;
                this.report(event.target, this.messages[context], event.valueLocation, context);
            }
        });
    }
    get messages() {
        return {
            [RuleContext.EMPTY]: "element id must not be empty",
            [RuleContext.WHITESPACE]: "element id must not contain whitespace",
            [RuleContext.LEADING_CHARACTER]: "element id must begin with a letter",
            [RuleContext.DISALLOWED_CHARACTER]: "element id must only contain alphanumerical, dash and underscore characters",
        };
    }
    isRelevant(event) {
        return event.key === "id";
    }
}

class VoidContent extends Rule {
    documentation(tagName) {
        const doc = {
            description: "HTML void elements cannot have any content and must not have content or end tag.",
            url: "https://html-validate.org/rules/void-content.html",
        };
        if (tagName) {
            doc.description = `<${tagName}> is a void element and must not have content or end tag.`;
        }
        return doc;
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.target; // The current element being closed.
            if (!node) {
                return;
            }
            if (!node.voidElement) {
                return;
            }
            if (node.closed === exports.NodeClosed.EndTag) {
                this.report(null, `End tag for <${node.tagName}> must be omitted`, node.location, node.tagName);
            }
        });
    }
}

var Style;
(function (Style) {
    Style[Style["AlwaysOmit"] = 1] = "AlwaysOmit";
    Style[Style["AlwaysSelfclose"] = 2] = "AlwaysSelfclose";
})(Style || (Style = {}));
const defaults$2 = {
    style: "omit",
};
class VoidStyle extends Rule {
    constructor(options) {
        super({ ...defaults$2, ...options });
        this.style = parseStyle(this.options.style);
    }
    static schema() {
        return {
            style: {
                enum: ["omit", "selfclose", "selfclosing"],
                type: "string",
            },
        };
    }
    documentation(context) {
        const [desc, end] = styleDescription(context.style);
        return {
            description: `The current configuration requires void elements to ${desc}, use <${context.tagName}${end}> instead.`,
            url: "https://html-validate.org/rules/void-style.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const active = event.previous; // The current active element (that is, the current element on the stack)
            if (active.meta) {
                this.validateActive(active);
            }
        });
    }
    validateActive(node) {
        /* ignore non-void elements, they must be closed with regular end tag */
        if (!node.voidElement) {
            return;
        }
        if (this.shouldBeOmitted(node)) {
            this.reportError(node, `Expected omitted end tag <${node.tagName}> instead of self-closing element <${node.tagName}/>`);
        }
        if (this.shouldBeSelfClosed(node)) {
            this.reportError(node, `Expected self-closing element <${node.tagName}/> instead of omitted end-tag <${node.tagName}>`);
        }
    }
    reportError(node, message) {
        const context = {
            style: this.style,
            tagName: node.tagName,
        };
        super.report(node, message, null, context);
    }
    shouldBeOmitted(node) {
        return this.style === Style.AlwaysOmit && node.closed === exports.NodeClosed.VoidSelfClosed;
    }
    shouldBeSelfClosed(node) {
        return this.style === Style.AlwaysSelfclose && node.closed === exports.NodeClosed.VoidOmitted;
    }
}
function parseStyle(name) {
    switch (name) {
        case "omit":
            return Style.AlwaysOmit;
        case "selfclose":
        case "selfclosing":
            return Style.AlwaysSelfclose;
        /* istanbul ignore next: covered by schema validation */
        default:
            throw new Error(`Invalid style "${name}" for "void-style" rule`);
    }
}
function styleDescription(style) {
    switch (style) {
        case Style.AlwaysOmit:
            return ["omit end tag", ""];
        case Style.AlwaysSelfclose:
            return ["be self-closed", "/"];
        // istanbul ignore next: will only happen if new styles are added, otherwise this isn't reached
        default:
            throw new Error(`Unknown style`);
    }
}

class H30 extends Rule {
    documentation() {
        return {
            description: "WCAG 2.1 requires each `<a>` anchor link to have a text describing the purpose of the link using either plain text or an `<img>` with the `alt` attribute set.",
            url: "https://html-validate.org/rules/wcag/h30.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const links = event.document.getElementsByTagName("a");
            for (const link of links) {
                /* ignore links with aria-hidden="true" */
                if (!inAccessibilityTree(link)) {
                    continue;
                }
                /* check if text content is present (or dynamic) */
                const textClassification = classifyNodeText(link, { ignoreHiddenRoot: true });
                if (textClassification !== exports.TextClassification.EMPTY_TEXT) {
                    continue;
                }
                /* check if image with alt-text is present */
                const images = link.querySelectorAll("img");
                if (images.some((image) => hasAltText(image))) {
                    continue;
                }
                /* check if aria-label is present on either the <a> element or a descendant */
                const labels = link.querySelectorAll("[aria-label]");
                if (hasAriaLabel(link) || labels.some((cur) => hasAriaLabel(cur))) {
                    continue;
                }
                this.report(link, "Anchor link must have a text describing its purpose");
            }
        });
    }
}

class H32 extends Rule {
    documentation() {
        return {
            description: "WCAG 2.1 requires each `<form>` element to have at least one submit button.",
            url: "https://html-validate.org/rules/wcag/h32.html",
        };
    }
    setup() {
        /* query all tags with form property, normally this is only the <form> tag
         * but with custom element metadata other tags might be considered form
         * (usually a component wrapping a <form> element) */
        const formTags = this.getTagsWithProperty("form");
        const formSelector = formTags.join(",");
        this.on("dom:ready", (event) => {
            const { document } = event;
            const forms = document.querySelectorAll(formSelector);
            for (const form of forms) {
                /* find nested submit buttons */
                if (hasNestedSubmit(form)) {
                    continue;
                }
                /* find explicitly associated submit buttons */
                if (hasAssociatedSubmit(document, form)) {
                    continue;
                }
                this.report(form, `<${form.tagName}> element must have a submit button`);
            }
        });
    }
}
function isSubmit(node) {
    const type = node.getAttribute("type");
    return Boolean(type && type.valueMatches(/submit|image/));
}
function isAssociated(id, node) {
    const form = node.getAttribute("form");
    return Boolean(form && form.valueMatches(id, true));
}
function hasNestedSubmit(form) {
    const matches = form
        .querySelectorAll("button,input")
        .filter(isSubmit)
        .filter((node) => !node.hasAttribute("form"));
    return matches.length > 0;
}
function hasAssociatedSubmit(document, form) {
    const { id } = form;
    if (!id) {
        return false;
    }
    const matches = document
        .querySelectorAll("button[form],input[form]")
        .filter(isSubmit)
        .filter((node) => isAssociated(id, node));
    return matches.length > 0;
}

class H36 extends Rule {
    documentation() {
        return {
            description: 'WCAG 2.1 requires all images used as submit buttons to have a textual description using the alt attribute. The alt text cannot be empty (`alt=""`).',
            url: "https://html-validate.org/rules/wcag/h36.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            /* only handle input elements */
            const node = event.previous;
            if (node.tagName !== "input")
                return;
            /* only handle images with type="image" */
            if (node.getAttributeValue("type") !== "image") {
                return;
            }
            if (!hasAltText(node)) {
                this.report(node, "image used as submit button must have alt text");
            }
        });
    }
}

const defaults$1 = {
    allowEmpty: true,
    alias: [],
};
function needsAlt(node) {
    if (node.is("img")) {
        return true;
    }
    if (node.is("input") && node.getAttributeValue("type") === "image") {
        return true;
    }
    return false;
}
function getTag(node) {
    var _a;
    return node.is("input")
        ? `<input type="${ /* istanbul ignore next */(_a = node.getAttributeValue("type")) !== null && _a !== void 0 ? _a : ""}">`
        : `<${node.tagName}>`;
}
class H37 extends Rule {
    constructor(options) {
        super({ ...defaults$1, ...options });
        /* ensure alias is array */
        if (!Array.isArray(this.options.alias)) {
            this.options.alias = [this.options.alias];
        }
    }
    static schema() {
        return {
            alias: {
                anyOf: [
                    {
                        items: {
                            type: "string",
                        },
                        type: "array",
                    },
                    {
                        type: "string",
                    },
                ],
            },
            allowEmpty: {
                type: "boolean",
            },
        };
    }
    documentation() {
        return {
            description: "Both HTML5 and WCAG 2.0 requires images to have a alternative text for each image.",
            url: "https://html-validate.org/rules/wcag/h37.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.previous;
            /* only validate images */
            if (!needsAlt(node)) {
                return;
            }
            /* ignore images with aria-hidden="true" or role="presentation" */
            if (!inAccessibilityTree(node)) {
                return;
            }
            /* validate plain alt-attribute */
            if (Boolean(node.getAttributeValue("alt")) ||
                Boolean(node.hasAttribute("alt") && this.options.allowEmpty)) {
                return;
            }
            /* validate if any non-empty alias is present */
            for (const attr of this.options.alias) {
                if (node.getAttribute(attr)) {
                    return;
                }
            }
            if (node.hasAttribute("alt")) {
                const attr = node.getAttribute("alt");
                /* istanbul ignore next */
                this.report(node, `${getTag(node)} cannot have empty "alt" attribute`, attr === null || attr === void 0 ? void 0 : attr.keyLocation);
            }
            else {
                this.report(node, `${getTag(node)} is missing required "alt" attribute`, node.location);
            }
        });
    }
}

var _a;
/* istanbul ignore next: this will always be present for the <th>
 * attribute (or the tests would fail) */
const { enum: validScopes } = (_a = elements.html5.th.attributes) === null || _a === void 0 ? void 0 : _a.scope;
const joinedScopes = utils_naturalJoin.naturalJoin(validScopes);
class H63 extends Rule {
    documentation() {
        return {
            description: "H63: Using the scope attribute to associate header cells and data cells in data tables",
            url: "https://html-validate.org/rules/wcag/h63.html",
        };
    }
    setup() {
        this.on("tag:ready", (event) => {
            var _a, _b;
            const node = event.target;
            /* only validate th */
            if (node.tagName !== "th") {
                return;
            }
            const scope = node.getAttribute("scope");
            const value = scope === null || scope === void 0 ? void 0 : scope.value;
            /* ignore dynamic scope */
            if (value instanceof DynamicValue) {
                return;
            }
            /* ignore elements with valid scope values */
            if (value && validScopes.includes(value)) {
                return;
            }
            const message = `<th> element must have a valid scope attribute: ${joinedScopes}`;
            const location = (_b = (_a = scope === null || scope === void 0 ? void 0 : scope.valueLocation) !== null && _a !== void 0 ? _a : scope === null || scope === void 0 ? void 0 : scope.keyLocation) !== null && _b !== void 0 ? _b : node.location;
            this.report(node, message, location);
        });
    }
}

class H67 extends Rule {
    documentation() {
        return {
            description: "A decorative image cannot have a title attribute. Either remove `title` or add a descriptive `alt` text.",
            url: "https://html-validate.org/rules/wcag/h67.html",
        };
    }
    setup() {
        this.on("tag:end", (event) => {
            const node = event.target;
            /* only validate images */
            if (!node || node.tagName !== "img") {
                return;
            }
            /* ignore images without title */
            const title = node.getAttribute("title");
            if (!title || title.value === "") {
                return;
            }
            /* ignore elements with non-empty alt-text */
            const alt = node.getAttributeValue("alt");
            if (alt && alt !== "") {
                return;
            }
            this.report(node, "<img> with empty alt text cannot have title attribute", title.keyLocation);
        });
    }
}

class H71 extends Rule {
    documentation() {
        return {
            description: "H71: Providing a description for groups of form controls using fieldset and legend elements",
            url: "https://html-validate.org/rules/wcag/h71.html",
        };
    }
    setup() {
        this.on("dom:ready", (event) => {
            const { document } = event;
            const fieldsets = document.querySelectorAll(this.selector);
            for (const fieldset of fieldsets) {
                this.validate(fieldset);
            }
        });
    }
    validate(fieldset) {
        const legend = fieldset.querySelectorAll("> legend");
        if (legend.length === 0) {
            this.reportNode(fieldset);
        }
    }
    reportNode(node) {
        super.report(node, `${node.annotatedName} must have a <legend> as the first child`);
    }
    get selector() {
        return this.getTagsDerivedFrom("fieldset").join(",");
    }
}

const bundledRules$1 = {
    "wcag/h30": H30,
    "wcag/h32": H32,
    "wcag/h36": H36,
    "wcag/h37": H37,
    "wcag/h63": H63,
    "wcag/h67": H67,
    "wcag/h71": H71,
};
var WCAG = bundledRules$1;

const bundledRules = {
    "allowed-links": AllowedLinks,
    "area-alt": AreaAlt,
    "aria-hidden-body": AriaHiddenBody,
    "aria-label-misuse": AriaLabelMisuse,
    "attr-case": AttrCase,
    "attr-delimiter": AttrDelimiter,
    "attr-pattern": AttrPattern,
    "attr-quotes": AttrQuotes,
    "attr-spacing": AttrSpacing,
    "attribute-allowed-values": AttributeAllowedValues,
    "attribute-boolean-style": AttributeBooleanStyle,
    "attribute-empty-style": AttributeEmptyStyle,
    "attribute-misuse": AttributeMisuse,
    "class-pattern": ClassPattern,
    "close-attr": CloseAttr,
    "close-order": CloseOrder,
    deprecated: Deprecated,
    "deprecated-rule": DeprecatedRule,
    "doctype-html": NoStyleTag$1,
    "doctype-style": DoctypeStyle,
    "element-case": ElementCase,
    "element-name": ElementName,
    "element-permitted-content": ElementPermittedContent,
    "element-permitted-occurrences": ElementPermittedOccurrences,
    "element-permitted-order": ElementPermittedOrder,
    "element-permitted-parent": ElementPermittedParent,
    "element-required-ancestor": ElementRequiredAncestor,
    "element-required-attributes": ElementRequiredAttributes,
    "element-required-content": ElementRequiredContent,
    "empty-heading": EmptyHeading,
    "empty-title": EmptyTitle,
    "form-dup-name": FormDupName,
    "heading-level": HeadingLevel,
    "id-pattern": IdPattern,
    "input-attributes": InputAttributes,
    "input-missing-label": InputMissingLabel,
    "long-title": LongTitle,
    "map-dup-name": MapDupName,
    "map-id-name": MapIdName,
    "meta-refresh": MetaRefresh,
    "missing-doctype": MissingDoctype,
    "multiple-labeled-controls": MultipleLabeledControls,
    "no-autoplay": NoAutoplay,
    "no-conditional-comment": NoConditionalComment,
    "no-deprecated-attr": NoDeprecatedAttr,
    "no-dup-attr": NoDupAttr,
    "no-dup-class": NoDupClass,
    "no-dup-id": NoDupID,
    "no-implicit-button-type": NoImplicitButtonType,
    "no-implicit-close": NoImplicitClose,
    "no-inline-style": NoInlineStyle,
    "no-missing-references": NoMissingReferences,
    "no-multiple-main": NoMultipleMain,
    "no-raw-characters": NoRawCharacters,
    "no-redundant-aria-label": NoRedundantAriaLabel,
    "no-redundant-for": NoRedundantFor,
    "no-redundant-role": NoRedundantRole,
    "no-self-closing": NoSelfClosing,
    "no-style-tag": NoStyleTag,
    "no-trailing-whitespace": NoTrailingWhitespace,
    "no-unknown-elements": NoUnknownElements,
    "no-unused-disable": NoUnusedDisable,
    "no-utf8-bom": NoUtf8Bom,
    "prefer-button": PreferButton,
    "prefer-native-element": PreferNativeElement,
    "prefer-tbody": PreferTbody,
    "require-csp-nonce": RequireCSPNonce,
    "require-sri": RequireSri,
    "script-element": ScriptElement,
    "script-type": ScriptType,
    "svg-focusable": SvgFocusable,
    "tel-non-breaking": TelNonBreaking,
    "text-content": TextContent,
    "unrecognized-char-ref": UnknownCharReference,
    "valid-id": ValidID,
    "void-content": VoidContent,
    "void-style": VoidStyle,
    ...WCAG,
};
var rules = bundledRules;

var defaultConfig = {};

const config$4 = {
    rules: {
        "area-alt": ["error", { accessible: true }],
        "aria-hidden-body": "error",
        "aria-label-misuse": "error",
        "deprecated-rule": "warn",
        "empty-heading": "error",
        "empty-title": "error",
        "meta-refresh": "error",
        "multiple-labeled-controls": "error",
        "no-autoplay": ["error", { include: ["audio", "video"] }],
        "no-dup-id": "error",
        "no-implicit-button-type": "error",
        "no-redundant-aria-label": "error",
        "no-redundant-for": "error",
        "no-redundant-role": "error",
        "prefer-native-element": "error",
        "svg-focusable": "off",
        "text-content": "error",
        "wcag/h30": "error",
        "wcag/h32": "error",
        "wcag/h36": "error",
        "wcag/h37": "error",
        "wcag/h63": "error",
        "wcag/h67": "error",
        "wcag/h71": "error",
    },
};
var a11y = config$4;

const config$3 = {
    rules: {
        "input-missing-label": "error",
        "heading-level": "error",
        "missing-doctype": "error",
        "no-missing-references": "error",
        "require-sri": "error",
    },
};
var document = config$3;

const config$2 = {
    rules: {
        "attr-quotes": "off",
        "void-style": "off",
    },
};
var prettier = config$2;

const config$1 = {
    rules: {
        "area-alt": ["error", { accessible: true }],
        "aria-hidden-body": "error",
        "aria-label-misuse": "error",
        "attr-case": "error",
        "attr-delimiter": "error",
        "attr-quotes": "error",
        "attr-spacing": "error",
        "attribute-allowed-values": "error",
        "attribute-boolean-style": "error",
        "attribute-empty-style": "error",
        "attribute-misuse": "error",
        "close-attr": "error",
        "close-order": "error",
        deprecated: "error",
        "deprecated-rule": "warn",
        "doctype-html": "error",
        "doctype-style": "error",
        "element-case": "error",
        "element-name": "error",
        "element-permitted-content": "error",
        "element-permitted-occurrences": "error",
        "element-permitted-order": "error",
        "element-permitted-parent": "error",
        "element-required-ancestor": "error",
        "element-required-attributes": "error",
        "element-required-content": "error",
        "empty-heading": "error",
        "empty-title": "error",
        "form-dup-name": "error",
        "input-attributes": "error",
        "long-title": "error",
        "map-dup-name": "error",
        "map-id-name": "error",
        "meta-refresh": "error",
        "multiple-labeled-controls": "error",
        "no-autoplay": ["error", { include: ["audio", "video"] }],
        "no-conditional-comment": "error",
        "no-deprecated-attr": "error",
        "no-dup-attr": "error",
        "no-dup-class": "error",
        "no-dup-id": "error",
        "no-implicit-button-type": "error",
        "no-implicit-close": "error",
        "no-inline-style": "error",
        "no-multiple-main": "error",
        "no-raw-characters": "error",
        "no-redundant-aria-label": "error",
        "no-redundant-for": "error",
        "no-redundant-role": "error",
        "no-self-closing": "error",
        "no-trailing-whitespace": "error",
        "no-utf8-bom": "error",
        "no-unused-disable": "error",
        "prefer-button": "error",
        "prefer-native-element": "error",
        "prefer-tbody": "error",
        "script-element": "error",
        "script-type": "error",
        "svg-focusable": "off",
        "tel-non-breaking": "error",
        "text-content": "error",
        "unrecognized-char-ref": "error",
        "valid-id": ["error", { relaxed: false }],
        void: "off",
        "void-content": "error",
        "void-style": "error",
        "wcag/h30": "error",
        "wcag/h32": "error",
        "wcag/h36": "error",
        "wcag/h37": "error",
        "wcag/h63": "error",
        "wcag/h67": "error",
        "wcag/h71": "error",
    },
};
var recommended = config$1;

const config = {
    rules: {
        "area-alt": ["error", { accessible: false }],
        "attr-spacing": "error",
        "attribute-allowed-values": "error",
        "attribute-misuse": "error",
        "close-attr": "error",
        "close-order": "error",
        deprecated: "error",
        "deprecated-rule": "warn",
        "doctype-html": "error",
        "element-name": "error",
        "element-permitted-content": "error",
        "element-permitted-occurrences": "error",
        "element-permitted-order": "error",
        "element-permitted-parent": "error",
        "element-required-ancestor": "error",
        "element-required-attributes": "error",
        "element-required-content": "error",
        "map-dup-name": "error",
        "map-id-name": "error",
        "multiple-labeled-controls": "error",
        "no-deprecated-attr": "error",
        "no-dup-attr": "error",
        "no-dup-id": "error",
        "no-multiple-main": "error",
        "no-raw-characters": ["error", { relaxed: true }],
        "no-unused-disable": "error",
        "script-element": "error",
        "unrecognized-char-ref": "error",
        "valid-id": ["error", { relaxed: true }],
        "void-content": "error",
    },
};
var standard = config;

/**
 * @internal
 */
const presets = {
    "html-validate:a11y": a11y,
    "html-validate:document": document,
    "html-validate:prettier": prettier,
    "html-validate:recommended": recommended,
    "html-validate:standard": standard,
    /* @deprecated aliases */
    "htmlvalidate:recommended": recommended,
    "htmlvalidate:document": document,
    "html-validate:a17y": a11y,
};
var Presets = presets;

/**
 * A resolved configuration is a normalized configuration with all extends,
 * plugins etc resolved.
 *
 * @public
 */
class ResolvedConfig {
    /**
     * @internal
     */
    constructor({ metaTable, plugins, rules, transformers }, original) {
        this.metaTable = metaTable;
        this.plugins = plugins;
        this.rules = rules;
        this.transformers = transformers;
        this.original = original;
    }
    /**
     * Returns the (merged) configuration data used to create this resolved
     * configuration.
     */
    getConfigData() {
        return this.original;
    }
    getMetaTable() {
        return this.metaTable;
    }
    getPlugins() {
        return this.plugins;
    }
    getRules() {
        return this.rules;
    }
    /**
     * Transform a source.
     *
     * When transforming zero or more new sources will be generated.
     *
     * @param source - Current source to transform.
     * @param filename - If set it is the filename used to match
     * transformer. Default is to use filename from source.
     * @returns A list of transformed sources ready for validation.
     */
    transformSource(source, filename) {
        const transformer = this.findTransformer(filename !== null && filename !== void 0 ? filename : source.filename);
        const context = {
            hasChain: (filename) => {
                return !!this.findTransformer(filename);
            },
            chain: (source, filename) => {
                return this.transformSource(source, filename);
            },
        };
        if (transformer) {
            try {
                return Array.from(transformer.fn.call(context, source), (cur) => {
                    var _a;
                    /* keep track of which transformers that has been run on this source
                     * by appending this entry to the transformedBy array */
                    (_a = cur.transformedBy) !== null && _a !== void 0 ? _a : (cur.transformedBy = []);
                    cur.transformedBy.push(transformer.name);
                    return cur;
                });
            }
            catch (err) {
                /* istanbul ignore next: only used as a fallback */
                const message = err instanceof Error ? err.message : String(err);
                throw new NestedError(`When transforming "${source.filename}": ${message}`, ensureError(err));
            }
        }
        else {
            return [source];
        }
    }
    /**
     * Wrapper around [[transformSource]] which reads a file before passing it
     * as-is to transformSource.
     *
     * @param filename - Filename to transform (according to configured
     * transformations)
     * @returns A list of transformed sources ready for validation.
     */
    transformFilename(filename) {
        const stdin = 0;
        const src = filename !== "/dev/stdin" ? filename : stdin;
        const data = fs__default.default.readFileSync(src, { encoding: "utf8" });
        const source = {
            data,
            filename,
            line: 1,
            column: 1,
            offset: 0,
            originalData: data,
        };
        return this.transformSource(source);
    }
    /**
     * Returns true if a transformer matches given filename.
     */
    canTransform(filename) {
        const entry = this.findTransformer(filename);
        return !!entry;
    }
    findTransformer(filename) {
        const match = this.transformers.find((entry) => entry.pattern.test(filename));
        return match !== null && match !== void 0 ? match : null;
    }
}

function haveResolver(key, value) {
    return key in value;
}
function haveConfigResolver(value) {
    return haveResolver("resolveConfig", value);
}
function haveElementsResolver(value) {
    return haveResolver("resolveElements", value);
}
function havePluginResolver(value) {
    return haveResolver("resolvePlugin", value);
}
function haveTransformerResolver(value) {
    return haveResolver("resolveTransformer", value);
}
/**
 * @internal
 */
function resolveConfig(resolvers, id, options) {
    for (const resolver of resolvers.filter(haveConfigResolver)) {
        const config = resolver.resolveConfig(id, options);
        if (config) {
            return config;
        }
    }
    throw new UserError(`Failed to load configuration from "${id}"`);
}
/**
 * @internal
 */
function resolveElements(resolvers, id, options) {
    for (const resolver of resolvers.filter(haveElementsResolver)) {
        const elements = resolver.resolveElements(id, options);
        if (elements) {
            return elements;
        }
    }
    throw new UserError(`Failed to load elements from "${id}"`);
}
/**
 * @internal
 */
function resolvePlugin(resolvers, id, options) {
    for (const resolver of resolvers.filter(havePluginResolver)) {
        const plugin = resolver.resolvePlugin(id, options);
        if (plugin) {
            return plugin;
        }
    }
    throw new UserError(`Failed to load plugin from "${id}"`);
}
/**
 * @internal
 */
function resolveTransformer(resolvers, id, options) {
    for (const resolver of resolvers.filter(haveTransformerResolver)) {
        const transformer = resolver.resolveTransformer(id, options);
        if (transformer) {
            return transformer;
        }
    }
    throw new UserError(`Failed to load transformer from "${id}"`);
}

/**
 * Create a new resolver for static content, i.e. plugins or transformers known
 * at compile time.
 *
 * @public
 * @since 8.0.0
 */
function staticResolver(map = {}) {
    const { elements = {}, configs = {}, plugins = {}, transformers = {} } = map;
    return {
        name: "static-qresolver",
        addElements(id, value) {
            elements[id] = value;
        },
        addConfig(id, value) {
            configs[id] = value;
        },
        addPlugin(id, value) {
            plugins[id] = value;
        },
        addTransformer(id, value) {
            transformers[id] = value;
        },
        resolveElements(id) {
            var _a;
            return (_a = elements[id]) !== null && _a !== void 0 ? _a : null;
        },
        resolveConfig(id) {
            var _a;
            return (_a = configs[id]) !== null && _a !== void 0 ? _a : null;
        },
        resolvePlugin(id) {
            var _a;
            return (_a = plugins[id]) !== null && _a !== void 0 ? _a : null;
        },
        resolveTransformer(id) {
            var _a;
            return (_a = transformers[id]) !== null && _a !== void 0 ? _a : null;
        },
    };
}

const ajv = new Ajv__default.default({ strict: true, strictTuples: true, strictTypes: true });
ajv.addMetaSchema(ajvSchemaDraft);
const validator = ajv.compile(configurationSchema);
function overwriteMerge(a, b) {
    return b;
}
function mergeInternal(base, rhs) {
    const dst = deepmerge__default.default(base, { ...rhs, rules: {} });
    /* rules need some special care, should overwrite arrays instead of
     * concaternation, i.e. ["error", {...options}] should not be merged by
     * appending to old value */
    if (rhs.rules) {
        dst.rules = deepmerge__default.default(dst.rules, rhs.rules, { arrayMerge: overwriteMerge });
    }
    /* root property is merged with boolean "or" since it should always be truthy
     * if any config has it set. */
    const root = Boolean(base.root) || Boolean(rhs.root);
    if (root) {
        dst.root = root;
    }
    return dst;
}
function toArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    else {
        return [value];
    }
}
/**
 * Configuration holder.
 *
 * Each file being validated will have a unique instance of this class.
 *
 * @public
 */
class Config {
    /**
     * Create a new blank configuration. See also `Config.defaultConfig()`.
     */
    static empty() {
        return new Config([], {
            extends: [],
            rules: {},
            plugins: [],
            transform: {},
        });
    }
    /**
     * Create configuration from object.
     */
    static fromObject(resolvers, options, filename = null) {
        Config.validate(options, filename);
        return new Config(resolvers, options);
    }
    /**
     * Read configuration from filename.
     *
     * Note: this reads configuration data from a file. If you intent to load
     * configuration for a file to validate use `ConfigLoader.fromTarget()`.
     *
     * @internal
     * @param filename - The file to read from
     */
    static fromFile(resolvers, filename) {
        const configData = resolveConfig(toArray(resolvers), filename, { cache: false });
        return Config.fromObject(resolvers, configData, filename);
    }
    /**
     * Validate configuration data.
     *
     * Throws SchemaValidationError if invalid.
     *
     * @internal
     */
    static validate(configData, filename = null) {
        var _a;
        const valid = validator(configData);
        if (!valid) {
            throw new SchemaValidationError(filename, `Invalid configuration`, configData, configurationSchema, 
            /* istanbul ignore next: will be set when a validation error has occurred */
            (_a = validator.errors) !== null && _a !== void 0 ? _a : []);
        }
        if (configData.rules) {
            const normalizedRules = Config.getRulesObject(configData.rules);
            for (const [ruleId, [, ruleOptions]] of normalizedRules.entries()) {
                const cls = rules[ruleId];
                const path = `/rules/${ruleId}/1`;
                Rule.validateOptions(cls, ruleId, path, ruleOptions, filename, configData);
            }
        }
    }
    /**
     * Load a default configuration object.
     */
    static defaultConfig() {
        return new Config([], defaultConfig);
    }
    /**
     * @internal
     */
    constructor(resolvers, options) {
        var _a, _b;
        this.transformers = [];
        const initial = {
            extends: [],
            plugins: [],
            rules: {},
            transform: {},
        };
        this.config = mergeInternal(initial, options);
        this.metaTable = null;
        this.initialized = false;
        this.resolvers = toArray(resolvers);
        /* load plugins */
        this.plugins = this.loadPlugins((_a = this.config.plugins) !== null && _a !== void 0 ? _a : []);
        this.configurations = this.loadConfigurations(this.plugins);
        this.extendMeta(this.plugins);
        /* process extended configs */
        this.config = this.extendConfig((_b = this.config.extends) !== null && _b !== void 0 ? _b : []);
        /* reset extends as we already processed them, this prevents the next config
         * from reapplying config from extended config as well as duplicate entries
         * when merging arrays */
        this.config.extends = [];
        /* rules explicitly set by passed options should have precedence over any
         * extended rules, not the other way around. */
        if (options.rules) {
            this.config = mergeInternal(this.config, { rules: options.rules });
        }
    }
    /**
     * Initialize plugins, transforms etc.
     *
     * Must be called before trying to use config. Can safely be called multiple
     * times.
     *
     * @public
     */
    init() {
        var _a;
        if (this.initialized) {
            return;
        }
        /* precompile transform patterns */
        this.transformers = this.precompileTransformers((_a = this.config.transform) !== null && _a !== void 0 ? _a : {});
        this.initialized = true;
    }
    /**
     * Returns true if this configuration is marked as "root".
     */
    isRootFound() {
        return Boolean(this.config.root);
    }
    /**
     * Returns a new configuration as a merge of the two. Entries from the passed
     * object takes priority over this object.
     *
     * @public
     * @param rhs - Configuration to merge with this one.
     */
    merge(resolvers, rhs) {
        return new Config(resolvers, mergeInternal(this.config, rhs.config));
    }
    extendConfig(entries) {
        if (entries.length === 0) {
            return this.config;
        }
        let base = {};
        for (const entry of entries) {
            let extended;
            if (this.configurations.has(entry)) {
                extended = this.configurations.get(entry); // eslint-disable-line @typescript-eslint/no-non-null-assertion -- map has/get combo
            }
            else {
                extended = Config.fromFile(this.resolvers, entry).config;
            }
            base = mergeInternal(base, extended);
        }
        return mergeInternal(base, this.config);
    }
    /**
     * Get element metadata.
     *
     * @internal
     */
    getMetaTable() {
        var _a;
        /* use cached table if it exists */
        if (this.metaTable) {
            return this.metaTable;
        }
        const metaTable = new MetaTable();
        const source = (_a = this.config.elements) !== null && _a !== void 0 ? _a : ["html5"];
        /* extend validation schema from plugins */
        for (const plugin of this.getPlugins()) {
            if (plugin.elementSchema) {
                metaTable.extendValidationSchema(plugin.elementSchema);
            }
        }
        /* load from all entries */
        for (const entry of source) {
            /* load meta directly from entry */
            if (typeof entry !== "string") {
                metaTable.loadFromObject(entry);
                continue;
            }
            /* try searching builtin metadata */
            const bundled = elements.bundledElements[entry];
            if (bundled) {
                metaTable.loadFromObject(bundled);
                continue;
            }
            /* load with resolver */
            try {
                const data = resolveElements(this.resolvers, entry, { cache: false });
                metaTable.loadFromObject(data, entry);
            }
            catch (err) {
                /* istanbul ignore next: only used as a fallback */
                const message = err instanceof Error ? err.message : String(err);
                throw new ConfigError(`Failed to load elements from "${entry}": ${message}`, ensureError(err));
            }
        }
        metaTable.init();
        return (this.metaTable = metaTable);
    }
    /**
     * Get a copy of internal configuration data.
     *
     * @internal primary purpose is unittests
     */
    /* istanbul ignore next: used for testing only */
    get() {
        return { ...this.config };
    }
    /**
     * Get all configured rules, their severity and options.
     *
     * @internal
     */
    getRules() {
        var _a;
        /* istanbul ignore next: only used as a fallback */
        return Config.getRulesObject((_a = this.config.rules) !== null && _a !== void 0 ? _a : {});
    }
    static getRulesObject(src) {
        const rules = new Map();
        for (const [ruleId, data] of Object.entries(src)) {
            let options = data;
            if (!Array.isArray(options)) {
                options = [options, {}];
            }
            else if (options.length === 1) {
                options = [options[0], {}];
            }
            const severity = parseSeverity(options[0]);
            rules.set(ruleId, [severity, options[1]]);
        }
        return rules;
    }
    /**
     * Get all configured plugins.
     *
     * @internal
     */
    getPlugins() {
        return this.plugins;
    }
    loadPlugins(plugins) {
        return plugins.map((moduleName, index) => {
            if (typeof moduleName !== "string") {
                const plugin = moduleName;
                plugin.name = plugin.name || `:unnamedPlugin@${index + 1}`;
                plugin.originalName = `:unnamedPlugin@${index + 1}`;
                return plugin;
            }
            try {
                const plugin = resolvePlugin(this.resolvers, moduleName, { cache: true });
                plugin.name = plugin.name || moduleName;
                plugin.originalName = moduleName;
                return plugin;
            }
            catch (err) {
                /* istanbul ignore next: only used as a fallback */
                const message = err instanceof Error ? err.message : String(err);
                throw new ConfigError(`Failed to load plugin "${moduleName}": ${message}`, ensureError(err));
            }
        });
    }
    loadConfigurations(plugins) {
        var _a;
        const configs = new Map();
        /* builtin presets */
        for (const [name, config] of Object.entries(Presets)) {
            Config.validate(config, name);
            configs.set(name, config);
        }
        /* presets from plugins */
        for (const plugin of plugins) {
            for (const [name, config] of Object.entries((_a = plugin.configs) !== null && _a !== void 0 ? _a : {})) {
                if (!config)
                    continue;
                Config.validate(config, name);
                /* add configuration with name provided by plugin */
                configs.set(`${plugin.name}:${name}`, config);
                /* add configuration with name provided by user (in config file) */
                if (plugin.name !== plugin.originalName) {
                    configs.set(`${plugin.originalName}:${name}`, config);
                }
            }
        }
        return configs;
    }
    extendMeta(plugins) {
        for (const plugin of plugins) {
            if (!plugin.elementSchema) {
                continue;
            }
            const { properties } = plugin.elementSchema;
            if (!properties) {
                continue;
            }
            for (const [raw, schema] of Object.entries(properties)) {
                /* at compile time this is a fixed list but the point of this method is
                 * to augment the runtime with additional keys so it is a bit of lying
                 * to typescript */
                const key = raw;
                if (schema.copyable && !MetaCopyableProperty.includes(key)) {
                    MetaCopyableProperty.push(key);
                }
            }
        }
    }
    /**
     * Resolve all configuration and return a [[ResolvedConfig]] instance.
     *
     * A resolved configuration will merge all extended configs and load all
     * plugins and transformers, and normalize the rest of the configuration.
     *
     * @public
     */
    resolve() {
        return new ResolvedConfig(this.resolveData(), this.get());
    }
    /**
     * Same as [[resolve]] but returns the raw configuration data instead of
     * [[ResolvedConfig]] instance. Mainly used for testing.
     *
     * @internal
     */
    resolveData() {
        return {
            metaTable: this.getMetaTable(),
            plugins: this.getPlugins(),
            rules: this.getRules(),
            transformers: this.transformers,
        };
    }
    precompileTransformers(transform) {
        return Object.entries(transform).map(([pattern, name]) => {
            var _a;
            try {
                const fn = this.getTransformFunction(name);
                /* istanbul ignore next */
                const version = (_a = fn.api) !== null && _a !== void 0 ? _a : 0;
                /* check if transformer version is supported */
                if (version !== TRANSFORMER_API.VERSION) {
                    throw new ConfigError(`Transformer uses API version ${version} but only version ${TRANSFORMER_API.VERSION} is supported`);
                }
                return {
                    // eslint-disable-next-line security/detect-non-literal-regexp -- expected to be a regexp
                    pattern: new RegExp(pattern),
                    name,
                    fn,
                };
            }
            catch (err) {
                if (err instanceof ConfigError) {
                    throw new ConfigError(`Failed to load transformer "${name}": ${err.message}`, err);
                }
                else {
                    throw new ConfigError(`Failed to load transformer "${name}"`, ensureError(err));
                }
            }
        });
    }
    /**
     * Get transformation function requested by configuration.
     *
     * Searches:
     *
     * - Named transformers from plugins.
     * - Unnamed transformer from plugin.
     * - Standalone modules (local or node_modules)
     *
     * @param name - Key from configuration
     */
    getTransformFunction(name) {
        /* try to match a named transformer from plugin */
        const match = name.match(/(.*):(.*)/);
        if (match) {
            const [, pluginName, key] = match;
            return this.getNamedTransformerFromPlugin(name, pluginName, key);
        }
        /* try to match an unnamed transformer from plugin */
        const plugin = this.plugins.find((cur) => cur.name === name);
        if (plugin) {
            return this.getUnnamedTransformerFromPlugin(name, plugin);
        }
        /* assume transformer refers to a regular module */
        return this.getTransformerFromModule(name);
    }
    /**
     * @param name - Original name from configuration
     * @param pluginName - Name of plugin
     * @param key - Name of transform (from plugin)
     */
    getNamedTransformerFromPlugin(name, pluginName, key) {
        const plugin = this.plugins.find((cur) => cur.name === pluginName);
        if (!plugin) {
            throw new ConfigError(`No plugin named "${pluginName}" has been loaded`);
        }
        if (!plugin.transformer) {
            throw new ConfigError(`Plugin does not expose any transformer`);
        }
        if (typeof plugin.transformer === "function") {
            throw new ConfigError(`Transformer "${name}" refers to named transformer but plugin exposes only unnamed, use "${pluginName}" instead.`);
        }
        const transformer = plugin.transformer[key];
        if (!transformer) {
            throw new ConfigError(`Plugin "${pluginName}" does not expose a transformer named "${key}".`);
        }
        return transformer;
    }
    /**
     * @param name - Original name from configuration
     * @param plugin - Plugin instance
     */
    getUnnamedTransformerFromPlugin(name, plugin) {
        if (!plugin.transformer) {
            throw new ConfigError(`Plugin does not expose any transformer`);
        }
        if (typeof plugin.transformer !== "function") {
            if (plugin.transformer.default) {
                return plugin.transformer.default;
            }
            throw new ConfigError(`Transformer "${name}" refers to unnamed transformer but plugin exposes only named.`);
        }
        return plugin.transformer;
    }
    getTransformerFromModule(name) {
        return resolveTransformer(this.resolvers, name, { cache: true });
    }
}

/**
 * Configuration loader interface.
 *
 * A configuration loader takes a handle (typically a filename) and returns a
 * configuration for it.
 *
 * @public
 */
class ConfigLoader {
    constructor(resolvers, config) {
        const defaults = Config.empty();
        this.resolvers = resolvers;
        this.globalConfig = defaults.merge(this.resolvers, config ? this.loadFromObject(config) : this.defaultConfig());
    }
    /**
     * @internal For testing only
     */
    _getGlobalConfig() {
        return this.globalConfig.get();
    }
    empty() {
        return Config.empty();
    }
    loadFromObject(options, filename) {
        return Config.fromObject(this.resolvers, options, filename);
    }
    loadFromFile(filename) {
        return Config.fromFile(this.resolvers, filename);
    }
}

/**
 * @public
 */
class EventHandler {
    constructor() {
        this.listeners = {};
    }
    /**
     * Add an event listener.
     *
     * @param event - Event names (comma separated) or '*' for any event.
     * @param callback - Called any time even triggers.
     * @returns Unregistration function.
     */
    on(event, callback) {
        const names = event.split(",").map((x) => x.trim());
        for (const name of names) {
            this.listeners[name] = this.listeners[name] || [];
            this.listeners[name].push(callback);
        }
        return () => {
            for (const name of names) {
                this.listeners[name] = this.listeners[name].filter((fn) => {
                    return fn !== callback;
                });
            }
        };
    }
    /**
     * Add a onetime event listener. The listener will automatically be removed
     * after being triggered once.
     *
     * @param event - Event names (comma separated) or '*' for any event.
     * @param callback - Called any time even triggers.
     * @returns Unregistration function.
     */
    once(event, callback) {
        const deregister = this.on(event, (event, data) => {
            callback(event, data);
            deregister();
        });
        return deregister;
    }
    /**
     * Trigger event causing all listeners to be called.
     *
     * @param event - Event name.
     * @param data - Event data.
     */
    trigger(event, data) {
        var _a, _b;
        const callbacks = [...((_a = this.listeners[event]) !== null && _a !== void 0 ? _a : []), ...((_b = this.listeners["*"]) !== null && _b !== void 0 ? _b : [])];
        callbacks.forEach((listener) => {
            listener.call(null, event, data);
        });
    }
}

const regexp = /<!(?:--)?\[(.*?)\](?:--)?>/g;
function* parseConditionalComment(comment, commentLocation) {
    let match;
    while ((match = regexp.exec(comment)) !== null) {
        const expression = match[1];
        const begin = match.index;
        const end = begin + match[0].length;
        const location = sliceLocation(commentLocation, begin, end, comment);
        yield {
            expression,
            location,
        };
    }
}

class ParserError extends Error {
    constructor(location, message) {
        super(message);
        this.location = location;
    }
}

function isAttrValueToken(token) {
    return Boolean(token && token.type === TokenType.ATTR_VALUE);
}
function svgShouldRetainTag(foreignTagName, tagName) {
    return foreignTagName === "svg" && ["title", "desc"].includes(tagName);
}
function isValidDirective(action) {
    const validActions = ["enable", "disable", "disable-block", "disable-next"];
    return validActions.includes(action);
}
/**
 * Parse HTML document into a DOM tree.
 *
 * @public
 */
class Parser {
    /**
     * Create a new parser instance.
     *
     * @public
     * @param config - Configuration
     */
    constructor(config) {
        this.currentNamespace = "";
        this.event = new EventHandler();
        this.dom = null;
        this.metaTable = config.getMetaTable();
    }
    /**
     * Parse HTML markup.
     *
     * @public
     * @param source - HTML markup.
     * @returns DOM tree representing the HTML markup.
     */
    parseHtml(source) {
        var _a, _b, _c, _d;
        if (typeof source === "string") {
            source = {
                data: source,
                filename: "inline",
                line: 1,
                column: 1,
                offset: 0,
            };
        }
        /* trigger starting event */
        this.trigger("parse:begin", {
            location: null,
        });
        /* reset DOM in case there are multiple calls in the same session */
        this.dom = new DOMTree({
            filename: (_a = source.filename) !== null && _a !== void 0 ? _a : "",
            offset: (_b = source.offset) !== null && _b !== void 0 ? _b : 0,
            line: (_c = source.line) !== null && _c !== void 0 ? _c : 1,
            column: (_d = source.column) !== null && _d !== void 0 ? _d : 1,
            size: 0,
        });
        /* trigger any rules waiting for DOM load event */
        this.trigger("dom:load", {
            source,
            location: null,
        });
        const lexer = new Lexer();
        const tokenStream = lexer.tokenize(source);
        /* consume all tokens from the stream */
        let it = this.next(tokenStream);
        while (!it.done) {
            const token = it.value;
            this.consume(source, token, tokenStream);
            it = this.next(tokenStream);
        }
        /* resolve any dynamic meta element properties */
        this.dom.resolveMeta(this.metaTable);
        /* enable cache on root element, all children already have cached enabled */
        this.dom.root.cacheEnable();
        /* trigger any rules waiting for DOM ready */
        this.trigger("dom:ready", {
            document: this.dom,
            source,
            /* disable location for this event so rules can use implicit node location
             * instead */
            location: null,
        });
        /* trigger ending event */
        this.trigger("parse:end", {
            location: null,
        });
        return this.dom.root;
    }
    /**
     * Detect optional end tag.
     *
     * Some tags have optional end tags (e.g. <ul><li>foo<li>bar</ul> is
     * valid). The parser handles this by checking if the element on top of the
     * stack when is allowed to omit.
     */
    closeOptional(token) {
        var _a;
        /* if the element doesn't have metadata it cannot have optional end
         * tags. Period. */
        const active = this.dom.getActive();
        if (!((_a = active.meta) === null || _a === void 0 ? void 0 : _a.implicitClosed)) {
            return false;
        }
        const tagName = token.data[2];
        const open = !token.data[1];
        const meta = active.meta.implicitClosed;
        if (open) {
            /* a new element is opened, check if the new element should close the
             * previous */
            return meta.includes(tagName);
        }
        else {
            /* if we are explicitly closing the active element, ignore implicit */
            if (active.is(tagName)) {
                return false;
            }
            /* the parent element is closed, check if the active element would be
             * implicitly closed when parent is. */
            return Boolean(active.parent && active.parent.is(tagName) && meta.includes(active.tagName));
        }
    }
    /**
     * @internal
     */
    /* eslint-disable-next-line complexity -- there isn't really a good other way to structure this method (that is still readable) */
    consume(source, token, tokenStream) {
        switch (token.type) {
            case TokenType.UNICODE_BOM:
                /* ignore */
                break;
            case TokenType.TAG_OPEN:
                this.consumeTag(source, token, tokenStream);
                break;
            case TokenType.WHITESPACE:
                this.trigger("whitespace", {
                    text: token.data[0],
                    location: token.location,
                });
                this.appendText(token.data[0], token.location);
                break;
            case TokenType.DIRECTIVE:
                this.consumeDirective(token);
                break;
            case TokenType.CONDITIONAL:
                this.consumeConditional(token);
                break;
            case TokenType.COMMENT:
                this.consumeComment(token);
                break;
            case TokenType.DOCTYPE_OPEN:
                this.consumeDoctype(token, tokenStream);
                break;
            case TokenType.TEXT:
            case TokenType.TEMPLATING:
                this.appendText(token.data[0], token.location);
                break;
            case TokenType.EOF:
                this.closeTree(source, token.location);
                break;
        }
    }
    /**
     * @internal
     */
    /* eslint-disable-next-line complexity, sonarjs/cognitive-complexity -- technical debt, chould be refactored a bit */
    consumeTag(source, startToken, tokenStream) {
        const tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, startToken.location));
        const endToken = tokens.slice(-1)[0];
        const closeOptional = this.closeOptional(startToken);
        const parent = closeOptional ? this.dom.getActive().parent : this.dom.getActive();
        const node = HtmlElement.fromTokens(startToken, endToken, parent, this.metaTable, this.currentNamespace);
        const isStartTag = !startToken.data[1];
        const isClosing = !isStartTag || node.closed !== exports.NodeClosed.Open;
        const isForeign = node.meta && node.meta.foreign;
        /* if the previous tag to be implicitly closed by the current tag we close
         * it and pop it from the stack before continuing processing this tag */
        if (closeOptional) {
            const active = this.dom.getActive();
            active.closed = exports.NodeClosed.ImplicitClosed;
            this.closeElement(source, node, active, startToken.location);
            this.dom.popActive();
        }
        if (isStartTag) {
            this.dom.pushActive(node);
            this.trigger("tag:start", {
                target: node,
                location: startToken.location,
            });
        }
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            switch (token.type) {
                case TokenType.WHITESPACE:
                    break;
                case TokenType.ATTR_NAME:
                    this.consumeAttribute(source, node, token, tokens[i + 1]);
                    break;
            }
        }
        /* emit tag:ready unless this is a end tag */
        if (isStartTag) {
            this.trigger("tag:ready", {
                target: node,
                location: endToken.location,
            });
        }
        if (isClosing) {
            const active = this.dom.getActive();
            /* if this is not an open tag it is a close tag and thus we force it to be
             * one, in case it is detected as void */
            if (!isStartTag) {
                node.closed = exports.NodeClosed.EndTag;
            }
            this.closeElement(source, node, active, endToken.location);
            /* if this element is closed with an end tag but is would it will not be
             * closed again (it is already closed automatically since it is
             * void). Closing again will have side-effects as it will close the parent
             * and cause a mess later. */
            const voidClosed = !isStartTag && node.voidElement;
            if (!voidClosed) {
                this.dom.popActive();
            }
        }
        else if (isForeign) {
            /* consume the body of the foreign element so it won't be part of the
             * document (only the root foreign element is).  */
            this.discardForeignBody(source, node.tagName, tokenStream, startToken.location);
        }
    }
    /**
     * @internal
     */
    closeElement(source, node, active, location) {
        /* call processElement hook */
        this.processElement(active, source);
        /* trigger event for the closing of the element (the </> tag)*/
        const event = {
            target: node,
            previous: active,
            location,
        };
        this.trigger("tag:end", event);
        /* trigger event for for an element being fully constructed. Special care
         * for void elements explicit closed <input></input> */
        if (active && !active.isRootElement()) {
            this.trigger("element:ready", {
                target: active,
                location: active.location,
            });
        }
    }
    processElement(node, source) {
        var _a;
        /* enable cache on node now that it is fully constructed */
        node.cacheEnable();
        if ((_a = source.hooks) === null || _a === void 0 ? void 0 : _a.processElement) {
            const processElement = source.hooks.processElement;
            const metaTable = this.metaTable;
            const context = {
                getMetaFor(tagName) {
                    return metaTable.getMetaFor(tagName);
                },
            };
            processElement.call(context, node);
        }
    }
    /**
     * Discard tokens until the end tag for the foreign element is found.
     *
     * @internal
     */
    discardForeignBody(source, foreignTagName, tokenStream, errorLocation) {
        /* consume elements until the end tag for this foreign element is found */
        let nested = 1;
        let startToken;
        let endToken;
        do {
            /* search for tags */
            const tokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_OPEN, errorLocation));
            const [last] = tokens.slice(-1);
            const [, tagClosed, tagName] = last.data;
            /* special case: svg <title> and <desc> should be intact as it affects accessibility */
            if (!tagClosed && svgShouldRetainTag(foreignTagName, tagName)) {
                const oldNamespace = this.currentNamespace;
                this.currentNamespace = "svg";
                this.consumeTag(source, last, tokenStream);
                this.consumeUntilMatchingTag(source, tokenStream, tagName);
                this.currentNamespace = oldNamespace;
                continue;
            }
            /* keep going unless the new tag matches the foreign root element */
            if (tagName !== foreignTagName) {
                continue;
            }
            /* locate end token and determine if this is a self-closed tag */
            const endTokens = Array.from(this.consumeUntil(tokenStream, TokenType.TAG_CLOSE, last.location));
            endToken = endTokens.slice(-1)[0];
            const selfClosed = endToken.data[0] === "/>";
            /* since foreign element may be nested keep a count for the number of
             * opened/closed elements */
            if (tagClosed) {
                startToken = last;
                nested--;
            }
            else if (!selfClosed) {
                nested++;
            }
        } while (nested > 0);
        /* istanbul ignore next: this should never happen because `consumeUntil`
         * would have thrown errors however typescript does not know that */
        if (!startToken || !endToken) {
            return;
        }
        const active = this.dom.getActive();
        const node = HtmlElement.fromTokens(startToken, endToken, active, this.metaTable);
        this.closeElement(source, node, active, endToken.location);
        this.dom.popActive();
    }
    /**
     * @internal
     */
    consumeAttribute(source, node, token, next) {
        var _a;
        const keyLocation = this.getAttributeKeyLocation(token);
        const valueLocation = this.getAttributeValueLocation(next);
        const location = this.getAttributeLocation(token, next);
        const haveValue = isAttrValueToken(next);
        const attrData = {
            key: token.data[1],
            value: null,
            quote: null,
        };
        if (haveValue) {
            const [, , value, quote] = next.data;
            attrData.value = value;
            attrData.quote = quote !== null && quote !== void 0 ? quote : null;
        }
        /* get callback to process attributes, default is to just return attribute
         * data right away but a transformer may override it to allow aliasing
         * attributes, e.g ng-attr-foo or v-bind:foo */
        let processAttribute = (attr) => [attr];
        if ((_a = source.hooks) === null || _a === void 0 ? void 0 : _a.processAttribute) {
            processAttribute = source.hooks.processAttribute;
        }
        /* handle deprecated callbacks */
        let iterator;
        const legacy = processAttribute.call({}, attrData);
        if (typeof legacy[Symbol.iterator] !== "function") {
            /* AttributeData */
            iterator = [attrData];
        }
        else {
            /* Iterable<AttributeData> */
            iterator = legacy;
        }
        /* process attribute(s) */
        for (const attr of iterator) {
            const event = {
                target: node,
                key: attr.key,
                value: attr.value,
                quote: attr.quote,
                originalAttribute: attr.originalAttribute,
                location,
                keyLocation,
                valueLocation,
            };
            this.trigger("attr", event);
            node.setAttribute(attr.key, attr.value, keyLocation, valueLocation, attr.originalAttribute);
        }
    }
    /**
     * Takes attribute key token an returns location.
     */
    getAttributeKeyLocation(token) {
        return token.location;
    }
    /**
     * Take attribute value token and return a new location referring to only the
     * value.
     *
     * foo="bar"    foo='bar'    foo=bar    foo      foo=""
     *      ^^^          ^^^         ^^^    (null)   (null)
     */
    getAttributeValueLocation(token) {
        if (!token || token.type !== TokenType.ATTR_VALUE || token.data[2] === "") {
            return null;
        }
        const quote = token.data[3];
        if (quote) {
            return sliceLocation(token.location, 2, -1);
        }
        else {
            return sliceLocation(token.location, 1);
        }
    }
    /**
     * Take attribute key and value token an returns a new location referring to
     * an aggregate location covering key, quotes if present and value.
     */
    getAttributeLocation(key, value) {
        var _a;
        const begin = key.location;
        const end = value && value.type === TokenType.ATTR_VALUE ? value.location : undefined;
        return {
            filename: begin.filename,
            line: begin.line,
            column: begin.column,
            size: begin.size + ((_a = end === null || end === void 0 ? void 0 : end.size) !== null && _a !== void 0 ? _a : 0),
            offset: begin.offset,
        };
    }
    /**
     * @internal
     */
    consumeDirective(token) {
        const [text, preamble, action, separator1, directive, postamble] = token.data;
        if (!postamble.startsWith("]")) {
            throw new ParserError(token.location, `Missing end bracket "]" on directive "${text}"`);
        }
        const match = directive.match(/^(.*?)(?:(\s*(?:--|:)\s*)(.*))?$/);
        /* istanbul ignore next: should not be possible, would be emitted as comment token */
        if (!match) {
            throw new Error(`Failed to parse directive "${text}"`);
        }
        if (!isValidDirective(action)) {
            throw new ParserError(token.location, `Unknown directive "${action}"`);
        }
        const [, data, separator2, comment] = match;
        const prefix = "html-validate-";
        /* <!-- [html-validate-action options -- comment] -->
         *                     ^      ^          ^--------------- comment offset
         *                     |      \-------------------------- options offset
         *                     \--------------------------------- action offset
         */
        const actionOffset = preamble.length;
        const optionsOffset = actionOffset + action.length + separator1.length;
        const commentOffset = optionsOffset + data.length + (separator2 || "").length;
        const location = sliceLocation(token.location, preamble.length - prefix.length - 1, -postamble.length + 1);
        const actionLocation = sliceLocation(token.location, actionOffset, actionOffset + action.length);
        const optionsLocation = data
            ? sliceLocation(token.location, optionsOffset, optionsOffset + data.length)
            : undefined;
        const commentLocation = comment
            ? sliceLocation(token.location, commentOffset, commentOffset + comment.length)
            : undefined;
        this.trigger("directive", {
            action,
            data,
            comment: comment || "",
            location,
            actionLocation,
            optionsLocation,
            commentLocation,
        });
    }
    /**
     * Consumes conditional comment in tag form.
     *
     * See also the related [[consumeCommend]] method.
     *
     * @internal
     */
    consumeConditional(token) {
        const element = this.dom.getActive();
        this.trigger("conditional", {
            condition: token.data[1],
            location: token.location,
            parent: element,
        });
    }
    /**
     * Consumes comment token.
     *
     * Tries to find IE conditional comments and emits conditional token if
     * found. See also the related [[consumeConditional]] method.
     *
     * @internal
     */
    consumeComment(token) {
        const comment = token.data[0];
        const element = this.dom.getActive();
        for (const conditional of parseConditionalComment(comment, token.location)) {
            this.trigger("conditional", {
                condition: conditional.expression,
                location: conditional.location,
                parent: element,
            });
        }
    }
    /**
     * Consumes doctype tokens. Emits doctype event.
     *
     * @internal
     */
    consumeDoctype(startToken, tokenStream) {
        const tokens = Array.from(this.consumeUntil(tokenStream, TokenType.DOCTYPE_CLOSE, startToken.location));
        /* first token is the doctype, second is the closing ">" */
        const doctype = tokens[0];
        const value = doctype.data[0];
        this.dom.doctype = value;
        this.trigger("doctype", {
            tag: startToken.data[1],
            value,
            valueLocation: tokens[0].location,
            location: startToken.location,
        });
    }
    /**
     * Return a list of tokens found until the expected token was found.
     *
     * @internal
     * @param errorLocation - What location to use if an error occurs
     */
    *consumeUntil(tokenStream, search, errorLocation) {
        let it = this.next(tokenStream);
        while (!it.done) {
            const token = it.value;
            yield token;
            if (token.type === search)
                return;
            it = this.next(tokenStream);
        }
        throw new ParserError(errorLocation, `stream ended before ${TokenType[search]} token was found`);
    }
    /**
     * Consumes tokens until a matching close-tag is found. Tags are appended to
     * the document.
     *
     * @internal
     */
    consumeUntilMatchingTag(source, tokenStream, searchTag) {
        let numOpen = 1;
        let it = this.next(tokenStream);
        while (!it.done) {
            const token = it.value;
            this.consume(source, token, tokenStream);
            if (token.type === TokenType.TAG_OPEN) {
                const [, close, tagName] = token.data;
                if (tagName === searchTag) {
                    if (close) {
                        numOpen--;
                    }
                    else {
                        numOpen++;
                    }
                    if (numOpen === 0) {
                        return;
                    }
                }
            }
            it = this.next(tokenStream);
        }
    }
    next(tokenStream) {
        const it = tokenStream.next();
        if (!it.done) {
            const token = it.value;
            this.trigger("token", {
                location: token.location,
                type: token.type,
                data: Array.from(token.data),
                token,
            });
        }
        return it;
    }
    on(event, listener) {
        return this.event.on(event, listener);
    }
    once(event, listener) {
        return this.event.once(event, listener);
    }
    /**
     * Defer execution. Will call function sometime later.
     *
     * @internal
     * @param cb - Callback to execute later.
     */
    defer(cb) {
        this.event.once("*", cb);
    }
    trigger(event, data) {
        if (typeof data.location === "undefined") {
            throw new Error("Triggered event must contain location");
        }
        this.event.trigger(event, data);
    }
    /**
     * @internal
     */
    getEventHandler() {
        return this.event;
    }
    /**
     * Appends a text node to the current element on the stack.
     */
    appendText(text, location) {
        this.dom.getActive().appendText(text, location);
    }
    /**
     * Trigger close events for any still open elements.
     */
    closeTree(source, location) {
        let active;
        while ((active = this.dom.getActive()) && !active.isRootElement()) {
            this.closeElement(source, null, active, location);
            this.dom.popActive();
        }
    }
}

function freeze(src) {
    return {
        ...src,
        selector: src.selector(),
    };
}
/**
 * @public
 */
class Reporter {
    constructor() {
        this.result = {};
    }
    /**
     * Merge two or more reports into a single one.
     */
    static merge(reports) {
        const valid = reports.every((report) => report.valid);
        const merged = {};
        reports.forEach((report) => {
            report.results.forEach((result) => {
                const key = result.filePath;
                if (key in merged) {
                    merged[key].messages = [...merged[key].messages, ...result.messages];
                }
                else {
                    merged[key] = { ...result };
                }
            });
        });
        const results = Object.values(merged).map((result) => {
            /* recalculate error- and warning-count */
            result.errorCount = countErrors(result.messages);
            result.warningCount = countWarnings(result.messages);
            return result;
        });
        return {
            valid,
            results,
            errorCount: sumErrors(results),
            warningCount: sumWarnings(results),
        };
    }
    add(rule, message, severity, node, location, context) {
        var _a;
        if (!(location.filename in this.result)) {
            this.result[location.filename] = [];
        }
        const ruleUrl = (_a = rule.documentation(context)) === null || _a === void 0 ? void 0 : _a.url;
        const entry = {
            ruleId: rule.name,
            severity,
            message,
            offset: location.offset,
            line: location.line,
            column: location.column,
            size: location.size || 0,
            selector() {
                return node ? node.generateSelector() : null;
            },
        };
        if (ruleUrl) {
            entry.ruleUrl = ruleUrl;
        }
        if (context) {
            entry.context = context;
        }
        this.result[location.filename].push(entry);
    }
    addManual(filename, message) {
        if (!(filename in this.result)) {
            this.result[filename] = [];
        }
        this.result[filename].push(message);
    }
    save(sources) {
        const report = {
            valid: this.isValid(),
            results: Object.keys(this.result).map((filePath) => {
                var _a;
                const messages = Array.from(this.result[filePath], freeze).sort(messageSort);
                const source = (sources !== null && sources !== void 0 ? sources : []).find((source) => { var _a; return filePath === ((_a = source.filename) !== null && _a !== void 0 ? _a : ""); });
                return {
                    filePath,
                    messages,
                    errorCount: countErrors(messages),
                    warningCount: countWarnings(messages),
                    source: source ? (_a = source.originalData) !== null && _a !== void 0 ? _a : source.data : null,
                };
            }),
            errorCount: 0,
            warningCount: 0,
        };
        report.errorCount = sumErrors(report.results);
        report.warningCount = sumWarnings(report.results);
        return report;
    }
    isValid() {
        const numErrors = Object.values(this.result).reduce((sum, messages) => {
            return sum + countErrors(messages);
        }, 0);
        return numErrors === 0;
    }
}
function countErrors(messages) {
    return messages.filter((m) => m.severity === Number(exports.Severity.ERROR)).length;
}
function countWarnings(messages) {
    return messages.filter((m) => m.severity === Number(exports.Severity.WARN)).length;
}
function sumErrors(results) {
    return results.reduce((sum, result) => {
        return sum + result.errorCount;
    }, 0);
}
function sumWarnings(results) {
    return results.reduce((sum, result) => {
        return sum + result.warningCount;
    }, 0);
}
function messageSort(a, b) {
    if (a.line < b.line) {
        return -1;
    }
    if (a.line > b.line) {
        return 1;
    }
    if (a.column < b.column) {
        return -1;
    }
    if (a.column > b.column) {
        return 1;
    }
    return 0;
}

let blockerCounter = 1;
/**
 * Creates a new rule blocker for using when blocking rules from generating
 * errors.
 *
 * @internal
 */
function createBlocker() {
    const id = blockerCounter++;
    return id;
}

/**
 * @internal
 */
class Engine {
    constructor(config, ParserClass) {
        this.report = new Reporter();
        this.config = config;
        this.ParserClass = ParserClass;
        /* initialize plugins and rules */
        const result = this.initPlugins(this.config);
        this.availableRules = {
            ...rules,
            ...result.availableRules,
        };
    }
    /**
     * Lint sources and return report
     *
     * @param sources - Sources to lint.
     * @returns Report output.
     */
    lint(sources) {
        for (const source of sources) {
            /* create parser for source */
            const parser = this.instantiateParser();
            /* setup plugins and rules */
            const { rules } = this.setupPlugins(source, this.config, parser);
            const noUnusedDisable = rules["no-unused-disable"];
            const directiveContext = {
                rules,
                reportUnused(rules, unused, options, location) {
                    if (noUnusedDisable && !rules.has(noUnusedDisable.name)) {
                        noUnusedDisable.reportUnused(unused, options, location);
                    }
                },
            };
            /* create a faux location at the start of the stream for the next events */
            const location = {
                filename: source.filename,
                line: 1,
                column: 1,
                offset: 0,
                size: 1,
            };
            /* trigger configuration ready event */
            const configEvent = {
                location,
                config: this.config,
                rules,
            };
            parser.trigger("config:ready", configEvent);
            /* trigger source ready event */
            const { hooks: _, ...sourceData } = source;
            const sourceEvent = {
                location,
                source: sourceData,
            };
            parser.trigger("source:ready", sourceEvent);
            /* setup directive handling */
            parser.on("directive", (_, event) => {
                this.processDirective(event, parser, directiveContext);
            });
            /* parse token stream */
            try {
                parser.parseHtml(source);
            }
            catch (e) {
                if (e instanceof InvalidTokenError || e instanceof ParserError) {
                    this.reportError("parser-error", e.message, e.location);
                }
                else {
                    throw e;
                }
            }
        }
        /* generate results from report */
        return this.report.save(sources);
    }
    /**
     * Returns a list of all events generated while parsing the source.
     *
     * For verbosity, token events are ignored (use [[dumpTokens]] to inspect
     * token stream).
     */
    dumpEvents(source) {
        const parser = this.instantiateParser();
        const lines = [];
        parser.on("*", (event, data) => {
            /* ignore token events as it becomes to verbose */
            if (event === "token") {
                return;
            }
            lines.push({ event, data });
        });
        source.forEach((src) => parser.parseHtml(src));
        return lines;
    }
    dumpTokens(source) {
        var _a;
        const lexer = new Lexer();
        const lines = [];
        for (const src of source) {
            for (const token of lexer.tokenize(src)) {
                const data = (_a = token.data[0]) !== null && _a !== void 0 ? _a : "";
                lines.push({
                    token: TokenType[token.type],
                    data,
                    location: `${token.location.filename}:${token.location.line}:${token.location.column}`,
                });
            }
        }
        return lines;
    }
    dumpTree(source) {
        /* @todo handle dumping each tree */
        const parser = this.instantiateParser();
        const document = parser.parseHtml(source[0]);
        const lines = [];
        function decoration(node) {
            let output = "";
            if (node.id) {
                output += `#${node.id}`;
            }
            if (node.hasAttribute("class")) {
                output += `.${node.classList.join(".")}`;
            }
            return output;
        }
        function writeNode(node, level, sibling) {
            if (node.parent) {
                const indent = "  ".repeat(level - 1);
                const l = node.childElements.length > 0 ? "" : "";
                const b = sibling < node.parent.childElements.length - 1 ? "" : "";
                lines.push(`${indent}${b}${l} ${node.tagName}${decoration(node)}`);
            }
            else {
                lines.push("(root)");
            }
            node.childElements.forEach((child, index) => {
                writeNode(child, level + 1, index);
            });
        }
        writeNode(document, 0, 0);
        return lines;
    }
    /**
     * Get rule documentation.
     */
    getRuleDocumentation({ ruleId, context, }) {
        const rules = this.config.getRules();
        const ruleData = rules.get(ruleId);
        if (ruleData) {
            const [, options] = ruleData;
            const rule = this.instantiateRule(ruleId, options);
            return rule.documentation(context);
        }
        else {
            return null;
        }
    }
    /**
     * Create a new parser instance with the current configuration.
     *
     * @internal
     */
    instantiateParser() {
        return new this.ParserClass(this.config);
    }
    processDirective(event, parser, context) {
        var _a;
        const rules = event.data
            .split(",")
            .map((name) => name.trim())
            .map((name) => context.rules[name])
            .filter((rule) => rule); /* filter out missing rules */
        /* istanbul ignore next: option must be present or there would be no rules to disable */
        const location = (_a = event.optionsLocation) !== null && _a !== void 0 ? _a : event.location;
        switch (event.action) {
            case "enable":
                this.processEnableDirective(rules, parser);
                break;
            case "disable":
                this.processDisableDirective(rules, parser);
                break;
            case "disable-block":
                this.processDisableBlockDirective(context, rules, parser, event.data, location);
                break;
            case "disable-next":
                this.processDisableNextDirective(context, rules, parser, event.data, location);
                break;
        }
    }
    processEnableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(true);
            if (rule.getSeverity() === exports.Severity.DISABLED) {
                rule.setServerity(exports.Severity.ERROR);
            }
        }
        /* enable rules on node */
        parser.on("tag:start", (event, data) => {
            data.target.enableRules(rules.map((rule) => rule.name));
        });
    }
    processDisableDirective(rules, parser) {
        for (const rule of rules) {
            rule.setEnabled(false);
        }
        /* disable rules on node */
        parser.on("tag:start", (event, data) => {
            data.target.disableRules(rules.map((rule) => rule.name));
        });
    }
    processDisableBlockDirective(context, rules, parser, options, location) {
        const ruleIds = new Set(rules.map((it) => it.name));
        const unused = new Set(ruleIds);
        const blocker = createBlocker();
        let directiveBlock = null;
        for (const rule of rules) {
            rule.block(blocker);
        }
        const unregisterOpen = parser.on("tag:start", (event, data) => {
            var _a, _b;
            /* wait for a tag to open and find the current block by using its parent */
            if (directiveBlock === null) {
                /* istanbul ignore next: there will always be a parent (root element if
                 * nothing else) but typescript doesn't know that */
                directiveBlock = (_b = (_a = data.target.parent) === null || _a === void 0 ? void 0 : _a.unique) !== null && _b !== void 0 ? _b : null;
            }
            /* disable rules directly on the node so it will be recorded for later,
             * more specifically when using the domtree to trigger errors */
            data.target.blockRules(ruleIds, blocker);
        });
        const unregisterClose = parser.on("tag:end", (event, data) => {
            /* if the directive is the last thing in a block no id would be set */
            const lastNode = directiveBlock === null;
            /* test if the block is being closed by checking the parent of the block
             * element is being closed */
            const parentClosed = directiveBlock === data.previous.unique;
            /* remove listeners and restore state */
            if (lastNode || parentClosed) {
                unregisterClose();
                unregisterOpen();
                for (const rule of rules) {
                    rule.unblock(blocker);
                }
            }
        });
        parser.on("rule:error", (event, data) => {
            if (data.blockers.includes(blocker)) {
                unused.delete(data.ruleId);
            }
        });
        parser.on("parse:end", () => {
            context.reportUnused(ruleIds, unused, options, location);
        });
    }
    processDisableNextDirective(context, rules, parser, options, location) {
        const ruleIds = new Set(rules.map((it) => it.name));
        const unused = new Set(ruleIds);
        const blocker = createBlocker();
        for (const rule of rules) {
            rule.block(blocker);
        }
        /* block rules directly on the node so it will be recorded for later,
         * more specifically when using the domtree to trigger errors */
        const unregister = parser.on("tag:start", (event, data) => {
            data.target.blockRules(ruleIds, blocker);
        });
        parser.on("rule:error", (event, data) => {
            if (data.blockers.includes(blocker)) {
                unused.delete(data.ruleId);
            }
        });
        parser.on("parse:end", () => {
            context.reportUnused(ruleIds, unused, options, location);
        });
        /* disable directive after next event occurs */
        parser.once("tag:ready, tag:end, attr", () => {
            unregister();
            parser.defer(() => {
                for (const rule of rules) {
                    rule.unblock(blocker);
                }
            });
        });
    }
    /*
     * Initialize all plugins. This should only be done once for all sessions.
     */
    initPlugins(config) {
        for (const plugin of config.getPlugins()) {
            if (plugin.init) {
                plugin.init();
            }
        }
        return {
            availableRules: this.initRules(config),
        };
    }
    /**
     * Initializes all rules from plugins and returns an object with a mapping
     * between rule name and its constructor.
     */
    initRules(config) {
        var _a;
        const availableRules = {};
        for (const plugin of config.getPlugins()) {
            for (const [name, rule] of Object.entries((_a = plugin.rules) !== null && _a !== void 0 ? _a : {})) {
                if (!rule)
                    continue;
                availableRules[name] = rule;
            }
        }
        return availableRules;
    }
    /**
     * Setup all plugins for this session.
     */
    setupPlugins(source, config, parser) {
        const eventHandler = parser.getEventHandler();
        for (const plugin of config.getPlugins()) {
            if (plugin.setup) {
                plugin.setup(source, eventHandler);
            }
        }
        return {
            rules: this.setupRules(config, parser),
        };
    }
    /**
     * Load and setup all rules for current configuration.
     */
    setupRules(config, parser) {
        const rules = {};
        for (const [ruleId, [severity, options]] of config.getRules().entries()) {
            rules[ruleId] = this.loadRule(ruleId, config, severity, options, parser, this.report);
        }
        return rules;
    }
    /**
     * Load and setup a rule using current config.
     */
    loadRule(ruleId, config, severity, options, parser, report) {
        const meta = config.getMetaTable();
        const rule = this.instantiateRule(ruleId, options);
        rule.name = ruleId;
        rule.init(parser, report, severity, meta);
        /* call setup callback if present */
        if (rule.setup) {
            rule.setup();
        }
        return rule;
    }
    instantiateRule(name, options) {
        if (this.availableRules[name]) {
            const RuleConstructor = this.availableRules[name];
            return new RuleConstructor(options);
        }
        else {
            return this.missingRule(name);
        }
    }
    missingRule(name) {
        return new (class MissingRule extends Rule {
            setup() {
                this.on("dom:load", () => {
                    this.report(null, `Definition for rule '${name}' was not found`);
                });
            }
        })();
    }
    reportError(ruleId, message, location) {
        this.report.addManual(location.filename, {
            ruleId,
            severity: exports.Severity.ERROR,
            message,
            offset: location.offset,
            line: location.line,
            column: location.column,
            size: location.size,
            selector: () => null,
        });
    }
}

const defaultResolvers = [];
function hasResolver(value) {
    return Array.isArray(value[0]);
}
/**
 * The static configuration loader does not do any per-handle lookup. Only the
 * global or per-call configuration is used.
 *
 * In practice this means no configuration is fetched by traversing the
 * filesystem.
 *
 * @public
 */
class StaticConfigLoader extends ConfigLoader {
    constructor(...args) {
        if (hasResolver(args)) {
            const [resolvers, config] = args;
            super(resolvers, config);
        }
        else {
            const [config] = args;
            super(defaultResolvers, config);
        }
    }
    getConfigFor(_handle, configOverride) {
        const override = this.loadFromObject(configOverride !== null && configOverride !== void 0 ? configOverride : {});
        if (override.isRootFound()) {
            override.init();
            return override.resolve();
        }
        const merged = this.globalConfig.merge(this.resolvers, override);
        merged.init();
        return merged.resolve();
    }
    flushCache() {
        /* do nothing */
    }
    defaultConfig() {
        return this.loadFromObject({
            extends: ["html-validate:recommended"],
            elements: ["html5"],
        });
    }
}

function isSourceHooks(value) {
    if (!value || typeof value === "string") {
        return false;
    }
    return Boolean(value.processAttribute || value.processElement);
}
function isConfigData(value) {
    if (!value || typeof value === "string") {
        return false;
    }
    return !(value.processAttribute || value.processElement);
}
/**
 * Primary API for using HTML-validate.
 *
 * Provides high-level abstractions for common operations.
 *
 * @public
 */
class HtmlValidate {
    constructor(arg) {
        const [loader, config] = arg instanceof ConfigLoader ? [arg, undefined] : [undefined, arg];
        this.configLoader = loader !== null && loader !== void 0 ? loader : new StaticConfigLoader(config);
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    validateString(str, arg1, arg2, arg3) {
        const filename = typeof arg1 === "string" ? arg1 : "inline";
        const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined;
        const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
        const source = {
            data: str,
            filename,
            line: 1,
            column: 1,
            offset: 0,
            hooks,
        };
        return this.validateSource(source, options);
    }
    /* eslint-enable @typescript-eslint/unified-signatures */
    validateStringSync(str, arg1, arg2, arg3) {
        const filename = typeof arg1 === "string" ? arg1 : "inline";
        const options = isConfigData(arg1) ? arg1 : isConfigData(arg2) ? arg2 : undefined;
        const hooks = isSourceHooks(arg1) ? arg1 : isSourceHooks(arg2) ? arg2 : arg3;
        const source = {
            data: str,
            filename,
            line: 1,
            column: 1,
            offset: 0,
            hooks,
        };
        return this.validateSourceSync(source, options);
    }
    /**
     * Parse and validate HTML from [[Source]].
     *
     * @public
     * @param input - Source to parse.
     * @returns Report output.
     */
    async validateSource(input, configOverride) {
        const config = await this.getConfigFor(input.filename, configOverride);
        const source = config.transformSource(input);
        const engine = new Engine(config, Parser);
        return engine.lint(source);
    }
    /**
     * Parse and validate HTML from [[Source]].
     *
     * @public
     * @param input - Source to parse.
     * @returns Report output.
     */
    validateSourceSync(input, configOverride) {
        const config = this.getConfigForSync(input.filename, configOverride);
        const source = config.transformSource(input);
        const engine = new Engine(config, Parser);
        return engine.lint(source);
    }
    /**
     * Parse and validate HTML from file.
     *
     * @public
     * @param filename - Filename to read and parse.
     * @returns Report output.
     */
    async validateFile(filename) {
        const config = await this.getConfigFor(filename);
        const source = config.transformFilename(filename);
        const engine = new Engine(config, Parser);
        return Promise.resolve(engine.lint(source));
    }
    /**
     * Parse and validate HTML from file.
     *
     * @public
     * @param filename - Filename to read and parse.
     * @returns Report output.
     */
    validateFileSync(filename) {
        const config = this.getConfigForSync(filename);
        const source = config.transformFilename(filename);
        const engine = new Engine(config, Parser);
        return engine.lint(source);
    }
    /**
     * Parse and validate HTML from multiple files. Result is merged together to a
     * single report.
     *
     * @param filenames - Filenames to read and parse.
     * @returns Report output.
     */
    async validateMultipleFiles(filenames) {
        const report = Reporter.merge(filenames.map((filename) => this.validateFileSync(filename)));
        return Promise.resolve(report);
    }
    /**
     * Parse and validate HTML from multiple files. Result is merged together to a
     * single report.
     *
     * @param filenames - Filenames to read and parse.
     * @returns Report output.
     */
    validateMultipleFilesSync(filenames) {
        return Reporter.merge(filenames.map((filename) => this.validateFileSync(filename)));
    }
    /**
     * Returns true if the given filename can be validated.
     *
     * A file is considered to be validatable if the extension is `.html` or if a
     * transformer matches the filename.
     *
     * This is mostly useful for tooling to determine whenever to validate the
     * file or not. CLI tools will run on all the given files anyway.
     */
    async canValidate(filename) {
        /* .html is always supported */
        if (filename.toLowerCase().endsWith(".html")) {
            return true;
        }
        /* test if there is a matching transformer */
        const config = await this.getConfigFor(filename);
        return config.canTransform(filename);
    }
    /**
     * Returns true if the given filename can be validated.
     *
     * A file is considered to be validatable if the extension is `.html` or if a
     * transformer matches the filename.
     *
     * This is mostly useful for tooling to determine whenever to validate the
     * file or not. CLI tools will run on all the given files anyway.
     */
    canValidateSync(filename) {
        /* .html is always supported */
        if (filename.toLowerCase().endsWith(".html")) {
            return true;
        }
        /* test if there is a matching transformer */
        const config = this.getConfigForSync(filename);
        return config.canTransform(filename);
    }
    /**
     * Tokenize filename and output all tokens.
     *
     * Using CLI this is enabled with `--dump-tokens`. Mostly useful for
     * debugging.
     *
     * @internal
     * @param filename - Filename to tokenize.
     */
    dumpTokens(filename) {
        const config = this.getConfigForSync(filename);
        const source = config.transformFilename(filename);
        const engine = new Engine(config, Parser);
        return engine.dumpTokens(source);
    }
    /**
     * Parse filename and output all events.
     *
     * Using CLI this is enabled with `--dump-events`. Mostly useful for
     * debugging.
     *
     * @internal
     * @param filename - Filename to dump events from.
     */
    dumpEvents(filename) {
        const config = this.getConfigForSync(filename);
        const source = config.transformFilename(filename);
        const engine = new Engine(config, Parser);
        return engine.dumpEvents(source);
    }
    /**
     * Parse filename and output DOM tree.
     *
     * Using CLI this is enabled with `--dump-tree`. Mostly useful for
     * debugging.
     *
     * @internal
     * @param filename - Filename to dump DOM tree from.
     */
    dumpTree(filename) {
        const config = this.getConfigForSync(filename);
        const source = config.transformFilename(filename);
        const engine = new Engine(config, Parser);
        return engine.dumpTree(source);
    }
    /**
     * Transform filename and output source data.
     *
     * Using CLI this is enabled with `--dump-source`. Mostly useful for
     * debugging.
     *
     * @internal
     * @param filename - Filename to dump source from.
     */
    dumpSource(filename) {
        const config = this.getConfigForSync(filename);
        const sources = config.transformFilename(filename);
        return sources.reduce((result, source) => {
            result.push(`Source ${source.filename}@${source.line}:${source.column} (offset: ${source.offset})`);
            if (source.transformedBy) {
                result.push("Transformed by:");
                result = result.concat(source.transformedBy.reverse().map((name) => ` - ${name}`));
            }
            if (source.hooks && Object.keys(source.hooks).length > 0) {
                result.push("Hooks");
                for (const [key, present] of Object.entries(source.hooks)) {
                    if (present) {
                        result.push(` - ${key}`);
                    }
                }
            }
            result.push("---");
            result = result.concat(source.data.split("\n"));
            result.push("---");
            return result;
        }, []);
    }
    /**
     * Get effective configuration schema.
     */
    getConfigurationSchema() {
        return configurationSchema;
    }
    /**
     * Get effective metadata element schema.
     *
     * If a filename is given the configured plugins can extend the
     * schema. Filename must not be an existing file or a filetype normally
     * handled by html-validate but the path will be used when resolving
     * configuration. As a rule-of-thumb, set it to the elements json file.
     */
    async getElementsSchema(filename) {
        const config = await this.getConfigFor(filename !== null && filename !== void 0 ? filename : "inline");
        const metaTable = config.getMetaTable();
        return metaTable.getJSONSchema();
    }
    /**
     * Get effective metadata element schema.
     *
     * If a filename is given the configured plugins can extend the
     * schema. Filename must not be an existing file or a filetype normally
     * handled by html-validate but the path will be used when resolving
     * configuration. As a rule-of-thumb, set it to the elements json file.
     */
    getElementsSchemaSync(filename) {
        const config = this.getConfigForSync(filename !== null && filename !== void 0 ? filename : "inline");
        const metaTable = config.getMetaTable();
        return metaTable.getJSONSchema();
    }
    async getContextualDocumentation(message, filenameOrConfig = "inline") {
        const config = typeof filenameOrConfig === "string"
            ? await this.getConfigFor(filenameOrConfig)
            : await filenameOrConfig;
        const engine = new Engine(config, Parser);
        return engine.getRuleDocumentation(message);
    }
    getContextualDocumentationSync(message, filenameOrConfig = "inline") {
        const config = typeof filenameOrConfig === "string"
            ? this.getConfigForSync(filenameOrConfig)
            : filenameOrConfig;
        const engine = new Engine(config, Parser);
        return engine.getRuleDocumentation(message);
    }
    /**
     * Get contextual documentation for the given rule.
     *
     * Typical usage:
     *
     * ```js
     * const report = await htmlvalidate.validateFile("my-file.html");
     * for (const result of report.results){
     *   const config = await htmlvalidate.getConfigFor(result.filePath);
     *   for (const message of result.messages){
     *     const documentation = await htmlvalidate.getRuleDocumentation(message.ruleId, config, message.context);
     *     // do something with documentation
     *   }
     * }
     * ```
     *
     * @public
     * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentation]] instead.
     * @param ruleId - Rule to get documentation for.
     * @param config - If set it provides more accurate description by using the
     * correct configuration for the file.
     * @param context - If set to `Message.context` some rules can provide
     * contextual details and suggestions.
     */
    async getRuleDocumentation(ruleId, config = null, context = null) {
        const c = config !== null && config !== void 0 ? config : this.getConfigFor("inline");
        const engine = new Engine(await c, Parser);
        return engine.getRuleDocumentation({ ruleId, context });
    }
    /**
     * Get contextual documentation for the given rule.
     *
     * Typical usage:
     *
     * ```js
     * const report = htmlvalidate.validateFileSync("my-file.html");
     * for (const result of report.results){
     *   const config = htmlvalidate.getConfigForSync(result.filePath);
     *   for (const message of result.messages){
     *     const documentation = htmlvalidate.getRuleDocumentationSync(message.ruleId, config, message.context);
     *     // do something with documentation
     *   }
     * }
     * ```
     *
     * @public
     * @deprecated Deprecated since 8.0.0, use [[getContextualDocumentationSync]] instead.
     * @param ruleId - Rule to get documentation for.
     * @param config - If set it provides more accurate description by using the
     * correct configuration for the file.
     * @param context - If set to `Message.context` some rules can provide
     * contextual details and suggestions.
     */
    getRuleDocumentationSync(ruleId, config = null, context = null) {
        const c = config !== null && config !== void 0 ? config : this.getConfigForSync("inline");
        const engine = new Engine(c, Parser);
        return engine.getRuleDocumentation({ ruleId, context });
    }
    /**
     * Create a parser configured for given filename.
     *
     * @internal
     * @param source - Source to use.
     */
    async getParserFor(source) {
        const config = await this.getConfigFor(source.filename);
        return new Parser(config);
    }
    /**
     * Get configuration for given filename.
     *
     * See [[FileSystemConfigLoader]] for details.
     *
     * @public
     * @param filename - Filename to get configuration for.
     * @param configOverride - Configuration to apply last.
     */
    getConfigFor(filename, configOverride) {
        const config = this.configLoader.getConfigFor(filename, configOverride);
        return Promise.resolve(config);
    }
    /**
     * Get configuration for given filename.
     *
     * See [[FileSystemConfigLoader]] for details.
     *
     * @public
     * @param filename - Filename to get configuration for.
     * @param configOverride - Configuration to apply last.
     */
    getConfigForSync(filename, configOverride) {
        return this.configLoader.getConfigFor(filename, configOverride);
    }
    /**
     * Flush configuration cache. Clears full cache unless a filename is given.
     *
     * See [[FileSystemConfigLoader]] for details.
     *
     * @public
     * @param filename - If set, only flush cache for given filename.
     */
    flushConfigCache(filename) {
        this.configLoader.flushCache(filename);
    }
}

/* generated file, changes will be overwritten */
/** @public */
const name = "html-validate";
/** @public */
const version = "8.4.1";
/** @public */
const bugs = "https://gitlab.com/html-validate/html-validate/issues/new";

/**
 * Helper function to assist IDE with completion and type-checking.
 *
 * @public
 */
function definePlugin(plugin) {
    return plugin;
}

const ruleIds = new Set(Object.keys(rules));
/**
 * Returns true if given ruleId is an existing builtin rule. It does not handle
 * rules loaded via plugins.
 *
 * Can be used to create forward/backward compatibility by checking if a rule
 * exists to enable/disable it.
 *
 * @public
 * @param ruleId - Rule id to check
 * @returns `true` if rule exists
 */
function ruleExists(ruleId) {
    return ruleIds.has(ruleId);
}

const entities = {
    ">": "&gt;",
    "<": "&lt;",
    "'": "&apos;",
    '"': "&quot;",
    "&": "&amp;",
};
function xmlescape(src) {
    return src.toString().replace(/[><'"&]/g, (match) => {
        return entities[match];
    });
}
function getMessageType(message) {
    switch (message.severity) {
        case 2:
            return "error";
        case 1:
            return "warning";
        default:
            return "error";
    }
}
function checkstyleFormatter(results) {
    let output = "";
    output += `<?xml version="1.0" encoding="utf-8"?>\n`;
    output += `<checkstyle version="4.3">\n`;
    results.forEach((result) => {
        const messages = result.messages;
        output += `  <file name="${xmlescape(result.filePath)}">\n`;
        messages.forEach((message) => {
            const ruleId = xmlescape(`htmlvalidate.rules.${message.ruleId}`);
            output += "    ";
            output += [
                `<error line="${xmlescape(message.line)}"`,
                `column="${xmlescape(message.column)}"`,
                `severity="${xmlescape(getMessageType(message))}"`,
                `message="${xmlescape(message.message)} (${message.ruleId})"`,
                `source="${ruleId}" />`,
            ].join(" ");
            output += "\n";
        });
        output += "  </file>\n";
    });
    output += "</checkstyle>\n";
    return output;
}
const formatter$3 = checkstyleFormatter;
var checkstyle = formatter$3;

const defaults = {
    showLink: true,
    showSummary: true,
    showSelector: false,
};
/**
 * Codeframe formatter based on ESLint codeframe.
 */
/**
 * Given a word and a count, append an s if count is not one.
 * @param word - A word in its singular form.
 * @param count - A number controlling whether word should be pluralized.
 * @returns The original word with an s on the end if count is not one.
 */
function pluralize(word, count) {
    return count === 1 ? word : `${word}s`;
}
/**
 * Gets a formatted relative file path from an absolute path and a line/column in the file.
 * @param filePath - The absolute file path to format.
 * @param line - The line from the file to use for formatting.
 * @param column -The column from the file to use for formatting.
 * @returns The formatted file path.
 */
function formatFilePath(filePath, line, column) {
    /* istanbul ignore next: safety check from original implementation */
    if (line && column) {
        filePath += `:${line}:${column}`;
    }
    return kleur__default.default.green(filePath);
}
function getStartLocation(message) {
    return {
        line: message.line,
        column: message.column,
    };
}
function getEndLocation(message, source) {
    let line = message.line;
    let column = message.column;
    for (let i = 0; i < message.size; i++) {
        if (source.charAt(message.offset + i) === "\n") {
            line++;
            column = 0;
        }
        else {
            column++;
        }
    }
    return { line, column };
}
/**
 * Gets the formatted output for a given message.
 * @param message - The object that represents this message.
 * @param parentResult - The result object that this message belongs to.
 * @returns The formatted output.
 */
function formatMessage(message, parentResult, options) {
    var _a;
    const type = message.severity === 2 ? kleur__default.default.red("error") : kleur__default.default.yellow("warning");
    const msg = `${kleur__default.default.bold(message.message.replace(/([^ ])\.$/, "$1"))}`;
    const ruleId = kleur__default.default.dim(`(${message.ruleId})`);
    const filePath = formatFilePath(parentResult.filePath, message.line, message.column);
    const sourceCode = parentResult.source;
    /* istanbul ignore next: safety check from original implementation */
    const firstLine = [
        `${type}:`,
        `${msg}`,
        ruleId ? `${ruleId}` : "",
        sourceCode ? `at ${filePath}:` : `at ${filePath}`,
    ]
        .filter(String)
        .join(" ");
    const result = [firstLine];
    /* istanbul ignore next: safety check from original implementation */
    if (sourceCode) {
        result.push(codeFrame.codeFrameColumns(sourceCode, {
            start: getStartLocation(message),
            end: getEndLocation(message, sourceCode),
        }, { highlightCode: false }));
    }
    if (options.showSelector) {
        result.push(`${kleur__default.default.bold("Selector:")} ${(_a = message.selector) !== null && _a !== void 0 ? _a : "-"}`);
    }
    if (options.showLink && message.ruleUrl) {
        result.push(`${kleur__default.default.bold("Details:")} ${message.ruleUrl}`);
    }
    return result.join("\n");
}
/**
 * Gets the formatted output summary for a given number of errors and warnings.
 * @param errors - The number of errors.
 * @param warnings - The number of warnings.
 * @returns The formatted output summary.
 */
function formatSummary(errors, warnings) {
    const summaryColor = errors > 0 ? "red" : "yellow";
    const summary = [];
    if (errors > 0) {
        summary.push(`${errors} ${pluralize("error", errors)}`);
    }
    if (warnings > 0) {
        summary.push(`${warnings} ${pluralize("warning", warnings)}`);
    }
    return kleur__default.default[summaryColor]().bold(`${summary.join(" and ")} found.`);
}
function codeframe(results, options) {
    const merged = { ...defaults, ...options };
    let errors = 0;
    let warnings = 0;
    const resultsWithMessages = results.filter((result) => result.messages.length > 0);
    let output = resultsWithMessages
        .reduce((resultsOutput, result) => {
        const messages = result.messages.map((message) => {
            return `${formatMessage(message, result, merged)}\n\n`;
        });
        errors += result.errorCount;
        warnings += result.warningCount;
        return resultsOutput.concat(messages);
    }, [])
        .join("\n");
    if (merged.showSummary) {
        output += "\n";
        output += formatSummary(errors, warnings);
        output += "\n";
    }
    return errors + warnings > 0 ? output : "";
}

function jsonFormatter(results) {
    return JSON.stringify(results);
}
const formatter$2 = jsonFormatter;
var json = formatter$2;

function linkSummary(results) {
    const urls = results.reduce((result, it) => {
        const urls = it.messages
            .map((error) => error.ruleUrl)
            .filter((error) => Boolean(error));
        return [...result, ...urls];
    }, []);
    const unique = Array.from(new Set(urls));
    if (unique.length === 0) {
        return "";
    }
    const lines = unique.map((url) => `  ${url}\n`);
    return `\n${kleur__default.default.bold("More information")}:\n${lines.join("")}\n`;
}
function stylish(results) {
    const errors = stylish$2.stylish(results.map((it) => ({
        ...it,
        fixableErrorCount: 0,
        fixableWarningCount: 0,
    })));
    const links = linkSummary(results);
    return `${errors}${links}`;
}
const formatter$1 = stylish;
var stylish$1 = formatter$1;

function textFormatter(results) {
    let output = "";
    let total = 0;
    results.forEach((result) => {
        const messages = result.messages;
        if (messages.length === 0) {
            return;
        }
        total += messages.length;
        output += messages
            .map((message) => {
            let messageType;
            if (message.severity === 2) {
                messageType = "error";
            }
            else {
                messageType = "warning";
            }
            const location = `${result.filePath}:${message.line}:${message.column}`;
            return `${location}: ${messageType} [${message.ruleId}] ${message.message}\n`;
        })
            .join("");
    });
    return total > 0 ? output : "";
}
const formatter = textFormatter;
var text = formatter;

const availableFormatters = {
    checkstyle,
    codeframe,
    json,
    stylish: stylish$1,
    text,
};
function getFormatter(name) {
    var _a;
    return (_a = availableFormatters[name]) !== null && _a !== void 0 ? _a : null;
}

/**
 * @internal
 */
function compatibilityCheckImpl(name, declared, options) {
    const { silent, version: current, logger } = options;
    const valid = semver__default.default.satisfies(current, declared);
    if (valid || silent) {
        return valid;
    }
    const text = [
        "-----------------------------------------------------------------------------------------------------",
        `${name} requires html-validate version "${declared}" but current installed version is ${current}`,
        "This is not a supported configuration. Please install a supported version before reporting bugs.",
        "-----------------------------------------------------------------------------------------------------",
    ].join("\n");
    logger(text);
    return false;
}

exports.Attribute = Attribute;
exports.Config = Config;
exports.ConfigError = ConfigError;
exports.ConfigLoader = ConfigLoader;
exports.DOMNode = DOMNode;
exports.DOMTokenList = DOMTokenList;
exports.DOMTree = DOMTree;
exports.DynamicValue = DynamicValue;
exports.EventHandler = EventHandler;
exports.HtmlElement = HtmlElement;
exports.HtmlValidate = HtmlValidate;
exports.MetaCopyableProperty = MetaCopyableProperty;
exports.MetaTable = MetaTable;
exports.NestedError = NestedError;
exports.Parser = Parser;
exports.Presets = Presets;
exports.Reporter = Reporter;
exports.ResolvedConfig = ResolvedConfig;
exports.Rule = Rule;
exports.SchemaValidationError = SchemaValidationError;
exports.StaticConfigLoader = StaticConfigLoader;
exports.TextNode = TextNode;
exports.UserError = UserError;
exports.Validator = Validator;
exports.WrappedError = WrappedError;
exports.bugs = bugs;
exports.classifyNodeText = classifyNodeText;
exports.codeframe = codeframe;
exports.compatibilityCheckImpl = compatibilityCheckImpl;
exports.definePlugin = definePlugin;
exports.ensureError = ensureError;
exports.getFormatter = getFormatter;
exports.keywordPatternMatcher = keywordPatternMatcher;
exports.name = name;
exports.ruleExists = ruleExists;
exports.sliceLocation = sliceLocation;
exports.staticResolver = staticResolver;
exports.version = version;
//# sourceMappingURL=core.js.map
