'use strict';

var fs = require('fs');
var path = require('node:path');
var kleur = require('kleur');
var minimist = require('minimist');
var core = require('./core.js');
var cli$1 = require('./cli.js');
require('ajv');
require('deepmerge');
require('./elements.js');
require('./meta-helper.js');
require('./utils/natural-join.js');
require('@sidvind/better-ajv-errors');
require('@babel/code-frame');
require('@html-validate/stylish');
require('semver');
require('./core-nodejs.js');
require('node:fs');
require('glob');
require('ignore');
require('prompts');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var kleur__default = /*#__PURE__*/_interopDefault(kleur);
var minimist__default = /*#__PURE__*/_interopDefault(minimist);

var _a;
function getMode(argv) {
    if (argv.init) {
        return cli$1.Mode.INIT;
    }
    if (argv["dump-events"]) {
        return cli$1.Mode.DUMP_EVENTS;
    }
    if (argv["dump-source"]) {
        return cli$1.Mode.DUMP_SOURCE;
    }
    if (argv["dump-tokens"]) {
        return cli$1.Mode.DUMP_TOKENS;
    }
    if (argv["dump-tree"]) {
        return cli$1.Mode.DUMP_TREE;
    }
    if (argv["print-config"]) {
        return cli$1.Mode.PRINT_CONFIG;
    }
    return cli$1.Mode.LINT;
}
function requiresFilename(mode) {
    switch (mode) {
        case cli$1.Mode.LINT:
            return true;
        case cli$1.Mode.INIT:
            return false;
        case cli$1.Mode.DUMP_EVENTS:
        case cli$1.Mode.DUMP_TOKENS:
        case cli$1.Mode.DUMP_TREE:
        case cli$1.Mode.DUMP_SOURCE:
        case cli$1.Mode.PRINT_CONFIG:
            return true;
    }
}
function handleValidationError(err) {
    if (err.filename) {
        const filename = path__default.default.relative(process.cwd(), err.filename);
        console.log(kleur__default.default.red(`A configuration error was found in "${filename}":`));
    }
    else {
        console.log(kleur__default.default.red(`A configuration error was found:`));
    }
    console.group();
    {
        console.log(err.prettyError());
    }
    console.groupEnd();
}
function handleUserError(err) {
    var _a;
    const formatted = err.prettyFormat();
    if (formatted) {
        console.error(); /* blank line */
        console.error(formatted);
        return;
    }
    console.error(kleur__default.default.red("Caught exception:"));
    console.group();
    {
        console.error((_a = err.prettyFormat()) !== null && _a !== void 0 ? _a : err);
    }
    console.groupEnd();
}
function handleUnknownError(err) {
    console.error(kleur__default.default.red("Caught exception:"));
    console.group();
    {
        console.error(err);
    }
    console.groupEnd();
    const bugUrl = `${core.bugs}?issuable_template=Bug`;
    console.error(kleur__default.default.red(`This is a bug in ${core.name}-${core.version}.`));
    console.error(kleur__default.default.red([
        `Please file a bug at ${bugUrl}`,
        `and include this message in full and if possible the content of the`,
        `file being parsed (or a reduced testcase).`,
    ].join("\n")));
}
const argv = minimist__default.default(process.argv.slice(2), {
    string: ["c", "config", "ext", "f", "formatter", "max-warnings", "rule", "stdin-filename"],
    boolean: [
        "init",
        "dump-events",
        "dump-source",
        "dump-tokens",
        "dump-tree",
        "h",
        "help",
        "print-config",
        "stdin",
        "version",
    ],
    alias: {
        c: "config",
        f: "formatter",
        h: "help",
    },
    default: {
        ext: "html",
        formatter: "stylish",
    },
    unknown: (opt) => {
        if (opt.startsWith("-")) {
            process.stderr.write(`unknown option ${opt}\n`);
            process.exit(1);
        }
        return true;
    },
});
function showUsage() {
    process.stdout.write(`${core.name}-${core.version}
Usage: html-validate [OPTIONS] [FILENAME..] [DIR..]

Common options:
      --ext=STRING               specify file extensions (commaseparated).
  -f, --formatter=FORMATTER      specify the formatter to use.
      --max-warnings=INT         number of warnings to trigger nonzero exit code
      --rule=RULE:SEVERITY       set additional rule, use comma separator for
                                 multiple.
      --stdin                    process markup from stdin.
      --stdin-filename=STRING    specify filename to report when using stdin

Miscellaneous:
  -c, --config=STRING            use custom configuration file.
      --init                     initialize project with a new configuration
      --print-config             output configuration for given file.
  -h, --help                     show help.
      --version                  show version.

Debugging options:
      --dump-events              output events during parsing.
      --dump-source              output post-transformed source data.
      --dump-tokens              output tokens from lexing stage.
      --dump-tree                output nodes from the dom tree.

Formatters:

Multiple formatters can be specified with a comma-separated list,
e.g. "json,checkstyle" to enable both.

To capture output to a file use "formatter=/path/to/file",
e.g. "checkstyle=dist/html-validate.xml"
`);
}
function showVersion() {
    process.stdout.write(`${core.name}-${core.version}\n`);
}
if (argv.stdin) {
    argv._.push("-");
}
if (argv.version) {
    showVersion();
    process.exit();
}
if (argv.help) {
    showUsage();
    process.exit();
}
if (argv._.length === 0) {
    const mode = getMode(argv);
    if (mode === cli$1.Mode.LINT) {
        showUsage();
        process.exit(0);
    }
    else if (requiresFilename(mode)) {
        const flag = cli$1.modeToFlag(mode);
        console.error(`\`${flag}\` requires a filename.`);
        process.exit(1);
    }
}
/* check that supplied config file exists before creating CLI */
if (typeof argv.config !== "undefined") {
    const checkPath = path__default.default.resolve(argv.config);
    if (!fs__default.default.existsSync(checkPath)) {
        console.log(`The file "${String(argv.config)}" was not found.`);
        console.log(`The location this file was checked for at was: "${String(checkPath)}"`);
        process.exit(1);
    }
}
const cli = new cli$1.CLI({
    configFile: argv.config,
    rules: argv.rule,
});
const mode = getMode(argv);
const formatter = cli.getFormatter(argv.formatter);
const maxWarnings = parseInt((_a = argv["max-warnings"]) !== null && _a !== void 0 ? _a : "-1", 10);
const htmlvalidate = cli.getValidator();
/* sanity check: ensure maxWarnings has a valid value */
if (isNaN(maxWarnings)) {
    console.log(`Invalid value "${String(argv["max-warnings"])}" given to --max-warnings`);
    process.exit(1);
}
/* parse extensions (used when expanding directories) */
const extensions = argv.ext.split(",").map((cur) => {
    return cur.startsWith(".") ? cur.slice(1) : cur;
});
const files = cli.expandFiles(argv._, { extensions });
if (files.length === 0 && mode !== cli$1.Mode.INIT) {
    console.error("No files matching patterns", argv._);
    process.exit(1);
}
async function run() {
    var _a;
    try {
        let success;
        if (mode === cli$1.Mode.LINT) {
            success = await cli$1.lint(htmlvalidate, process.stdout, files, {
                formatter,
                maxWarnings,
                stdinFilename: (_a = argv["stdin-filename"]) !== null && _a !== void 0 ? _a : false,
            });
        }
        else if (mode === cli$1.Mode.INIT) {
            success = await cli$1.init(cli, process.stdout, { cwd: process.cwd() });
        }
        else if (mode === cli$1.Mode.PRINT_CONFIG) {
            success = await cli$1.printConfig(htmlvalidate, process.stdout, files);
        }
        else {
            success = await cli$1.dump(htmlvalidate, process.stdout, files, mode);
        }
        process.exit(success ? 0 : 1);
    }
    catch (err) {
        if (err instanceof core.SchemaValidationError) {
            handleValidationError(err);
        }
        else if (err instanceof core.UserError) {
            handleUserError(err);
        }
        else {
            handleUnknownError(err);
        }
        process.exit(1);
    }
}
run().catch((err) => {
    console.error(err);
    process.exit(1);
});
//# sourceMappingURL=html-validate.js.map
